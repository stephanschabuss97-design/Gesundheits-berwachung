
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Gesundheits-Logger (V1.7.3.6)</title>
<style>

/* ANKER: chart-controls styles (move to assets/app.css bei naechster Release) */
  /* Dropdown optisch kompakter */
  #chart .controls .compact { max-width: 240px; }

  /* KPI-Zeile: -Werte neben dem Dropdown */
  #chart .controls .kpis {
    display: inline-flex;
    gap: 16px;
    align-items: center;
    margin-left: 16px;
    color: var(--text, #e5e7eb);
    font-size: 0.95rem;
    white-space: nowrap;
  }
  #chart .controls .kpis .sep { opacity: .6; }
  
body.auth-locked main{ opacity:.6; }
:root {
  --bg:#0b0c10;
  --card:#15171c;
  --fg:#e8e8e8;
  --muted:#9aa3af;
  --accent:#4f46e5;
  --warn:#f59e0b;
  --ok:#10b981;
  --danger:#ef4444;
  --header-h:56px;
  --tabs-h:48px;
}
*{box-sizing:border-box}
.sr-only{
  position:absolute;
  width:1px;
  height:1px;
  padding:0;
  margin:-1px;
  overflow:hidden;
  clip:rect(0,0,0,0);
  white-space:nowrap;
  border:0;
}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial;background:var(--bg);color:var(--fg);-webkit-tap-highlight-color:transparent;touch-action:manipulation;overscroll-behavior-y:none}
header{position:sticky;top:0;background:linear-gradient(180deg,rgba(11,12,16,.95),rgba(11,12,16,.7));backdrop-filter:blur(6px);z-index:10;padding:10px 12px;border-bottom:1px solid #1f232b}
h1{margin:0;font-size:20px}
nav.tabs{display:flex;gap:8px;padding:8px 12px;position:sticky;top:var(--header-h,56px);background:rgba(11,12,16,.9);backdrop-filter:blur(6px);z-index:11}
nav.tabs button{flex:1;min-width:100px;touch-action:manipulation}
main{padding:12px;position:relative;z-index:1;padding-top:calc(var(--header-h,56px) + var(--tabs-h,48px) + 8px)}
.card{background:var(--card);border:1px solid #242833;border-radius:16px;padding:14px;margin-bottom:12px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
.row{display:flex;gap:8px;flex-wrap:wrap}
.grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
@media (max-width:640px){ .grid{grid-template-columns:1fr} }
label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
input, select, textarea {width:100%;padding:12px;border-radius:12px;border:1px solid #2b2f3a;background:#0f1116;color:var(--fg);font-size:16px;scroll-margin-top:calc(var(--header-h,56px) + var(--tabs-h,48px) + 8px)}
textarea{min-height:64px;resize:vertical}

.small{font-size:12px;color:var(--muted)}
.btn{appearance:none;border:none;border-radius:12px;padding:12px 14px;font-weight:600;color:white;background:#2b2f3a;cursor:pointer;touch-action:manipulation;transition: background .25s ease, color .25s ease, transform .06s ease, box-shadow .25s ease}
.btn:disabled{opacity:.6;cursor:not-allowed}
.btn:active{ transform: scale(0.98) }
.btn.primary{background:var(--accent)}
.btn.ghost{background:#0f1116;border:1px solid #2b2f3a;color:var(--fg)}
.btn.warn{background:var(--warn);color:#1a1200}
.btn.toggle.active{ background: var(--ok); color:#06110b; border-color: transparent; }
/* Tabs: aktiver Zustand = wie Primary */
nav.tabs .btn.primary {
  background: var(--accent);
  color: #fff;
  border-color: transparent;
}
details.accordion{
  background:#11131a;
  border:1px solid #232735;
  border-radius:16px;
  margin:12px 0;
  overflow:hidden;
}
details.accordion summary{
  list-style:none;
  cursor:pointer;
  padding:14px 18px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  font-weight:600;
}
details.accordion summary::-webkit-details-marker{display:none;}
details.accordion .chevron{transition:transform .2s ease;}
details.accordion[open] .chevron{transform:rotate(90deg);}
details.accordion .accordion-body{padding:0 18px 16px;}
.bp-pane{display:none;}
.bp-pane.active{display:block;}
.panel-actions{display:flex;gap:8px;justify-content:flex-start;margin:12px 0 0;}
.panel-actions .btn{min-width:180px;}
.card-nested{
  background:#11131a;
  border:1px solid #232735;
  border-radius:12px;
  padding:14px;
  margin-top:12px;
}
.card-nested:first-of-type{margin-top:10px;}
.card-nested h3.blockTitle{margin-top:0;}
@media (max-width:640px){
  details.accordion summary{padding:12px 14px;}
  details.accordion .accordion-body{padding:0 14px 14px;}
}


.btn.flash{background:linear-gradient(90deg,var(--accent) 0%,#7c3aed 50%,var(--accent) 100%)!important;background-size:200% 100%;color:#fff!important;animation:flashGradient 1s ease forwards,flashPop .2s ease;box-shadow:0 6px 24px rgba(79,70,229,.35)}
@keyframes flashGradient{0%{background-position:0% 50%}100%{background-position:100% 50%}}
@keyframes flashPop {
0% { transform: scale(1) }
50% { transform: scale(1.03) }
100% { transform: scale(1) }
}

/* Toolbar mit zentrierter Mitte + Badges rechts */
#doctorCard .toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: space-between; /* Titel links + Mitte + Badges rechts */
}

#doctorCard .toolbar .center-group {
  flex: 1;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center; /* Buttons + Datum + Anwenden mittig */
}

#doctorCard .toolbar .badge {
  margin-left: 8px;
}

.spacer{flex:1}
section.view{display:none}
section.view.active{display:block}

#doctorCard .toolbar{border-bottom:1px solid #242833;padding-bottom:8px;margin-bottom:8px}

#err{position:fixed;left:8px;right:8px;bottom:8px;background:#3d0d0d;color:#fecaca;padding:8px 10px;border-radius:10px;display:none;z-index:9999}

/* === Arzt-Ansicht (Daily): 3-Spalten-Layout je Tag === */
.doctor-view .doctor-day{
display:grid;
grid-template-columns: 1fr; /* Standard = gestapelt */
gap:12px;
align-items:start;
padding:12px 14px;
margin:8px 0;
border-radius:12px;
background:var(--card);
border:1px solid #242833;
box-shadow:0 6px 18px rgba(0,0,0,.25);
page-break-inside:avoid;
break-inside:avoid;
}

  /* --- Arzt-Toolbar Badges (Daily KPIs) --- */
.badge {
  display: inline-block;
  padding: 6px 12px;         /* etwas mehr Platz */
  border: 1.5px solid #2b2f3a;
  border-radius: 12px;       /* runder = moderner */
  font-size: 13px;           /* +1pt groesser */
  font-weight: 600;          /* kraeftiger */
  margin-left: 10px;
}
.badge.good{border-color:var(--ok); color:var(--ok)}
.badge.bad{ border-color:var(--danger); color:var(--danger)}
.badge.hidden{ display:none !important; }

/* Tablet/Desktop: nebeneinander */
@media (min-width: 900px){
.doctor-view .doctor-day{
grid-template-columns: 18% 46% 36%;
}
}

/* Zwischenbereich: 2 Spalten */
@media (min-width: 600px) and (max-width: 899px){
.doctor-view .doctor-day{
grid-template-columns: 40% 60%;
grid-template-areas:
"date measure"
"date special";
}
.doctor-view .col-date{ grid-area: date; }
.doctor-view .col-measure{ grid-area: measure; }
.doctor-view .col-special{ grid-area: special; }
}

/* Spalte A - Datum */
.doctor-view .col-date{
display:flex; align-items:center;
font-weight:800;
font-size:clamp(16px,1.6vw,20px);
letter-spacing:.2px;
}
  /* Datumsspalte mit Cloud + Delete untereinander */
.doctor-view .col-date{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.doctor-view .col-date .date-top{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}
.doctor-view .col-date .date-label{
  font-weight:800;
  font-size:clamp(16px,1.6vw,20px);
  letter-spacing:.2px;
}
.doctor-view .col-date .date-cloud{ font-size:16px; line-height:1; }
.doctor-view .col-date .date-actions{
  display:flex;
  justify-content:flex-start; /* oder center, wenn du's mittig magst */
}
.btn-xs{ padding:6px 10px; font-size:12px; border-radius:8px; }

/* Spalte B - Messungen */
.doctor-view .col-measure{ display:grid; grid-template-rows:auto 1fr; gap:6px; }
/* Kopf und Werte-Spalten: gleiche Breiten wie Zahlen, Label links fix */
.doctor-view .measure-head,
.doctor-view .measure-grid{
display:grid;
grid-template-columns: minmax(70px, auto) repeat(4, 1fr);
gap:4px;
}
.doctor-view .measure-head{ font-size:12px; opacity:.8; }


/* Head-Zellen als Flex: rechtsbuendig wie die Zahlen */
.doctor-view .measure-head > div{ display:flex; align-items:center; }
.doctor-view .measure-head > div:first-child{ justify-content:flex-start; }
.doctor-view .measure-head > div:not(:first-child){ justify-content:flex-end; }
.doctor-view .measure-row{ display:contents; }
.doctor-view .label{ display:flex; align-items:center; font-size:13px; opacity:.9; }

/* Zahlenbild */
.doctor-view .num{
font-variant-numeric: tabular-nums lining-nums;
-moz-font-feature-settings:"tnum","lnum";
-webkit-font-feature-settings:"tnum","lnum";
font-feature-settings:"tnum","lnum";
text-align:right;
display:flex; align-items:center; justify-content:flex-end;

min-width: 4ch; /* Basisschutz gegen Abschneiden */
white-space: nowrap;
}
  
  /* Grenzwert-Highlight fuer Arzt-Ansicht */
.doctor-view .num.alert{ color: var(--danger); }

.doctor-view .measure-grid .num,
.doctor-view .col-special .num{
text-align:right; justify-content:flex-end;
}

/* Spalte C - Spezialinfos */
/* Gewicht: Ueberschrift + Zahl darunter */
.doctor-view .weight-line,
.doctor-view .waist-line{
  display:flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  background: transparent;
  border: none;
  padding: 0;
  font-weight: 600;
}

.doctor-view .weight-line > :first-child,
.doctor-view .waist-line > :first-child{
  font-size: 12px;
  opacity:.8;
  font-weight:600;
  letter-spacing:.2px;
}

.doctor-view .weight-line .num,
.doctor-view .waist-line .num{
  font-size:clamp(16px,1.6vw,20px);
  font-weight:700;
  line-height:1.1;
  text-align:center;
}

/* Spalten C/D/E: Gewicht | Flags | Kommentar */
.doctor-view .col-special{
  display: grid;
  grid-template-columns: minmax(120px, max-content) 220px 1fr; /* C | D | E */
  column-gap: 16px;
  row-gap: 6px;
  align-items: start; /* <-- alles oben ausrichten */
}

/* Elemente gezielt in Spalten setzen */
.doctor-view .col-special > .weight-line,
.doctor-view .col-special > .waist-line { grid-column: 1; }
.doctor-view .col-special > .flags       { grid-column: 2; }
.doctor-view .col-special > .notes       { grid-column: 3; }

/* D: Flags - Desktop: eine Spalte untereinander */
.doctor-view .flags{
  display:grid;
  grid-template-columns: repeat(2, max-content); /* 2 Spalten */
  justify-content:start;
  align-items:start;
  gap: 6px 16px; /* vertikal 6px, horizontal 16px */
}

.doctor-view .weight-line .num,
.doctor-view .waist-line .num{ font-variant-numeric: tabular-nums; } /* Spalten wirken ruhiger */
.doctor-view .flag span:last-child{ white-space:nowrap; }
.doctor-view .flag{ display:grid; grid-template-columns:18px 1fr; align-items:center; gap:6px; font-size:12px; opacity:.95; }
.doctor-view .flag-box{
width:16px; height:16px; border:1.5px solid #2b2f3a; border-radius:3px; display:inline-block; position:relative;
}
.doctor-view .flag-box.on::after{
content:""; position:absolute; inset:2px; background:var(--accent); border-radius:2px;
}

/* Notizen: im Screen 3 Zeilen, im Druck voll */
/* Kommentar: Titel + Box */
/* Kommentar: Kopf + Wert, ohne Kasten */
.doctor-view .notes{
  font-size: 13px;
  line-height: 1.35;
  display: -webkit-box;
  -webkit-line-clamp: 3;      /* 3 Zeilen, bei Bedarf 2 setzen */
  -webkit-box-orient: vertical;
  overflow: hidden;
  word-break: break-word;
  padding: 0;                 /* kein Box-Feeling */
  background: transparent;
  border: none;
}
.doctor-view .notes::before{
  content: "Kommentar";
  display: block;
  font-size: 12px;
  opacity: .8;
  font-weight: 600;
  letter-spacing: .2px;
  margin-bottom: 4px;
}
/* NICHT ausblenden, auch wenn leer - der Renderer liefert "-" */

/* Mobile-Optimierung */
@media (max-width: 599px){

  /* Kopf & Werte: schmaelere Label-Spalte + garantierte Zahlbreite */
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(72px, 1fr) repeat(4, minmax(56px, 1fr));
  }
  .doctor-view .measure-head{ font-size: 11px; }

  /* Zahlen duerfen nicht schrumpfen  keine abgeschnittenen Dezimalstellen */
  .doctor-view .num{
    min-width: 4.5ch; /* ~ "96.7" passt sicher */
    white-space: nowrap;
    flex: 0 0 auto;
  }
.doctor-view .col-special .weight-line .num,
.doctor-view .col-special .waist-line .num{
  min-width: 5ch;
}

  /* Spalten: Gewicht | Flags nebeneinander, Kommentar darunter ueber volle Breite */
  .doctor-view .col-special{
    grid-template-columns: minmax(110px, max-content) 1fr; /* Flags bekommen flex Breite */
    column-gap: 12px;
  }
  .doctor-view .col-special > .notes{
    grid-column: 1 / -1; /* Kommentar ueber beide Spalten */
  }

  /* Kommentar: mobil 4 Zeilen anzeigen */
  .doctor-view .notes{
    -webkit-line-clamp: 4; /* bei Bedarf auf 5 erhoehen */
  }

  /* Flags: kompakt in 2 Spalten, keine abgeschnittenen Labels */
  .doctor-view .flags{
    display: grid;
    grid-template-columns: repeat(2, max-content);
    justify-content: start;
    align-items: center;
    column-gap: 14px;
    row-gap: 6px;
    margin-top: 6px;
  }
  .doctor-view .flag span:last-child{ white-space: nowrap; }
}

/* Extra-eng ( 390px Breite) */
@media (max-width: 390px){
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(66px, 1fr) repeat(4, minmax(50px, 1fr));
  }
  .doctor-view .flags{
    grid-template-columns: repeat(3, max-content);
  }
}

/* Panels */
.panel{position:fixed;right:8px;bottom:8px;max-height:80vh;overflow:auto;background:#0f1116;border:1px solid #2b2f3a;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.35);display:none;z-index:9998}
/* Panel (Charts) - Fullscreen */
.panel.chart{
  inset: 0;                 /* volle Flaeche (top/right/bottom/left = 0) */
  width: 100vw;
  height: 100dvh;           /* korrekt auf Mobile (sichtbare Hoehe) */
  max-width: 100vw;
  max-height: 100dvh;
  border-radius: 0;         /* keine abgerundeten Ecken im Vollbild */
}

/* Flex-Layout: Header fix oben, Inhalt fuellt Rest */
.panel.chart{
  /* Sichtbarkeit steuert JS; NICHT auf block setzen */
}
.panel.chart header{ 
  /* bleibt oben, keine Aenderung noetig - aber fixere Hoehe ist hilfreich */
  min-height: 44px;
}
.panel.chart .content{
  /* Inhalt fuellt den verfuegbaren Raum */
  height: calc(100dvh - 44px - 2px); /* 44px Header + 1px border oben/unten */
  display: flex;
  flex-direction: column;
  overflow: auto;
}
.panel header{display:flex;gap:6px;align-items:center;justify-content:space-between;padding:8px;border-bottom:1px solid #2b2f3a}
.panel h4{margin:0;font-size:14px}
.panel .content{
  padding: 12px;
  font-size: 13px;
  line-height: 1.45;
}
#diag pre{margin:0;padding:8px;font-size:12px;white-space:pre-wrap}

/* FABs */
.fab-wrap{position:fixed;right:8px;bottom:8px;display:flex;flex-direction:column;gap:8px;z-index:9999}
.fab{width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;border:1px solid #2b2f3a;background:#0f1116;cursor:pointer}
.fab:hover{box-shadow:0 8px 24px rgba(0,0,0,.35)}

/* Chart panel */
#chart .controls{
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  margin-bottom:6px;
}
/* ANKER: flags-overlay CSS */
#chartSvg .flags { pointer-events: auto; }
#chart .controls > * {flex:1}
#chart .controls .half{flex:0 0 calc(50% - 4px)}
  
  /* SVG fuellt verbleibende Hoehe vollstaendig */
#chart svg{
  flex: 1 1 auto;
  width: 100%;
  height: 100%;     /* statt auto */
  min-height: 160px;
  display: block;
  background: #0f1116;
  border: 1px solid #2b2f3a;
  border-radius: 10px;
}

#chart .legend{display:flex;gap:10px;font-size:12px;color:var(--muted);margin-top:6px;flex-wrap:wrap}

.dot{width:8px;height:8px;border-radius:50%;display:inline-block;margin-right:6px;border:1px solid #000}

/* Busy overlay */
#busy{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);z-index:99998}
#busy .box{background:#10131a;border:1px solid #2b2f3a;border-radius:12px;padding:12px 16px;font-weight:600}

.seg{display:flex;gap:8px;margin:8px 0 12px}
.seg .seg-btn.active{background:var(--accent);color:#fff}
.hidden{display:none!important}
:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

/* App-Lock Overlay */
#appLock{
  position: fixed; inset: 0; z-index: 10001;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.45); backdrop-filter: blur(2px);
}
#appLock .lock-card{
  width: min(420px, 92vw);
  background: #fff; color: #111;
  border-radius: 16px; padding: 18px;
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
  border: 1px solid #e5e7eb;
}
#appLock .lock-card h3{ margin: 0 0 6px; }
#appLock .btn.primary{ background: var(--accent); color: #fff; }
#appLock .pin-wrap{ display:flex; gap:8px; margin-top:8px; }
#appLock .pin-wrap input{
  flex:1; background:#f8fafc; color:#111; border:1px solid #e5e7eb;
}

/* Body-State: solange gelockt ist, Interaktion sperren (Overlay deckt ohnehin ab) */
body.app-locked main, body.app-locked nav, body.app-locked header{
  filter: blur(0); /* bewusst ohne Blur, nur visuelles Dimmen optional */
}
body.app-locked { pointer-events: auto; } /* Overlay nimmt Events ab */

/* Login-Overlay */
#loginOverlay{

  position: fixed; inset: 0; z-index: 10000;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.35); backdrop-filter: blur(2px);
}
#loginOverlay .login-card{
  width: min(420px, 92vw);
  background: #fff; color: #111;
  border-radius: 16px; padding: 18px;
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
  border: 1px solid #e5e7eb;
}
#loginOverlay .login-card h3{ margin: 0 0 6px; }
  #loginOverlay .btn.primary{ background: var(--accent); color: #fff; }
  
/* Lifestyle progress: modern look */
#lifestyle .progress, #cap-intake-wrap .progress { position: relative; width:100%; height:18px; background:#0f1116; border:1px solid #2b2f3a; border-radius:999px; overflow:hidden; margin-top:8px; }
#lifestyle .progress .bar, #cap-intake-wrap .progress .bar { height:100%; width:0%; background:linear-gradient(90deg,var(--accent),#7c3aed); transition: width .35s ease, filter .2s ease; box-shadow: inset 0 0 0 1px rgba(79,70,229,.25); }
#lifestyle .progress .label, #cap-intake-wrap .progress .label { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:600; color:rgba(255,255,255,.9); text-shadow:0 1px 2px rgba(0,0,0,.6); pointer-events:none; }
#lifestyle .progress.ok   .bar, #cap-intake-wrap .progress.ok   .bar { background:linear-gradient(90deg,#10b981,#34d399); box-shadow: inset 0 0 0 1px rgba(16,185,129,.25), 0 8px 20px rgba(16,185,129,.18); }
#lifestyle .progress.warn .bar, #cap-intake-wrap .progress.warn .bar { background:linear-gradient(90deg,#f59e0b,#fbbf24); box-shadow: inset 0 0 0 1px rgba(245,158,11,.25), 0 8px 20px rgba(245,158,11,.18); }
#lifestyle .progress.bad  .bar, #cap-intake-wrap .progress.bad  .bar { background:linear-gradient(90deg,#ef4444,#f87171); box-shadow: inset 0 0 0 1px rgba(239,68,68,.25), 0 8px 20px rgba(239,68,68,.18); }
#lifestyle .progress.neutral .bar, #cap-intake-wrap .progress.neutral .bar { background:linear-gradient(90deg,#6b7280,#9ca3af); box-shadow: inset 0 0 0 1px rgba(107,114,128,.25); }
@media (hover:hover){
  #lifestyle .progress:hover .bar, #cap-intake-wrap .progress:hover .bar { filter:brightness(1.05); }
}

/* Intake status pills (Capture) */
#cap-intake-status { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
.pill { display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:600; background:#0f1116; border:1px solid #2b2f3a; color:#e5e7eb; }
.pill .dot { width:8px; height:8px; border-radius:50%; background:#6b7280; box-shadow:0 0 0 1px rgba(15,17,22,.6); }
.pill.ok .dot { background:#10b981; }
.pill.warn .dot { background:#f59e0b; }
.pill.bad .dot { background:#ef4444; }
.pill.neutral .dot { background:#7c3aed; }
.body-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;}
.capture-header{ display:flex; flex-direction:column; gap:8px; }
.capture-header .capture-date{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
.capture-header .capture-pills{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.capture-header .capture-pills .pill{ margin:0; }


/* Arzttermine Skeleton */
#appointmentsWrap {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.appointment-card {
  background: #11131a;
  border: 1px solid #232735;
  border-radius: 12px;
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.appointment-card h3 {
  margin: 0;
}
.appointment-inputs {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: flex-end;
}
.appointment-inputs > div {
  flex: 1 1 160px;
  min-width: 160px;
}
.appointment-inputs .btn-wrap {
  flex: 0 0 auto;
}
.appointment-inputs .btn-wrap button {
  min-width: 140px;
}
.appointment-line {
  display: flex;
  gap: 8px;
  align-items: center;
}
.appointment-line .label {
  opacity: .75;
}
.appointment-line .value {
  font-weight: 600;
}
.appointment-line button {
  margin-left: auto;
}
@media (max-width: 640px) {
  .appointment-inputs > div {
    flex: 1 1 100%;
  }
  .appointment-inputs .btn-wrap button {
    width: 100%;
  }
  .appointment-line {
    flex-wrap: wrap;
    gap: 6px;
  }
  .appointment-line button {
    margin-left: 0;
  }
}

/* --- SAFETY: versteckte Dinge fangen keine Klicks --- */
[hidden] {
  display: none !important;
  pointer-events: none !important;
}

/* Versteckte Overlays fangen niemals Pointer-Events */
#loginOverlay[hidden],
#appLock[hidden],
#loginOverlay.is-hidden,
#appLock.is-hidden {
  display: none !important;
  pointer-events: none !important;
}

/* --- SAFETY: summary darf nie full-screen ?oben? liegen --- */
summary {
  display: list-item;
  position: static !important;
  z-index: auto !important;
  pointer-events: auto !important;
}
details[open] > summary {
  position: static !important;
}

/* Falls Details per hidden versteckt werden */
details[hidden] {
  display: none !important;
  pointer-events: none !important;
}

/* Optional: Config-Accordion im Login-Overlay explizit entsch?rfen */
#configAdv > summary { position: static !important; }

</style>
</head>
<body>
<!-- ANKER: touch-log-fallback -->
<pre id="touchLog" style="display:none;position:fixed;bottom:0;left:0;right:0;max-height:40vh;overflow:auto;background:#111;color:#eee;font-size:12px;padding:4px;z-index:10000"></pre>

<header>
<div style="display:flex;align-items:center;gap:10px">
<h1>Gesundheits-Logger</h1><span class="small">V1.7.3.6</span>
<div class="spacer"></div>
<button class="btn ghost" id="helpToggle" type="button">Hilfe</button>
<button class="btn ghost" id="diagToggle" type="button">Log</button>
</div>
</header>

<nav class="tabs">
<button class="btn ghost" data-tab="capture" id="tab-capture" type="button">Erfassen</button>
<button class="btn ghost" data-tab="doctor" id="tab-doctor" type="button">Arzt-Ansicht</button>
</nav>

<!-- Hilfe-Panel -->
<div id="help" class="panel" role="dialog" aria-modal="false" aria-labelledby="helpTitle">
<header>
<h4 id="helpTitle">Hilfe * Was soll ich ankreuzen?</h4>
<button class="btn ghost" id="helpClose" type="button">x</button>
</header>
<div class="content">
<strong>&#x1F489; NSAR genommen</strong> ankreuzen, wenn du ein Schmerz-/Entzuendungsmedikament der Klasse NSAR genommen hast.
<ul>
<li><em>Beispiele (AT, frei):</em> Ibuprofen, Diclofenac, Naproxen.</li>
<li><em>Kombo-Achtung:</em> Viele "Erkaeltungs-/Kopfweh"-Mittel enthalten NSAR.</li>
<li><em>Bei Nierenkrankheit:</em>NSAR moeglichst vermeiden, Alternativen mit Arzt besprechen.</li>
</ul>
</div>
</div>

<!-- Diagnose-Panel -->
<div id="diag" class="panel" role="dialog" aria-modal="false" aria-labelledby="diagTitle">
<header>
<h4 id="diagTitle">Touch-Log</h4>
<button class="btn ghost" id="diagClose" type="button">x</button>
</header>
<pre id="diagLog" class="content" style="margin:0"></pre>
</div>

<!-- Diagramm-Panel (Daily) -->
<div id="chart" class="panel chart" role="dialog" aria-modal="false" aria-labelledby="chartTitle">
<header>
<h4 id="chartTitle">Diagramm (Daily)</h4>
<button class="btn ghost" id="chartClose" type="button">x</button>
</header>
<div class="content">
<div class="controls">
<select id="metricSel" class="half compact" aria-label="Messgroesse auswaehlen">
    <option value="bp">Blutdruck (Sys/Dia)</option>
    <option value="weight">Koerper</option>
</select>

  <!-- ANKER: chart-averages (Daily) -->
  <div id="chartAverages" class="kpis" aria-live="polite">
    <span data-k="sys">Durchschnitt Sys: -</span>
    <span class="sep" aria-hidden="true">*</span>
    <span data-k="dia">Durchschnitt Dia: -</span>
    <span class="sep" aria-hidden="true">*</span>
    <span data-k="map">Durchschnitt MAP: -</span>
  </div>
</div>

<svg id="chartSvg" viewBox="0 0 640 280" preserveAspectRatio="none" role="img" aria-label="Werteverlauf"></svg>
<div class="legend" id="chartLegend"></div>
<div class="small" style="opacity:.7;margin-top:6px">Zeitraum: nutzt die <em>Arzt-Ansicht</em> (von/bis).</div>
</div>
</div>

<div id="err" role="status" aria-live="polite"></div>
<div id="busy"><div class="box"> Bitte warten...</div></div>

<main id="appMain">
<!-- Capture -->
<section class="view active" id="capture" aria-labelledby="captureHeading">
 
  <h2 class="sr-only" id="captureHeading">Tageserfassung</h2>
  <!-- Daily-Capture -->
  <section class="card" id="entry">
    <div class="capture-header">
      <div class="capture-date">
        <div style="flex:0 0 220px">
          <label>Datum</label>
          <input class="compact" type="date" id="date">
        </div>
      </div>
      <div class="capture-pills" id="capturePillsRow">
        <div id="cap-intake-status-top" class="small" style="opacity:.8; display:flex; gap:8px; flex-wrap:wrap"></div>
        <span id="nextApptBadge" class="pill neutral" title="Kein Termin geplant" aria-live="polite">Kein Termin geplant</span>
      </div>
    </div>


    <details class="accordion">
      <summary><span>&#x1F4C8; Blutdruck</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
      <div class="accordion-body">
        <div class="card-nested">
          <div class="row" style="align-items:flex-end; gap:12px; flex-wrap:wrap">
            <div style="min-width:180px">
              <label for="bpContextSel">Messzeitpunkt</label>
              <select id="bpContextSel">
                <option value="M">Morgens</option>
                <option value="A">Abends</option>
              </select>
            </div>
          </div>
        </div>
        <div class="card-nested bp-pane active" data-context="M">
          <h3 class="blockTitle">Morgens</h3>
          <div class="grid">
            <div><label>Systolisch (mmHg)</label><input type="number" id="captureAmount" inputmode="numeric" placeholder="z. B. 128"></div>
            <div><label>Diastolisch (mmHg)</label><input type="number" id="diaM" inputmode="numeric" placeholder="z. B. 82"></div>
            <div><label>Puls (bpm)</label><input type="number" id="pulseM" inputmode="numeric" placeholder="z. B. 66"></div>
          </div>
          <div class="row" style="margin-top:6px">
            <textarea id="bpCommentM" class="small" placeholder="Kommentar Morgens (optional)"></textarea>
          </div>
        </div>
        <div class="card-nested bp-pane" data-context="A">
          <h3 class="blockTitle">Abends</h3>
          <div class="grid">
            <div><label>Systolisch (mmHg)</label><input type="number" id="sysA" inputmode="numeric" placeholder="z. B. 128"></div>
            <div><label>Diastolisch (mmHg)</label><input type="number" id="diaA" inputmode="numeric" placeholder="z. B. 82"></div>
            <div><label>Puls (bpm)</label><input type="number" id="pulseA" inputmode="numeric" placeholder="z. B. 66"></div>
          </div>
          <div class="row" style="margin-top:6px">
            <textarea id="bpCommentA" class="small" placeholder="Kommentar Abends (optional)"></textarea>
          </div>
        </div>
        <div class="panel-actions">
          <button class="btn primary" id="saveBpPanelBtn" type="button">&#x1F4BE; Blutdruck speichern</button>
        </div>
      </div>
    </details>

    <details class="accordion">
      <summary><span>&#x2696;&#xFE0F; Koerper</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
      <div class="accordion-body">
          <div class="card-nested">
            <h3 class="blockTitle">Koerper</h3>
            <div class="body-grid">
              <div>
                <label>Gewicht (kg)</label>
                <input type="number" step="0.1" id="weightDay" inputmode="decimal" placeholder="z. B. 84.2">
              </div>
              <div>
                <label>Bauchumfang (cm)</label>
                <input id="input-waist-cm" type="text" inputmode="decimal" autocomplete="off" placeholder="z. B. 104,5">
              </div>
              <div>
                <label>Fett (%)</label>
                <input id="fatPctDay" type="text" inputmode="decimal" autocomplete="off" placeholder="z. B. 22,5">
              </div>
              <div>
                <label>Muskel (%)</label>
                <input id="musclePctDay" type="text" inputmode="decimal" autocomplete="off" placeholder="z. B. 38,0">
              </div>
            </div>
          </div>
        
        <div class="panel-actions">
          <button class="btn primary" id="saveBodyPanelBtn" type="button">&#x1F4BE; Koerper speichern</button>
        </div>
      </div>
    </details>

    <details class="accordion" id="captureIntake">
      <summary><span>&#x1F964; Fluessigkeit & Intake</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
      <div class="accordion-body">
        <div class="card-nested" id="cap-intake-wrap">
          <h3 class="blockTitle">Intake pro Tag</h3>
          <div class="small" id="cap-intake-status" style="margin-bottom:10px;opacity:.8"></div>

          <div class="row" style="align-items:flex-end; gap:8px; flex-wrap:wrap">
            <div style="flex:1;min-width:180px">
              <label>Wasser hinzufuegen (ml)</label>
              <input type="number" id="cap-water-add" min="0" step="50" inputmode="numeric" placeholder="z. B. 250">
            </div>
            <div style="width:140px">
              <button class="btn primary" id="cap-water-add-btn" type="button">+ Menge</button>
            </div>
          </div>

          <div class="row" style="align-items:flex-end; gap:8px; flex-wrap:wrap; margin-top:12px">
            <div style="flex:1;min-width:180px">
              <label>Salz hinzufuegen (g)</label>
              <input type="text" id="cap-salt-add" inputmode="decimal" autocomplete="off" placeholder="z. B. 0,5">
            </div>
            <div style="width:140px">
              <button class="btn primary" id="cap-salt-add-btn" type="button">+ Menge</button>
            </div>
          </div>

          <div class="row" style="align-items:flex-end; gap:8px; flex-wrap:wrap; margin-top:12px">
            <div style="flex:1;min-width:180px">
              <label>Protein hinzufuegen (g)</label>
              <input type="text" id="cap-protein-add" inputmode="decimal" autocomplete="off" placeholder="z. B. 20,0">
            </div>
            <div style="width:140px">
              <button class="btn primary" id="cap-protein-add-btn" type="button">+ Menge</button>
            </div>
          </div>

          <div class="small" style="margin-top:10px;opacity:.75">
            Hinweis: Werte werden fuer das gewaehlte Datum gespeichert und synchronisiert.
          </div>
        </div>
      </div>
    </details>

    <details class="accordion">
      <summary><span>&#x1F6A9; Flags</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
      <div class="accordion-body">
        <div class="card-nested">
          <div class="row" style="align-items:center; gap:8px; flex-wrap:wrap; margin-top:0">
            <button class="btn toggle" id="trainingToggle" type="button" aria-pressed="false">&#x1F3CB;&#xFE0F; Training heute</button>
            <button class="btn toggle" id="sickToggle" type="button" aria-pressed="false">&#x1F912; Krank (Forxiga pausiert)</button>
            <button class="btn toggle" id="valsartanMissToggle" type="button" aria-pressed="false">&#x1F48A; Valsartan vergessen</button>
            <button class="btn toggle" id="forxigaMissToggle" type="button" aria-pressed="false">&#x23F0; Forxiga vergessen</button>
            <button class="btn toggle" id="lowIntakeToggle" type="button" aria-pressed="false">&#x1F4A7; &lt; 2 L getrunken</button>
            <button class="btn toggle" id="saltHighToggle" type="button" aria-pressed="false" title="> 5 g Salz">&#x1F9C2; &gt; 5 g Salz</button>
            <button class="btn toggle" id="proteinHighToggle" type="button" aria-pressed="false" title="Protein >= 90 g">&#x1F969; Protein >= 90 g</button>
            <button class="btn toggle" id="nsarToggle" type="button" aria-pressed="false" title="Nicht-steroidale Antirheumatika">&#x1F489; NSAR genommen</button>
          </div>
        </div>
        <div class="card-nested">
          <label for="flagsComment" class="small" style="display:block;margin-bottom:6px">Kommentar zu Flags</label>
          <textarea id="flagsComment" placeholder="Kommentar zu Flags (optional)" rows="2"></textarea>
        </div>
        <div class="panel-actions">
          <button class="btn primary" id="saveFlagsPanelBtn" type="button">&#x1F4BE; Flags speichern</button>
        </div>
      </div>

</details>

<details class="accordion" id="appointments">
  <summary><span>&#x1F4C5; Arzttermine</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
  <div class="accordion-body">
    <div class="card-nested" id="appointmentsWrap">
      <div class="small" style="margin-bottom:12px;opacity:.8">Pro Rolle gibt es genau einen geplanten Termin.</div>

      <div class="appointment-card" data-role="nephro">
        <h3 class="blockTitle">Nephrologe</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-nephro-date">Datum</label>
            <input type="date" id="appt-nephro-date">
          </div>
          <div>
            <label for="appt-nephro-time">Zeit</label>
            <input type="time" id="appt-nephro-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-nephro-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-line">
          <span class="label">Naechster Termin:</span>
          <span class="value" id="appt-nephro-next">&mdash;</span>
          <button class="btn ghost btn-xs" id="appt-nephro-done" type="button" disabled>Done</button>
        </div>
        <div class="appointment-line">
          <span class="label">Letzter Termin:</span>
          <span class="value" id="appt-nephro-last">&mdash;</span>
        </div>
      </div>

      <div class="appointment-card" data-role="internal">
        <h3 class="blockTitle">Internist</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-internal-date">Datum</label>
            <input type="date" id="appt-internal-date">
          </div>
          <div>
            <label for="appt-internal-time">Zeit</label>
            <input type="time" id="appt-internal-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-internal-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-line">
          <span class="label">Naechster Termin:</span>
          <span class="value" id="appt-internal-next">&mdash;</span>
          <button class="btn ghost btn-xs" id="appt-internal-done" type="button" disabled>Done</button>
        </div>
        <div class="appointment-line">
          <span class="label">Letzter Termin:</span>
          <span class="value" id="appt-internal-last">&mdash;</span>
        </div>
      </div>

      <div class="appointment-card" data-role="urology">
        <h3 class="blockTitle">Urologe</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-urology-date">Datum</label>
            <input type="date" id="appt-urology-date">
          </div>
          <div>
            <label for="appt-urology-time">Zeit</label>
            <input type="time" id="appt-urology-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-urology-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-line">
          <span class="label">Naechster Termin:</span>
          <span class="value" id="appt-urology-next">&mdash;</span>
          <button class="btn ghost btn-xs" id="appt-urology-done" type="button" disabled>Done</button>
        </div>
        <div class="appointment-line">
          <span class="label">Letzter Termin:</span>
          <span class="value" id="appt-urology-last">&mdash;</span>
        </div>
      </div>

      <div class="appointment-card" data-role="dentist">
        <h3 class="blockTitle">Zahnarzt</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-dentist-date">Datum</label>
            <input type="date" id="appt-dentist-date">
          </div>
          <div>
            <label for="appt-dentist-time">Zeit</label>
            <input type="time" id="appt-dentist-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-dentist-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-line">
          <span class="label">Naechster Termin:</span>
          <span class="value" id="appt-dentist-next">&mdash;</span>
          <button class="btn ghost btn-xs" id="appt-dentist-done" type="button" disabled>Done</button>
        </div>
        <div class="appointment-line">
          <span class="label">Letzter Termin:</span>
          <span class="value" id="appt-dentist-last">&mdash;</span>
        </div>
      </div>

      <div class="appointment-card" data-role="ophtha">
        <h3 class="blockTitle">Augenarzt</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-ophtha-date">Datum</label>
            <input type="date" id="appt-ophtha-date">
          </div>
          <div>
            <label for="appt-ophtha-time">Zeit</label>
            <input type="time" id="appt-ophtha-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-ophtha-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-line">
          <span class="label">Naechster Termin:</span>
          <span class="value" id="appt-ophtha-next">&mdash;</span>
          <button class="btn ghost btn-xs" id="appt-ophtha-done" type="button" disabled>Done</button>
        </div>
        <div class="appointment-line">
          <span class="label">Letzter Termin:</span>
          <span class="value" id="appt-ophtha-last">&mdash;</span>
        </div>
      </div>

      <div class="appointment-card" data-role="physio">
        <h3 class="blockTitle">Physiotherapie</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-physio-date">Datum</label>
            <input type="date" id="appt-physio-date">
          </div>
          <div>
            <label for="appt-physio-time">Zeit</label>
            <input type="time" id="appt-physio-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-physio-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-line">
          <span class="label">Naechster Termin:</span>
          <span class="value" id="appt-physio-next">&mdash;</span>
          <button class="btn ghost btn-xs" id="appt-physio-done" type="button" disabled>Done</button>
        </div>
        <div class="appointment-line">
          <span class="label">Letzter Termin:</span>
          <span class="value" id="appt-physio-last">&mdash;</span>
        </div>
      </div>

      <div class="small" style="opacity:.7">Hinweis: Logik folgt in den naechsten Phasen ? aktuell nur UI-Skelett.</div>
    </div>
  </div>
</details>

  </section>
</section>

<!-- Lifestyle (Heute) -->


<!-- Doctor -->
<section class="view" id="doctor" aria-labelledby="doctorHeading">
  <h2 class="sr-only" id="doctorHeading">Arzt-Ansicht</h2>
  <div class="card" id="doctorCard">
    <div class="toolbar">
      <strong id="doctorTitle">Arzt-Ansicht</strong>

      <div class="center-group">
        <label class="small">Von <input type="date" id="from" style="width:auto"></label>
        <label class="small">Bis <input type="date" id="to" style="width:auto"></label>
        <button class="btn ghost" id="applyRange" type="button">Anwenden</button>
        <button class="btn ghost" id="doctorChartBtn" type="button" title="Werte als Grafik">Werte anzeigen</button>
        <button class="btn ghost" id="doctorExportJson" type="button">Export JSON</button>
      </div>

      <span id="docTrainCnt" class="badge good" title="Anzahl Tage mit Training im Zeitraum"> Trainingstage: <span class="val">0</span></span>
      <span id="docBadCnt" class="badge bad" title="Anzahl Tage mit mind. einem Bad-Flag"> Tage mit Bad-Flag: <span class="val">0</span></span>
    </div> <!--  Toolbar sauber schliessen -->

    <div style="overflow:auto" id="doctorDailyWrap">
      <div class="doctor-view" id="doctorView"></div>
    </div>

        <div class="small" style="margin-top:6px">
      Tipp: "Werte anzeigen" oeffnet die passende Grafik zum aktuellen Tab (Daily).
    </div>
  </div>
</section>

</main>

<!-- Supabase (UMD, v2) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

<script>
/* ===== Supabase Defaults (ANON only - niemals service_role!) ===== */
const SUPABASE_URL_DEFAULT = "https://jlylmservssinsavlkdi.supabase.co";
const SUPABASE_ANON_DEFAULT = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpseWxtc2VydnNzaW5zYXZsa2RpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNTQ2NjAsImV4cCI6MjA3MDgzMDY2MH0.4BpnwDJAlPohSYLfNcaEJfxQNvlHBbMvxVcCOAWpkFA";
const DEFAULT_WEBHOOK_ENTRIES = `${SUPABASE_URL_DEFAULT}/rest/v1/health_events`;
const DEV_ALLOW_DEFAULTS = (() => {
  try {
    const host = window?.location?.hostname || "";
    if (/^(localhost|127\.0\.0\.1)$/i.test(host) || /\.local$/i.test(host)) return true;
    const params = new URLSearchParams(window?.location?.search || "");
    if (params.get('devDefaults') === '1') {
      window?.localStorage?.setItem('healthlog_dev_defaults', '1');
      return true;
    }
    if (window?.localStorage?.getItem('healthlog_dev_defaults') === '1') return true;
  } catch(_){ }
  return false;
})();
const APPOINTMENT_GRACE_MS = 5 * 60 * 1000;
const APPOINTMENT_ROLES = [
  { code: 'nephro', label: 'Nephrologe' },
  { code: 'internal', label: 'Internist' },
  { code: 'urology', label: 'Urologe' },
  { code: 'dentist', label: 'Zahnarzt' },
  { code: 'ophtha', label: 'Augenarzt' },
  { code: 'physio', label: 'Physiotherapie' },
];

const appointmentsState = {
  data: Object.create(null),
  loading: false,
  loaded: false,
  next: null,
};


/* ===== Fehlerbox ===== */
window.addEventListener('unhandledrejection', (e)=>{
const box = document.getElementById('err');
box.style.display='block';
box.textContent = 'Fehler: ' + (e.reason?.message || e.reason || 'Unbekannter Fehler');
});

/* ===== Diagnostics ===== */
const perfStats = (() => {
  const buckets = Object.create(null);
  const add = (k, ms) => (buckets[k] ??= []).push(ms);
  const pct = (arr, p) => {
    if (!arr.length) return 0;
    const a = [...arr].sort((x,y)=>x-y);
    const i = Math.ceil((p/100)*a.length)-1;
    return a[Math.max(0, Math.min(i, a.length-1))];
  };
  const snap = (k) => {
    const arr = buckets[k] || [];
    return { count: arr.length, p50: pct(arr,50), p90: pct(arr,90), p95: pct(arr,95), p99: pct(arr,99) };
  };
  return { add, snap };
})();

function recordPerfStat(key, startedAt){
  if (startedAt == null) return;
  const hasPerf = typeof performance !== "undefined" && typeof performance.now === "function";
  if (!hasPerf) return;
  try {
    perfStats?.add?.(key, Math.max(0, performance.now() - startedAt));
    const snap = perfStats?.snap?.(key);
    if (snap && snap.count % 25 === 0) {
      try {
        diag.add?.(`[perf] ${key} p50=${snap.p50|0}ms p90=${snap.p90|0}ms p95=${snap.p95|0}ms`);
      } catch(_){}
    }
  } catch(_){}
}

const diag = { el:null, logEl:null, open:false, lines:[],
add(msg){ const t=new Date().toLocaleTimeString(); this.lines.unshift(`[${t}] ${msg}`); this.lines=this.lines.slice(0,80); if(this.logEl) this.logEl.textContent = this.lines.join('\n'); },
init(){ this.el=document.getElementById('diag'); this.logEl=document.getElementById('diagLog');
if (this.logEl && this.lines.length) { this.logEl.textContent = this.lines.join('\n'); }
const t1=document.getElementById('diagToggle'); const t2=document.getElementById('diagToggleFab');
const close=document.getElementById('diagClose');
const toggle=()=>{ this.open=!this.open; if (this.open){ this.show(); } else { this.hide(); } };
t1.addEventListener('click', toggle);
if (t2) t2.addEventListener('click', toggle);
close.addEventListener('click', ()=>{ this.hide(); });
},
show(){ if (!this.el) return; this.el.style.display='block'; focusTrap.activate(this.el); this.open=true; },
hide(){ if (!this.el) return; this.el.style.display='none'; focusTrap.deactivate(); this.open=false; }
};

/* ===== Help panel ===== */
const helpPanel={ el:null, open:false,
init(){ this.el=document.getElementById('help');
const t1=document.getElementById('helpToggle'); const t2=document.getElementById('helpToggleFab'); const close=document.getElementById('helpClose');
const toggle=()=>{ this.open=!this.open; if (this.open){ this.show(); } else { this.hide(); } };
t1.addEventListener('click', toggle);
if (t2) t2.addEventListener('click', toggle);
close.addEventListener('click', ()=>{ this.hide(); });
},
show(){ if (!this.el) return; this.el.style.display='block'; focusTrap.activate(this.el); this.open=true; },
hide(){ if (!this.el) return; this.el.style.display='none'; focusTrap.deactivate(); this.open=false; }
};

/* ===== Helpers ===== */
const uiRefreshState = {
  timer: null,
  running: false,
  docNeeded: false,
  chartNeeded: false,
  lifestyleNeeded: false,
  appointmentsNeeded: false,
  resolvers: [],
  lastReason: ''
};

function requestUiRefresh(opts = {}){
  if (typeof opts === "string") {
    opts = { reason: opts };
  }
  const reason = opts.reason || '';
  const doctor = opts.doctor !== undefined ? !!opts.doctor : true;

  let chartDefault = false;
  try { chartDefault = !!(chartPanel?.open); } catch(_) {}
  const chart = opts.chart !== undefined ? !!opts.chart : chartDefault;

  let lifestyleDefault = false;
  try {
    const lifestyleEl = document.getElementById('lifestyle');
    lifestyleDefault = !!(lifestyleEl?.classList?.contains('active'));
  } catch(_) {}
  const lifestyle = opts.lifestyle !== undefined ? !!opts.lifestyle : lifestyleDefault;

  const appointments = opts.appointments !== undefined ? !!opts.appointments : false;

  uiRefreshState.docNeeded = uiRefreshState.docNeeded || doctor;
  uiRefreshState.chartNeeded = uiRefreshState.chartNeeded || chart;
  uiRefreshState.lifestyleNeeded = uiRefreshState.lifestyleNeeded || lifestyle;
  uiRefreshState.appointmentsNeeded = uiRefreshState.appointmentsNeeded || appointments;
  uiRefreshState.lastReason = reason || uiRefreshState.lastReason;

  const promise = new Promise(resolve => uiRefreshState.resolvers.push(resolve));

  if (!uiRefreshState.running && !uiRefreshState.timer) {
    uiRefreshState.timer = setTimeout(runUiRefresh, 60);
  }
  return promise;
}

async function runUiRefresh(){
  const state = uiRefreshState;
  if (state.timer){
    clearTimeout(state.timer);
    state.timer = null;
  }
  state.running = true;
  try {
    while (state.docNeeded || state.chartNeeded || state.lifestyleNeeded || state.appointmentsNeeded) {
      const doc = state.docNeeded;
      const chart = state.chartNeeded;
      const lifestyle = state.lifestyleNeeded;
      const appointments = state.appointmentsNeeded;
      state.docNeeded = false;
      state.chartNeeded = false;
      state.lifestyleNeeded = false;
      state.appointmentsNeeded = false;
      try {
        if (doc) await renderDoctor();
        if (appointments) await refreshAppointments();
        if (lifestyle && typeof renderLifestyle === 'function') await renderLifestyle();
        if (chart) await chartPanel.draw?.();
      } catch (e) {
        try { diag.add?.('uiRefresh error: ' + (e?.message || e)); } catch(_){}
      }
    }
  } finally {
    state.running = false;
    const resolvers = state.resolvers;
    state.resolvers = [];
    resolvers.forEach(resolve => { try { resolve(); } catch(_){} });
    if ((state.docNeeded || state.chartNeeded || state.lifestyleNeeded) && !state.timer){
      state.timer = setTimeout(runUiRefresh, 60);
    }
  }
}
// kleines visuelles Ping bei Realtime
function livePulse(){
  const el = document.getElementById('doctorLive');
  if (!el) return;
  el.classList.add('pulse');
  setTimeout(() => el.classList.remove('pulse'), 900);
}

// --- Service-Role-Schutz (NIEMALS im Browser) ---
function isServiceRoleKey(raw){
  const tok = String(raw||"").trim().replace(/^Bearer\s+/i,'');
  try{
    const payload = JSON.parse(atob(tok.split('.')[1].replace(/-/g,'+').replace(/_/g,'/')));
    return payload?.role === 'service_role';
  }catch{
    return false; // Fallback: lieber konservativ sein
  }
}

// ANKER: sb-rest
async function sbSelect({ table, select, filters = [], order = null, limit = null }) {
  // Basis-URL aus gespeicherter REST-URL ableiten (z. B. .../rest/v1/health_events)
  const restUrl = await getConf("webhookUrl");
  const base    = baseUrlFromRest(restUrl) || (DEV_ALLOW_DEFAULTS ? SUPABASE_URL_DEFAULT : null);
  if (!base) {
    setConfigStatus('Bitte REST-Endpoint konfigurieren.', 'error');
    const err = new Error("REST-Basis fehlt");
    err.status = 0;
    throw err;
  }

  const url = new URL(`${base}/rest/v1/${table}`);
  if (select) url.searchParams.set('select', select);
  for (const [k, v] of filters) url.searchParams.set(k, v);
  if (order) url.searchParams.set('order', order);
  if (limit) url.searchParams.set('limit', String(limit));

  // WICHTIG: mit User-JWT lesen (RLS)!
  const res = await fetchWithAuth(
    headers => fetch(url.toString(), { headers }),
    { tag: `sbSelect:${table}`, maxAttempts: 2 }
  );
  if (!res.ok) {
    let details = '';
    try { const e = await res.json(); details = e?.message || e?.details || ''; } catch {}
    throw new Error(`REST ${table} failed ${res.status} - ${details}`);
  }
  return await res.json();
}
  
// ANCHOR: num-helper-de
function toNumDE(s) {
  if (s == null) return null;
  const v = String(s).trim();
  if (!v) return null;
  const n = parseFloat(v.replace(',', '.'));
  return Number.isFinite(n) ? n : null;
}

// ANKER: ui-utils
function uiError(msg) {
  const box = document.getElementById('err');
  if (box) {
    box.setAttribute('role','status');
    box.setAttribute('aria-live','polite');
    box.textContent = String(msg || 'Fehler');
    box.style.display = 'block';
    setTimeout(()=>{ box.style.display='none'; }, 5000);
  } else {
    alert(msg);
  }
}

function uiInfo(msg) {
  const box = document.getElementById('err');
  if (box) {
    box.setAttribute('role','status');
    box.setAttribute('aria-live','polite');
    box.textContent = String(msg || 'OK');
    box.style.display = 'block';
    setTimeout(()=>{ box.style.display='none'; }, 2000);
  } else {
    console.log(msg);
  }
}

// Utility: debounce to avoid rapid-fire updates (e.g. live regions)
function debounce(fn, ms = 150) {
  let timer = null;
  return (...args) => {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      timer = null;
      fn(...args);
    }, ms);
  };
}

// Utility: disable background when modal dialog is active
function setUnderlayInert(active, exceptEl = null) {
  try {
    const targets = [
      document.querySelector('header'),
      document.querySelector('nav.tabs'),
      document.getElementById('appMain'),
      document.querySelector('.fab-wrap')
    ].filter(Boolean);

    targets.forEach(el => {
      if (!el) return;
      if (active) {
        if (exceptEl && (el === exceptEl || el.contains(exceptEl) || exceptEl.contains(el))) return;
        if (!el.hasAttribute('data-prev-aria-hidden')) {
          const prev = el.getAttribute('aria-hidden');
          el.setAttribute('data-prev-aria-hidden', prev == null ? '' : prev);
        }
        el.setAttribute('aria-hidden', 'true');
        if (!el.hasAttribute('data-inert-applied')) {
          el.setAttribute('data-inert-applied', '1');
        }
        el.setAttribute('inert', '');
      } else {
        if (el.hasAttribute('data-prev-aria-hidden')) {
          const prev = el.getAttribute('data-prev-aria-hidden');
          if (prev === '') el.removeAttribute('aria-hidden');
          else el.setAttribute('aria-hidden', prev);
          el.removeAttribute('data-prev-aria-hidden');
        } else {
          el.removeAttribute('aria-hidden');
        }
        if (el.hasAttribute('data-inert-applied')) {
          el.removeAttribute('inert');
          el.removeAttribute('data-inert-applied');
        }
      }
    });
  } catch(_) { /* noop */ }
}

function updateStickyOffsets(){
  try{
    const headerEl = document.querySelector('header');
    const tabsEl = document.querySelector('nav.tabs');
    const headerH = Math.max(headerEl?.offsetHeight || 0, 48);
    const tabsH = Math.max(tabsEl?.offsetHeight || 0, 40);
    document.documentElement.style.setProperty('--header-h', `${headerH}px`);
    document.documentElement.style.setProperty('--tabs-h', `${tabsH}px`);
    const mainEl = document.getElementById('appMain');
    if (mainEl){
      mainEl.style.paddingTop = `calc(${headerH}px + ${tabsH}px + 8px)`;
    }
  }catch(_){ /* noop */ }
}

window.addEventListener('resize', updateStickyOffsets);
window.addEventListener('orientationchange', updateStickyOffsets);

function ensureNotObscured(el){
  try{
    if (!el) return;
    const headerBottom = document.querySelector('header')?.getBoundingClientRect().bottom ?? 0;
    const tabsHeight = document.querySelector('nav.tabs')?.getBoundingClientRect().height ?? 0;
    const requiredTop = headerBottom + tabsHeight + 8;
    const rect = el.getBoundingClientRect();
    if (rect.top < requiredTop){
      window.scrollBy({ top: rect.top - requiredTop, left: 0, behavior: 'auto' });
    }
  }catch(_){ /* noop */ }
}

document.addEventListener('focusin', (e)=>{
  try{
    if (!e.target?.matches?.('input, select, textarea, button')){
      return;
    }
    ensureNotObscured(e.target);
  }catch(_){ /* noop */ }
}, true);

// Simple focus trap for modal overlays
const focusTrap = {
  current: null,
  lastFocus: null,
  handler: null,
  prevTabIndex: null,
  getFocusable(root) {
    return Array.from(root.querySelectorAll('a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'))
      .filter(el => {
        const style = window.getComputedStyle(el);
        if (style.visibility === 'hidden' || style.display === 'none') return false;
        return el.getClientRects().length > 0;
      });
  },
  onKeyDown(e) {
    if (e.key !== 'Tab') return;
    const root = focusTrap.current;
    if (!root) return;
    const items = focusTrap.getFocusable(root);
    if (!items.length) {
      e.preventDefault();
      (root.focus ? root.focus() : null);
      return;
    }
    const first = items[0];
    const last = items[items.length - 1];
    if (e.shiftKey && document.activeElement === first) {
      e.preventDefault();
      last.focus();
    } else if (!e.shiftKey && document.activeElement === last) {
      e.preventDefault();
      first.focus();
    }
  },
  activate(root) {
    if (!root) return;
    if (this.current === root) return;
    this.deactivate();
    this.current = root;
    this.lastFocus = document.activeElement || null;
    this.prevTabIndex = root.hasAttribute('tabindex') ? root.getAttribute('tabindex') : null;
    if (this.prevTabIndex === null) root.setAttribute('tabindex', '-1');
    root.setAttribute('aria-modal', 'true');
    this.handler = this.onKeyDown.bind(this);
    document.addEventListener('keydown', this.handler, true);
    const items = this.getFocusable(root);
    (items[0] || root).focus();
    setUnderlayInert(true, root);
  },
  deactivate() {
    const root = this.current;
    if (!root) return;
    root.setAttribute('aria-modal', 'false');
    if (this.handler) document.removeEventListener('keydown', this.handler, true);
    setUnderlayInert(false);
    if (this.prevTabIndex === null) root.removeAttribute('tabindex');
    else root.setAttribute('tabindex', this.prevTabIndex);
    const last = this.lastFocus;
    this.current = null;
    this.lastFocus = null;
    this.handler = null;
    this.prevTabIndex = null;
    if (last && typeof last.focus === 'function') last.focus();
  }
};

function restErrorMessage(status, details = '') {
  const norm = String(details || '').trim();
  if (status === 0) return 'Netzwerkfehler - bitte Verbindung pruefen.';
  if (status === 401 || status === 403) return 'Bitte erneut anmelden.';
  if (status === 404) return 'Eintrag nicht gefunden.';
  if (status === 409) return 'Konflikt: Ein Eintrag existiert bereits.';
  if (status === 400 || status === 422) return 'Eingaben bitte pruefen.';
  if (status === 429) return 'Zu viele Anfragen - bitte kurz warten.';
  if (status >= 500) return 'Serverfehler - bitte spaeter erneut versuchen.';
  return norm || `Fehler (${status})`;
}

function uiRestError(status, details, fallback){
  uiError(fallback || restErrorMessage(status, details));
}

function withBusy(el, on=true){
  if (!el) return;
  el.disabled = !!on;
}
  
/* ===== Auth-Guard ===== */
async function isLoggedIn(){
  if (!sbClient) return false;
  return await isLoggedInFast({ timeout: 800 });
}

/** Schaltet optisch auf "gesperrt" - ohne Controls hart zu deaktivieren */
function setAuthGuard(logged){
  // Nur visuelles Dimmen; die Save-Logik prueft isLoggedIn() ohnehin.
  document.body.classList.toggle('auth-locked', !logged);
  // Kein auto-boot mehr hier - Start erfolgt in main()/watchAuthState.
}

function setDoctorAccess(enabled){
  // Tab-Button
  const tabBtn = document.getElementById('tab-doctor');
  if (tabBtn){
    tabBtn.disabled = !enabled;
    tabBtn.classList.toggle('ghost', !enabled);
    tabBtn.title = enabled ? '' : 'Bitte zuerst anmelden';
  }
  // "Werte anzeigen"-Button
  const chartBtn = document.getElementById('doctorChartBtn');
  if (chartBtn){
    chartBtn.disabled = !enabled;
    chartBtn.title = enabled ? 'Werte als Grafik' : 'Bitte zuerst anmelden';
  }
  // Lifestyle-Tab mitsteuern
  
}
  
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const fmtNum = (n, d=1) => (n===null||n===undefined||isNaN(n)) ? "" : Number(n).toFixed(d);
const pad2 = n => n.toString().padStart(2,'0');
const todayStr = () => { const d = new Date(); const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; };
const timeStr = () => { const d = new Date(); return pad2(d.getHours())+":"+pad2(d.getMinutes()); };
function esc(s){ return String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function nl2br(s){ return esc(s).replace(/\n/g, "<br>"); }
function formatDateTimeDE(iso){
  if (!iso) return '\u2014';
  try {
    const dt = new Date(iso);
    if (Number.isNaN(dt.getTime())) return '\u2014';
    return new Intl.DateTimeFormat('de-AT', {
      day:'2-digit', month:'2-digit', year:'numeric',
      hour:'2-digit', minute:'2-digit', hour12:false,
      timeZone:'Europe/Vienna'
    }).format(dt);
  } catch(_) {
    return '\u2014';
  }
}

function calcMAP(sys, dia){ if (sys==null || dia==null) return null; return Number(dia) + (Number(sys)-Number(dia))/3; }
  // === Mapping: lokaler Erfassungseintrag -> 0..N health_events ===
// Erzeugt pro Eingabe die noetigen Events (bp/body/day_flags/note)
function toHealthEvents(entry){
  const tsIso = entry.dateTime; // ISO Timestamp des Eintrags
  const out = [];

  // 1) Blutdruck-Messungen (Morgen/Abend)
  if (entry.context === "Morgen" || entry.context === "Abend"){
    const hasVitals = (entry.sys != null) || (entry.dia != null) || (entry.pulse != null);
    if (hasVitals){
      const payload = {};
      if (entry.sys   != null) payload.sys   = Number(entry.sys);
      if (entry.dia   != null) payload.dia   = Number(entry.dia);
      if (entry.pulse != null) payload.pulse = Number(entry.pulse);
      payload.ctx = entry.context; // "Morgen" | "Abend"
      out.push({ ts: tsIso, type: "bp", payload });
    }
  }

  // 2) Tageszusammenfassung (Gewicht, Bauchumfang, Flags, Kommentar)
  if (entry.context === "Tag"){
    // body (Gewicht + Bauchumfang)
    const hasBody = (entry.weight != null) || (entry.waist_cm != null);
    if (hasBody){
      const payload = {};
      if (entry.weight   != null) payload.kg = Number(entry.weight);
      if (entry.waist_cm != null) payload.cm = Number(entry.waist_cm);
      if (entry.fat_pct != null) payload.fat_pct = Number(entry.fat_pct);
      if (entry.muscle_pct != null) payload.muscle_pct = Number(entry.muscle_pct);
      out.push({ ts: tsIso, type: "body", payload });
    }

    // day_flags (alle Booleans)
    const flags = {
      training:         !!entry.training,
      sick:             !!entry.sick,
      low_intake:       !!entry.low_intake,
      salt_high:        !!entry.salt_high,
      protein_high90:   !!entry.protein_high90,
      valsartan_missed: !!entry.valsartan_missed,
      forxiga_missed:   !!entry.forxiga_missed,
      nsar_taken:       !!entry.nsar_taken,
    };
    const anyFlag = Object.values(flags).some(Boolean);
    if (anyFlag){
      out.push({ ts: tsIso, type: "day_flags", payload: flags });
    }

    // note (optional, 1 Zeile Text)
    const note = (entry.notes || "").trim();
    if (note){
      out.push({ ts: tsIso, type: "note", payload: { text: note } });
    }
  }

  return out;
}

// "Legacy": Measurement Eintrag, der nur Gewicht enthaelt
function isWeightOnly(e){
const hasVitals = !!(e?.sys || e?.dia || e?.pulse);
return !hasVitals && (e?.weight != null);
}

function setBusy(on){
const b = document.getElementById('busy');
if (b) b.style.display = on ? 'flex' : 'none';
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function softWarnRange(el, min, max){
const v = Number(el.value);
if (!isNaN(v) && (v < min || v > max)) {
el.style.outline = '2px solid var(--warn)';
} else {
el.style.outline = '';
}
}

/* ===== IndexedDB ===== */
let db;
const DB_NAME = "healthlog_db";
const STORE   = "entries";
const CONF    = "config";

function initDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, 5);

    req.onupgradeneeded = (e)=>{
      db = e.target.result;
      // entries
      if(!db.objectStoreNames.contains(STORE)){
        const s = db.createObjectStore(STORE,{ keyPath:"id", autoIncrement:true });
        s.createIndex("byDateTime","dateTime",{unique:false});
        s.createIndex("byRemote","remote_id",{unique:false});
      } else {
        const s = e.target.transaction.objectStore(STORE);
        try{ s.createIndex("byDateTime","dateTime",{unique:false}); }catch(_){}
        try{ s.createIndex("byRemote","remote_id",{unique:false}); }catch(_){}
      }
      // config
      if(!db.objectStoreNames.contains(CONF)){
        db.createObjectStore(CONF,{ keyPath:"key" });
      }
    };

    req.onsuccess = (e)=>{
      db = e.target.result;
      db.onversionchange = ()=> db?.close?.();
      resolve();
    };
    req.onerror = ()=> reject(req.error || new Error("IndexedDB open failed"));
  });
}

/* --- IDB Helpers (global) --- */
function putConf(key, value){
  return new Promise((res,rej)=>{
    const tx = db.transaction(CONF,"readwrite");
    tx.objectStore(CONF).put({key, value});
    tx.oncomplete = ()=>res();
    tx.onerror = (e)=>rej(e);
  });
}
function getConf(key){
  return new Promise((res,rej)=>{
    const tx = db.transaction(CONF,"readonly");
    const rq = tx.objectStore(CONF).get(key);
    rq.onsuccess = ()=> res(rq.result?.value ?? null);
    rq.onerror   = (e)=> rej(e);
  });
}
function addEntry(obj){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    const rq = tx.objectStore(STORE).add(obj);
    rq.onsuccess = ()=> res(rq.result);
    rq.onerror   = (e)=> rej(e);
  });
}
function updateEntry(id, patch){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    const store = tx.objectStore(STORE);
    const get = store.get(id);
    get.onsuccess = ()=>{
      const cur = get.result; if(!cur){ res(false); return; }
      store.put(Object.assign({}, cur, patch));
    };
    tx.oncomplete = ()=> res(true);
    tx.onerror    = (e)=> rej(e);
  });
}
function getAllEntries(){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readonly");
    const rq = tx.objectStore(STORE).getAll();
    rq.onsuccess = ()=> res(rq.result || []);
    rq.onerror   = (e)=> rej(e);
  });
}
function getEntryByRemoteId(remoteId){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readonly");
    const idx = tx.objectStore(STORE).index("byRemote");
    const rq  = idx.getAll(remoteId);
    rq.onsuccess = ()=> res(rq.result?.[0] ?? null);
    rq.onerror   = (e)=> rej(e);
  });
}
function deleteEntryLocal(id){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    tx.objectStore(STORE).delete(id);
    tx.oncomplete = ()=> res();
    tx.onerror    = (e)=> rej(e);
  });
}

/* ===== Remote (Supabase REST) ===== */
async function getHeaders(){
  const key = await getConf("webhookKey");
  if (!key) { try{ diag.add?.('Headers: kein Key (webhookKey)'); }catch(_){} return null; }
  if (isServiceRoleKey(key)) { try{ diag.add?.('Headers: service_role Key blockiert'); }catch(_){} return null; }
  const anonKey = key.replace(/^Bearer\s+/i, "");

  const supa = await ensureSupabaseClient();
  if (!supa) { try{ diag.add?.('Headers: Supabase-Client fehlt'); }catch(_){} return null; }

  const { data: { session } } = await supa.auth.getSession();
  const jwt = session?.access_token;
  if (!anonKey || !jwt) { try{ diag.add?.('Headers: fehlende Session/JWT'); }catch(_){} return null; }

  const headers = {
    "Content-Type": "application/json",
    "apikey": anonKey,
    "Authorization": `Bearer ${jwt}`,
    "Prefer": "return=representation"
  };
  try{ diag.add?.('[headers] ok'); }catch(_){}
  return headers;
}

async function deleteRemote(remote_id){
  const url = await getConf("webhookUrl");
  if(!url || !remote_id) return {ok:false};
  const q = `${url}?id=eq.${encodeURIComponent(remote_id)}`;
  try{
    const res = await fetchWithAuth(headers => fetch(q, { method:"DELETE", headers }), { tag: 'remote:delete', maxAttempts: 2 });
    return {ok: res.ok, status: res.status};
  }catch(e){
    return {ok:false, status: e?.status ?? 0};
  }
}

async function loadIntakeToday({ user_id, dayIso }){
  if (!user_id) return null;
  const baseDay = /^\d{4}-\d{2}-\d{2}$/.test(String(dayIso || '')) ? dayIso : todayStr();
  const from = `${baseDay}T00:00:00Z`;
  const toNext = new Date(from); toNext.setUTCDate(toNext.getUTCDate() + 1);
  const toIso = toNext.toISOString().slice(0, 10);

  const rows = await sbSelect({
    table: 'health_events',
    select: 'id,payload',
    filters: [
      ['user_id', `eq.${user_id}`],
      ['type', 'eq.intake'],
      ['ts', `gte.${from}`],
      ['ts', `lt.${toIso}T00:00:00Z`]
    ],
    order: 'ts.desc',
    limit: 1
  });
  const r = Array.isArray(rows) && rows.length ? rows[0] : null;
  const p = r?.payload || {};
  return {
    id: r?.id ?? null,
    water_ml: Number(p.water_ml || 0),
    salt_g: Number(p.salt_g || 0),
    protein_g: Number(p.protein_g || 0)
  };
}

async function saveIntakeTotals({ dayIso, totals }){
  const url = await getConf("webhookUrl");
  const uid = await getUserId();
  if (!url || !uid) {
    const errMissing = new Error("saveIntakeTotals: missing config/auth");
    errMissing.status = 401;
    throw errMissing;
  }

  const dayIsoNorm = /^\d{4}-\d{2}-\d{2}$/.test(String(dayIso||"")) ? dayIso : todayStr();
  const ts = new Date(`${dayIsoNorm}T12:00:00Z`).toISOString();
  const payloadTotals = {
    water_ml: Number(totals?.water_ml || 0),
    salt_g: Number(totals?.salt_g || 0),
    protein_g: Number(totals?.protein_g || 0),
  };
  const payload = [{ ts, type: 'intake', payload: payloadTotals, user_id: uid }];

  const res = await fetchWithAuth(
    headers => fetch(url, { method:'POST', headers, body: JSON.stringify(payload) }),
    { tag: 'intake:post', maxAttempts: 2 }
  );

  if (res.ok) {
    return await res.json();
  }

  let details = '';
  try { const e = await res.clone().json(); details = e?.message || e?.details || ''; } catch{}

  if (!(res.status === 409 || /duplicate|unique/i.test(details))) {
    try { diag.add?.(`[intake] POST failed ${res.status} ${details||''}`); } catch {}
    const errRes = new Error('intake-post-failed');
    errRes.status = res.status;
    errRes.details = details;
    throw errRes;
  }

  const toNext = new Date(`${dayIsoNorm}T00:00:00Z`); toNext.setUTCDate(toNext.getUTCDate()+1);
  const toIso = toNext.toISOString().slice(0,10);
  const patchUrl = `${url}?user_id=eq.${encodeURIComponent(uid)}&type=eq.intake`
            + `&ts=gte.${encodeURIComponent(dayIsoNorm)}T00:00:00Z&ts=lt.${encodeURIComponent(toIso)}T00:00:00Z`;
  const res2 = await fetchWithAuth(
    headers => fetch(patchUrl, { method:'PATCH', headers, body: JSON.stringify({ payload: payloadTotals }) }),
    { tag: 'intake:patch', maxAttempts: 2 }
  );
  if (!res2.ok){
    let d2='';
    try{ const e2 = await res2.clone().json(); d2 = e2?.message || e2?.details || ''; }catch{}
    const errPatch = new Error('intake-patch-failed');
    errPatch.status = res2.status;
    errPatch.details = d2;
    throw errPatch;
  }
  return await res2.json();
}

async function cleanupOldIntake(){
  try{
    const url = await getConf('webhookUrl');
    const uid = await getUserId();
    if (!url || !uid) return;
    const today = todayStr();
    const q = `${url}?user_id=eq.${encodeURIComponent(uid)}&type=eq.intake`+
              `&ts=lt.${encodeURIComponent(today)}T00:00:00Z`;
    await fetchWithAuth(headers => fetch(q, { method:'DELETE', headers }), { tag: 'intake:cleanup', maxAttempts: 2 });
  }catch(e){
    try { diag.add?.('cleanupOldIntake error: ' + (e?.message || e)); } catch(_){}
  }
}

/* === Remote-Fetch Arzt-Ansicht (Views) === */
async function loadBpFromView({ user_id, from, to }) {
  const filters = [['user_id', `eq.${user_id}`]];
  if (from) filters.push(['day', `gte.${from}`]);
  if (to)   filters.push(['day', `lte.${to}`]);
  return await sbSelect({
    table: 'v_events_bp',
    select: 'day,ctx,sys,dia,pulse',
    filters,
    order: 'day.asc'
  });
}

async function loadBodyFromView({ user_id, from, to }) {
  const filters = [['user_id', `eq.${user_id}`]];
  if (from) filters.push(['day', `gte.${from}`]);
  if (to)   filters.push(['day', `lte.${to}`]);
  return await sbSelect({
    table: 'v_events_body',
    select: 'day,kg,cm,fat_pct,muscle_pct,fat_kg,muscle_kg',
    filters,
    order: 'day.asc'
  });
}

async function loadFlagsFromView({ user_id, from, to }) {
  const filters = [['user_id', `eq.${user_id}`]];
  if (from) filters.push(['day', `gte.${from}`]);
  if (to)   filters.push(['day', `lte.${to}`]);
  return await sbSelect({
    table: 'v_events_day_flags',
    select: 'day,training,sick,low_intake,salt_high,protein_high90,valsartan_missed,forxiga_missed,nsar_taken',
    filters,
    order: 'day.asc'
  });
}

// Sync capture toggles with existing day flags from the cloud for the selected date
async function syncCaptureToggles(){
  try{
    const uid = await getUserId();
    const dayIso = document.getElementById('date')?.value || todayStr();
    const rows = await loadFlagsFromView({ user_id: uid, from: dayIso, to: dayIso });
    const r = Array.isArray(rows) && rows.length ? rows[0] : null;
    // Apply or clear
    const f = r || { training:false, sick:false, low_intake:false, salt_high:false, protein_high90:false, valsartan_missed:false, forxiga_missed:false, nsar_taken:false };
    setTraining(!!f.training);
    setSick(!!f.sick);
    setLowIntake(!!f.low_intake);
    setSaltHigh(!!f.salt_high);
    setProteinHigh(!!f.protein_high90);
    setValsartanMiss(!!f.valsartan_missed);
    setForxigaMiss(!!f.forxiga_missed);
    setNsar(!!f.nsar_taken);
    const flagsCommentEl = document.getElementById("flagsComment");
    if (flagsCommentEl) flagsCommentEl.value = "";
  }catch(_){ /* non-blocking */ }
}

async function prefillBodyInputs(){
  const weightEl = document.getElementById('weightDay');
  const waistEl = document.getElementById('input-waist-cm');
  const fatEl = document.getElementById('fatPctDay');
  const muscleEl = document.getElementById('musclePctDay');
  const applyValues = (row) => {
    if (weightEl) weightEl.value = row?.kg != null ? fmtNum(row.kg, 1) : '';
    if (waistEl) waistEl.value = row?.cm != null ? fmtNum(row.cm, 1).replace('.', ',') : '';
    if (fatEl) {
      clearFieldError(fatEl);
      fatEl.value = row?.fat_pct != null ? fmtNum(row.fat_pct, 1).replace('.', ',') : '';
    }
    if (muscleEl) {
      clearFieldError(muscleEl);
      muscleEl.value = row?.muscle_pct != null ? fmtNum(row.muscle_pct, 1).replace('.', ',') : '';
    }
  };

  const dateEl = document.getElementById('date');
  const dayIso = dateEl?.value || todayStr();
  try {
    const uid = await getUserId();
    if (!uid) {
      applyValues(null);
      return;
    }
    const rows = await loadBodyFromView({ user_id: uid, from: dayIso, to: dayIso });
    const row = Array.isArray(rows) && rows.length ? rows[rows.length - 1] : null;
    applyValues(row);
  } catch(_) {
    applyValues(null);
  }
}

/* Optional: Notes (aus health_events, falls keine View v_events_note existiert) */
async function loadNotesLastPerDay({ user_id, from, to }) {
  const filters = [['user_id', `eq.${user_id}`], ['type', 'eq.note']];
  if (from) filters.push(['day', `gte.${from}`]);
  if (to)   filters.push(['day', `lte.${to}`]);
  const rows = await sbSelect({
    table: 'health_events',
    select: 'day,ts,payload',
    filters,
    order: 'ts.asc',
  });
  const grouped = new Map();
  for (const r of rows) {
    const text = (r?.payload?.text || '').trim();
    if (!text) continue;
    if (!grouped.has(r.day)) grouped.set(r.day, []);
    grouped.get(r.day).push({ ts: r.ts, text });
  }
  const out = [];
  for (const [day, entries] of grouped.entries()) {
    entries.sort((a,b)=> (a.ts||0) - (b.ts||0));
    const lastTs = entries.length ? entries[entries.length-1].ts : null;
    out.push({ day, ts: lastTs, text: entries.map(e=>e.text).join(' ') });
  }
  return out;
}

/* View-Zeilen  Tagesobjekte (kompatibel zu renderDoctor/chartPanel) */
function joinViewsToDaily({ bp, body, flags, notes = [] }) {
  const days = new Map();
  const ensure = (day) => {
    let d = days.get(day);
    if (!d) {
      d = {
        date: day,
        morning: { sys:null, dia:null, pulse:null, map:null },
        evening: { sys:null, dia:null, pulse:null, map:null },
        weight: null,
        waist_cm: null,
        fat_pct: null,
        muscle_pct: null,
        fat_kg: null,
        muscle_kg: null,
        notes: "",
        flags: { water_lt2:false, salt_gt5:false, protein_ge90:false, sick:false, meds:false, training:false },
        remoteIds: [],
        hasCloud: true
      };
      days.set(day, d);
    }
    return d;
  };

  // body (1x/Tag)
  for (const r of body) {
    const d = ensure(r.day);
    if (r.kg != null) d.weight   = Number(r.kg);
    if (r.cm != null) d.waist_cm = Number(r.cm);
    if (r.fat_pct != null) d.fat_pct = Number(r.fat_pct);
    if (r.muscle_pct != null) d.muscle_pct = Number(r.muscle_pct);
    if (r.fat_kg != null) d.fat_kg = Number(r.fat_kg);
    if (r.muscle_kg != null) d.muscle_kg = Number(r.muscle_kg);
  }

  // bp (max 2x/Tag - Morgen/Abend)
  for (const r of bp) {
    const d = ensure(r.day);
    const blk = r.ctx === 'Morgen' ? d.morning : (r.ctx === 'Abend' ? d.evening : null);
    if (blk) {
      if (r.sys   != null) blk.sys   = Number(r.sys);
      if (r.dia   != null) blk.dia   = Number(r.dia);
      if (r.pulse != null) blk.pulse = Number(r.pulse);
      if (blk.sys != null && blk.dia != null) blk.map = calcMAP(blk.sys, blk.dia);
    }
  }

  // flags (1x/Tag)
  for (const r of flags) {
    const d = ensure(r.day);
    d.flags.training   = !!r.training;
    d.flags.sick       = !!r.sick;
    d.flags.water_lt2  = !!r.low_intake;
    d.flags.salt_gt5   = !!r.salt_high;
    d.flags.protein_ge90 = !!r.protein_high90;
    d.flags.meds       = !!(r.valsartan_missed || r.forxiga_missed || r.nsar_taken);
    // Detail-Medikamentenflags (fuer Tooltip)
    d.flags.valsartan_missed = !!r.valsartan_missed;
    d.flags.forxiga_missed   = !!r.forxiga_missed;
    d.flags.nsar_taken       = !!r.nsar_taken;
  }

  // notes: alle Texte eines Tages zusammenfassen
  for (const n of notes) {
    const d = ensure(n.day);
    d.notes = n.text || "";
  }

  return Array.from(days.values()).sort((a,b)=> a.date.localeCompare(b.date));
}

/* Neues fetchDailyOverview: liest direkt aus den Views */
async function fetchDailyOverview(fromIso, toIso){
  const user_id = await getUserId();
  if (!user_id) return [];

  const [bp, body, flags, notes] = await Promise.all([
    loadBpFromView({ user_id, from: fromIso, to: toIso }),
    loadBodyFromView({ user_id, from: fromIso, to: toIso }),
    loadFlagsFromView({ user_id, from: fromIso, to: toIso }),
    loadNotesLastPerDay({ user_id, from: fromIso, to: toIso }) // optional
  ]);

  return joinViewsToDaily({ bp, body, flags, notes });
}

/* Server: alle Events eines Tages loeschen (RLS: nur eigene Records) */
async function deleteRemoteDay(dateIso /*YYYY-MM-DD*/){
  const url = await getConf("webhookUrl");
  if (!url) return { ok:false, status:0 };

  const from = `${dateIso}T00:00:00Z`;
  const toNext = new Date(from); toNext.setUTCDate(toNext.getUTCDate()+1);
  const toIso = toNext.toISOString().slice(0,10);

  const q = `${url}?ts=gte.${encodeURIComponent(dateIso)}T00:00:00Z&ts=lt.${encodeURIComponent(toIso)}T00:00:00Z`;
  try{
    const res = await fetchWithAuth(headers => fetch(q, { method:"DELETE", headers }), { tag: 'remote:delete-day', maxAttempts: 2 });
    return { ok: res.ok, status: res.status };
  }catch(e){
    return { ok:false, status: e?.status ?? 0 };
  }
}

function setCaptureIntakeDisabled(disabled){
  ['cap-water-add','cap-salt-add','cap-protein-add'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.disabled = !!disabled;
  });
  ['cap-water-add-btn','cap-salt-add-btn','cap-protein-add-btn'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.disabled = !!disabled;
  });
}

function clearFieldError(el){
  if (!el) return;
  el.style.outline = '';
  el.removeAttribute('aria-invalid');
}

function setFieldError(el){
  if (!el) return;
  el.style.outline = '2px solid var(--danger)';
  el.setAttribute('aria-invalid','true');
}

function prepareIntakeStatusHeader(){
  try {
    const wrap = document.getElementById('capturePillsRow');
    const nab = wrap ? wrap.querySelector('#nextApptBadge') : document.getElementById('nextApptBadge');
    if (nab) {
      nab.textContent = 'Kein Termin geplant';
      nab.title = 'Kein Termin geplant';
    }
    if (!wrap) return;

    wrap.style.gap = '8px';
    wrap.style.flexWrap = 'wrap';
    wrap.style.alignItems = 'center';

    let top = document.getElementById('cap-intake-status-top');
    if (!top) {
      top = document.createElement('div');
      top.id = 'cap-intake-status-top';
      top.className = 'small';
      top.style.opacity = '.8';
      top.setAttribute('role','group');
      top.setAttribute('aria-live','polite');
      top.setAttribute('tabindex','0');
    }

    if (top) {
      top.setAttribute('role','group');
      top.setAttribute('aria-live','polite');
      top.setAttribute('tabindex','0');
      top.style.display = 'flex';
      top.style.gap = '8px';
      top.style.flexWrap = 'wrap';
      top.style.alignItems = 'center';
    }

    if (wrap && nab && top) {
      wrap.insertBefore(top, nab);
    } else if (wrap && top && !top.parentElement) {
      wrap.appendChild(top);
    }
  } catch(_) {}
}

const updateCaptureIntakeStatus = debounce(function(){
  const startedAt = (typeof performance !== "undefined" && typeof performance.now === "function") ? performance.now() : null;
  try {
    const statusEl = document.getElementById('cap-intake-status');
    let statusTop = document.getElementById('cap-intake-status-top');
    if (!statusEl && !statusTop) return;

    if (!statusTop) {
      prepareIntakeStatusHeader();
      statusTop = document.getElementById('cap-intake-status-top');
    }

    if (statusTop) {
      statusTop.setAttribute('role','group');
      statusTop.setAttribute('aria-live','polite');
      statusTop.setAttribute('tabindex','0');
    }

    if (!captureIntakeState.logged){
      if (statusEl) {
        statusEl.textContent = 'Bitte anmelden, um Intake zu erfassen.';
        statusEl.style.display = '';
      }
      if (statusTop) {
        statusTop.innerHTML = '';
        statusTop.style.display = 'none';
        statusTop.setAttribute('aria-label', 'Tagesaufnahme: Bitte anmelden, um Intake zu erfassen.');
      }
      return;
    }

    const t = captureIntakeState.totals || {};
    const waterVal = Math.round(t.water_ml || 0);
    const saltVal = Number(t.salt_g || 0);
    const proteinVal = Number(t.protein_g || 0);

    const waterRatio = LS_WATER_GOAL ? waterVal / LS_WATER_GOAL : 0;
    const waterCls = waterRatio >= 0.9 ? 'ok' : (waterRatio >= 0.5 ? 'warn' : 'bad');
    const saltCls = saltVal > LS_SALT_MAX ? 'bad' : (saltVal >= 5 ? 'warn' : 'ok');
    const proteinCls = (proteinVal >= 78 && proteinVal <= LS_PROTEIN_GOAL) ? 'ok' : (proteinVal > LS_PROTEIN_GOAL ? 'bad' : 'warn');

    const describe = (cls) => ({
      ok: 'Zielbereich',
      warn: 'Warnung',
      bad: 'kritisch',
      neutral: 'neutral'
    }[cls] || 'unbekannt');

    const pills = [
      { cls: waterCls, label: 'Wasser', value: `${waterVal} ml` },
      { cls: saltCls, label: 'Salz', value: `${fmtDE(saltVal,1)} g` },
      { cls: proteinCls, label: 'Protein', value: `${fmtDE(proteinVal,1)} g` },
    ];

    const summary = pills.map(p => `${p.label} ${p.value} (${describe(p.cls)})`).join(', ');
    const html = pills.map(p => {
      const statusText = describe(p.cls);
      const aria = `${p.label}: ${p.value}, Status: ${statusText}`;
      return `<span class="pill ${p.cls}" role="status" aria-label="${aria}"><span class="dot" aria-hidden="true"></span>${p.label}: ${p.value}</span>`;
    }).join(' ');

    if (statusEl) {
      statusEl.innerHTML = '';
      statusEl.style.display = 'none';
    }
    if (statusTop) {
      statusTop.innerHTML = html;
      statusTop.style.display = 'flex';
      statusTop.setAttribute('aria-label', `Tagesaufnahme: ${summary}`);
    }
  } finally {
    recordPerfStat('header_intake', startedAt);
  }
}, 150);

function millisUntilNextMidnight(){
  try {
    const now = new Date();
    const next = new Date(now);
    next.setHours(0, 0, 10, 0);
    next.setDate(next.getDate() + 1);
    const diff = next.getTime() - now.getTime();
    return isNaN(diff) ? 3600_000 : Math.max(1000, diff);
  } catch { return 3600_000; }
}

async function handleMidnightRefresh(){
  __midnightTimer = null;
  try {
    await maybeRefreshForTodayChange({ force: true, source: 'midnight' });
  } finally {
    scheduleMidnightRefresh();
  }
}

function scheduleMidnightRefresh(){
  try {
    if (__midnightTimer) clearTimeout(__midnightTimer);
    const delay = millisUntilNextMidnight();
    __midnightTimer = setTimeout(handleMidnightRefresh, delay);
  } catch { /* noop */ }
}

function millisUntilNoonGrace(){
  try {
    const now = new Date();
    const next = new Date(now);
    next.setHours(12, 5, 0, 0);
    if (next.getTime() <= now.getTime()) {
      next.setDate(next.getDate() + 1);
    }
    const diff = next.getTime() - now.getTime();
    return Number.isFinite(diff) ? Math.max(1000, diff) : 3600_000;
  } catch {
    return 3600_000;
  }
}

function scheduleNoonSwitch(){
  try {
    if (__noonTimer) clearTimeout(__noonTimer);
    const delay = millisUntilNoonGrace();
    __noonTimer = setTimeout(handleNoonSwitch, delay);
  } catch { /* noop */ }
}

function startDayHeartbeat(){ /* no-op: auf eventgetriebene Variante umgestellt */ }

function isAfterNoonGrace(){
  try {
    const now = new Date();
    const minutes = now.getHours() * 60 + now.getMinutes();
    return minutes >= (12 * 60 + 5);
  } catch {
    return false;
  }
}

function maybeAutoApplyBpContext({ force = false, source = '' } = {}){
  if (!force && __bpUserOverride) return;
  const select = document.getElementById('bpContextSel');
  if (!select) return;
  const dateEl = document.getElementById('date');
  const todayIso = todayStr();
  const selected = dateEl?.value || '';
  if (selected && selected !== todayIso) return;

  const desired = isAfterNoonGrace() ? 'A' : 'M';
  if (select.value === desired) return;

  select.value = desired;
  applyBpContext(desired);
  updateBpCommentWarnings?.();
  try { diag.add?.(`bp:auto (${source || 'auto'}) -> ${desired}`); } catch(_){ }
}

function handleNoonSwitch(){
  __noonTimer = null;
  try {
    maybeAutoApplyBpContext({ source: 'noon-timer' });
  } finally {
    scheduleNoonSwitch();
  }
}

function getBpPanes(){
  if (!__bpPanesCache || __bpPanesCache.length === 0) {
    __bpPanesCache = Array.from(document.querySelectorAll('.bp-pane'));
  }
  return __bpPanesCache;
}

function applyBpContext(value){
  const ctx = value === 'A' ? 'A' : 'M';
  getBpPanes().forEach(pane => {
    const match = pane.getAttribute('data-context') === ctx;
    pane.classList.toggle('active', match);
  });
}

async function maybeRefreshForTodayChange({ force = false, source = '' } = {}){
  const todayIso = todayStr();
  const dateEl = document.getElementById('date');
  const selected = dateEl?.value || '';
  const todayChanged = __lastKnownToday !== todayIso;
  if (!force && !todayChanged) return;

  const userPinnedOtherDay = __dateUserSelected && selected && selected !== todayIso;
  if (!userPinnedOtherDay && dateEl) {
    if (selected !== todayIso) {
      dateEl.value = todayIso;
    }
    __dateUserSelected = false;
  }

  try {
    await refreshCaptureIntake();
  } catch(_) {}

  __lastKnownToday = todayIso;
  if (!__midnightTimer) scheduleMidnightRefresh();
  scheduleNoonSwitch();
  if (!userPinnedOtherDay) {
    __bpUserOverride = false;
    maybeAutoApplyBpContext({ force: true, source: source || 'day-change' });
  }
  try { diag.add?.(`intake: day refresh (${source || 'auto'})`); } catch(_) {}
}


async function getAppointmentsEndpoint(){
  const rest = await getConf('webhookUrl');
  if (!rest) return null;
  const base = baseUrlFromRest(rest);
  if (!base) {
    setConfigStatus('Bitte REST-Endpoint konfigurieren.', 'error');
    return null;
  }
  return { base };
}

function getAppointmentRoleLabel(code){
  const role = APPOINTMENT_ROLES.find(r => r.code === code);
  return role ? role.label : (code || '');
}

const setAppointmentBadge = debounce(function(details){
  const badge = document.getElementById('nextApptBadge');
  if (!badge) return;

  const startedAt = (typeof performance !== "undefined" && typeof performance.now === "function") ? performance.now() : null;
  try {
    badge.setAttribute('role','status');
    badge.setAttribute('aria-live','polite');
    badge.setAttribute('tabindex','0');

    const role = details?.role || null;
    const dtIso = details?.dt || null;

    if (!role || !dtIso) {
      badge.textContent = 'Kein Termin geplant';
      badge.title = 'Kein Termin geplant';
      badge.setAttribute('aria-label', 'Kein Termin geplant');
      badge.dataset.role = '';
      badge.dataset.dt = '';
      return;
    }

    const label = getAppointmentRoleLabel(role);
    const formatted = formatDateTimeDE(dtIso);
    const text = `N\u00e4chster Arzttermin bei: ${label} am: ${formatted}`;
    badge.textContent = text;
    badge.title = `Arzttermin bei ${label} am ${formatted}`;
    badge.setAttribute('aria-label', text);
    badge.dataset.role = role;
    badge.dataset.dt = dtIso;
  } finally {
    recordPerfStat('header_appt', startedAt);
  }
}, 160);

function computeNextAppointment(summary){
  if (!summary) return null;
  let nextRole = null;
  let nextIso = null;
  let nextTs = Number.POSITIVE_INFINITY;
  const nowTs = Date.now();

  for (const { code } of APPOINTMENT_ROLES) {
    const nextCandidate = summary[code]?.next;
    if (!nextCandidate) continue;
    const ts = Date.parse(nextCandidate);
    if (!Number.isFinite(ts)) continue;
    if (ts < nowTs - APPOINTMENT_GRACE_MS) continue;
    if (ts < nextTs) {
      nextTs = ts;
      nextRole = code;
      nextIso = nextCandidate;
    }
  }

  if (!nextRole || !nextIso) return null;
  return { role: nextRole, dt: nextIso };
}

function validateAppointmentInput({ date, time }){
  if (!date || !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return { ok: false, error: 'date' };
  }
  if (!time || !/^([01]\d|2[0-3]):[0-5]\d$/.test(time)) {
    return { ok: false, error: 'time' };
  }
  const dt = new Date(`${date}T${time}:00`);
  if (Number.isNaN(dt.getTime())) {
    return { ok: false, error: 'invalid' };
  }
  return { ok: true, iso: dt.toISOString() };
}

function resetAppointmentsUi(){
  APPOINTMENT_ROLES.forEach(({ code }) => {
    const nextEl = document.getElementById(`appt-${code}-next`);
    const lastEl = document.getElementById(`appt-${code}-last`);
    const doneBtn = document.getElementById(`appt-${code}-done`);
    if (nextEl) nextEl.textContent = '\u2014';
    if (lastEl) lastEl.textContent = '\u2014';
    if (doneBtn){
      doneBtn.disabled = true;
      doneBtn.dataset.hasNext = '0';
      doneBtn.hidden = true;
    }
  });
  appointmentsState.next = null;
  setAppointmentBadge();
}

function applyAppointmentsUi(summary){
  APPOINTMENT_ROLES.forEach(({ code }) => {
    const record = summary && summary[code] ? summary[code] : { next: null, last: null };
    const nextEl = document.getElementById(`appt-${code}-next`);
    const lastEl = document.getElementById(`appt-${code}-last`);
    const doneBtn = document.getElementById(`appt-${code}-done`);
    if (nextEl) nextEl.textContent = formatDateTimeDE(record.next);
    if (lastEl) lastEl.textContent = formatDateTimeDE(record.last);
    if (doneBtn){
      doneBtn.disabled = !record.next;
      doneBtn.dataset.hasNext = record.next ? '1' : '0';
      doneBtn.hidden = !record.next;
    }
  });
}

async function fetchAppointmentsSummary(){
  const rest = await getConf('webhookUrl');
  if (!rest) return null;
  const base = baseUrlFromRest(rest);
  if (!base) return null;

  const fetchJson = async (url) => {
    const res = await fetchWithAuth(
      headers => fetch(url.toString(), { headers }),
      { tag: 'appt:summary', maxAttempts: 2 }
    );
    if (res.status === 404) return [];
    if (!res.ok) {
      let details = '';
      try { const err = await res.json(); details = err?.message || err?.details || ''; } catch(_){ }
      throw new Error(`appointments fetch failed ${res.status} ${details}`);
    }
    return await res.json();
  };

  const scheduledUrl = new URL(`${base}/rest/v1/appointments`);
  scheduledUrl.searchParams.set('select', 'role,dt');
  scheduledUrl.searchParams.set('status', 'eq.scheduled');
  scheduledUrl.searchParams.set('order', 'dt.asc');

  const doneUrl = new URL(`${base}/rest/v1/appointments`);
  doneUrl.searchParams.set('select', 'role,dt');
  doneUrl.searchParams.set('status', 'eq.done');
  doneUrl.searchParams.set('order', 'dt.desc');

  const [scheduled, done] = await Promise.all([
    fetchJson(scheduledUrl),
    fetchJson(doneUrl)
  ]);
  return { scheduled, done };
}

async function refreshAppointments(){
  if (appointmentsState.loading) return;
  appointmentsState.loading = true;
  try {
    const summaryRaw = await fetchAppointmentsSummary();
    const scheduledList = Array.isArray(summaryRaw?.scheduled) ? summaryRaw.scheduled : [];
    const doneList = Array.isArray(summaryRaw?.done) ? summaryRaw.done : [];

    const scheduledMap = new Map();
    for (const item of scheduledList) {
      const role = item?.role;
      const dt = item?.dt;
      if (!role || !dt) continue;
      if (!scheduledMap.has(role)) {
        scheduledMap.set(role, item);
      }
    }

    const doneMap = new Map();
    for (const item of doneList) {
      const role = item?.role;
      const dt = item?.dt;
      if (!role || !dt) continue;
      if (!doneMap.has(role)) {
        doneMap.set(role, item);
      }
    }

    const summary = Object.create(null);
    const now = Date.now();

    APPOINTMENT_ROLES.forEach(({ code }) => {
      let nextIso = null;
      let lastIso = doneMap.get(code)?.dt ?? null;

      const scheduled = scheduledMap.get(code);
      if (scheduled?.dt) {
        const ts = Date.parse(scheduled.dt);
        if (Number.isFinite(ts)) {
          if (ts >= now - APPOINTMENT_GRACE_MS) {
            nextIso = scheduled.dt;
          } else if (!lastIso) {
            lastIso = scheduled.dt;
          }
        }
      }

      summary[code] = { next: nextIso, last: lastIso };
    });

    appointmentsState.data = summary;
    appointmentsState.loaded = true;
    applyAppointmentsUi(summary);
    const nextAppt = computeNextAppointment(summary);
    appointmentsState.next = nextAppt;
    setAppointmentBadge(nextAppt);
  } catch (e) {
    try { diag.add?.('appointments refresh error: ' + (e?.message || e)); } catch(_){}
    appointmentsState.data = Object.create(null);
    appointmentsState.loaded = false;
    resetAppointmentsUi();
  } finally {
    appointmentsState.loading = false;
  }
}


async function handleAppointmentSave(role){
  const dateEl = document.getElementById(`appt-${role}-date`);
  const timeEl = document.getElementById(`appt-${role}-time`);
  const saveBtn = document.getElementById(`appt-${role}-save`);
  if (!dateEl || !timeEl || !saveBtn) return;

  const date = (dateEl.value || '').trim();
  const time = (timeEl.value || '').trim();
  const validation = validateAppointmentInput({ date, time });
  if (!validation.ok){
    if (validation.error === 'date'){
      uiError('Bitte Datum waehlen.');
      dateEl.focus();
    } else if (validation.error === 'time'){
      uiError('Bitte Uhrzeit im Format HH:MM angeben.');
      timeEl.focus();
    } else {
      uiError('Bitte Datum/Uhrzeit pruefen.');
      timeEl.focus();
    }
    return;
  }

  const endpoint = await getAppointmentsEndpoint();
  const base = endpoint?.base || null;
  const iso = validation.iso;

  const hasScheduled = !!(appointmentsState.data && appointmentsState.data[role] && appointmentsState.data[role].next);
  const patchUrl = base ? new URL(base + '/rest/v1/appointments') : null;
  if (patchUrl){
    patchUrl.searchParams.set('status', 'eq.scheduled');
    patchUrl.searchParams.set('role', 'eq.' + role);
  }

  const body = JSON.stringify({ dt: iso });
  withBusy(saveBtn, true);
  try {
    if (!base || !patchUrl){
      const errMissing = new Error('appointments-endpoint-missing');
      errMissing.status = 401;
      throw errMissing;
    }

    let saved = false;
    if (hasScheduled){
      const res = await fetchWithAuth(
        headers => fetch(patchUrl.toString(), { method: 'PATCH', headers, body }),
        { tag: 'appt:patch', maxAttempts: 2 }
      );
      if (!res.ok){
        let details = '';
        try { const err = await res.json(); details = err?.message || err?.details || ''; } catch(_){ }
        if (res.status === 400){
          uiError('Bitte Datum/Uhrzeit pruefen (HH:MM).');
          timeEl.focus();
          return;
        }
        if (res.status !== 404){
          const errPatch = new Error('appointments-patch-failed');
          errPatch.status = res.status;
          errPatch.details = details;
          throw errPatch;
        }
      } else {
        saved = true;
      }
    }

    if (!saved){
      const uid = await getUserId();
      if (!uid){
        const errAuth = new Error('appointments-user-missing');
        errAuth.status = 401;
        throw errAuth;
      }
      const postUrl = new URL(base + '/rest/v1/appointments');
      const payload = JSON.stringify([{ role, dt: iso, status: 'scheduled', user_id: uid }]);
      const resPost = await fetchWithAuth(
        headers => fetch(postUrl.toString(), { method: 'POST', headers, body: payload }),
        { tag: 'appt:post', maxAttempts: 2 }
      );
      if (resPost.status === 409){
        uiError('Es existiert bereits ein geplanter Termin. Bitte aktualisieren.');
        return;
      }
      if (!resPost.ok){
        let details = '';
        try { const err = await resPost.json(); details = err?.message || err?.details || ''; } catch(_){ }
        if (resPost.status === 400){
          uiError('Bitte Datum/Uhrzeit pruefen (HH:MM).');
          timeEl.focus();
          return;
        }
        const errPost = new Error('appointments-post-failed');
        errPost.status = resPost.status;
        errPost.details = details;
        throw errPost;
      }
    }

    dateEl.value = '';
    timeEl.value = '';
    await refreshAppointments();
    uiInfo('Termin gespeichert.');
  } catch (e){
    if (e?.status === 400){
      uiError('Bitte Datum/Uhrzeit pruefen (HH:MM).');
      timeEl.focus();
    } else if (e?.status === 401 || e?.status === 403){
      showLoginOverlay(true);
      uiError('Bitte erneut anmelden.');
    } else if (e?.status) {
      uiRestError(e.status, e.details || e.message);
      try { diag.add?.('appointments save error (' + role + '): ' + (e?.details || e?.message || e)); } catch(_){ }
    } else {
      uiError('Speichern fehlgeschlagen. Bitte erneut versuchen.');
      try { diag.add?.('appointments save error (' + role + '): ' + (e?.message || e)); } catch(_){ }
    }
  } finally {
    withBusy(saveBtn, false);
  }
}
async function handleAppointmentDone(role){
  const btn = document.getElementById(`appt-${role}-done`);
  if (!btn || btn.hidden || btn.disabled || btn.dataset.hasNext !== '1') return;

  const endpoint = await getAppointmentsEndpoint();
  const base = endpoint?.base || null;
  withBusy(btn, true);
  try {
    if (!base){
      const errMissing = new Error('appointments-endpoint-missing');
      errMissing.status = 401;
      throw errMissing;
    }
    const url = new URL(base + '/rest/v1/appointments');
    url.searchParams.set('status', 'eq.scheduled');
    url.searchParams.set('role', 'eq.' + role);
    const body = JSON.stringify({ status: 'done' });

    const res = await fetchWithAuth(
      headers => fetch(url.toString(), { method: 'PATCH', headers, body }),
      { tag: 'appt:done', maxAttempts: 2 }
    );
    if (!res.ok){
      let details = '';
      try { const err = await res.json(); details = err?.message || err?.details || ''; } catch(_){ }
      if (res.status === 404){
        uiError('Kein geplanter Termin vorhanden.');
        await refreshAppointments();
        return;
      }
      const errDone = new Error('appointments-done-failed');
      errDone.status = res.status;
      errDone.details = details;
      throw errDone;
    }
    await refreshAppointments();
    uiInfo('Termin abgeschlossen.');
  } catch (e){
    if (e?.status === 401 || e?.status === 403){
      showLoginOverlay(true);
      uiError('Bitte erneut anmelden.');
    } else if (e?.status) {
      uiRestError(e.status, e.details || e.message, 'Termin konnte nicht abgeschlossen werden.');
      try { diag.add?.('appointments done error (' + role + '): ' + (e?.details || e?.message || e)); } catch(_){ }
    } else {
      uiError('Termin konnte nicht abgeschlossen werden.');
      try { diag.add?.('appointments done error (' + role + '): ' + (e?.message || e)); } catch(_){ }
    }
  } finally {
    withBusy(btn, false);
  }
}
function bindAppointmentsPanel(){
  APPOINTMENT_ROLES.forEach(({ code }) => {
    const saveBtn = document.getElementById(`appt-${code}-save`);
    const doneBtn = document.getElementById(`appt-${code}-done`);
    if (saveBtn) saveBtn.addEventListener('click', () => handleAppointmentSave(code));
    if (doneBtn) doneBtn.addEventListener('click', () => handleAppointmentDone(code));
  });
}

async function refreshCaptureIntake(){
  const wrap = document.getElementById('cap-intake-wrap');
  if (!wrap) return;
  const dayIso = document.getElementById('date')?.value || todayStr();
  captureIntakeState.dayIso = dayIso;
  clearCaptureIntakeInputs();

const logged = await isLoggedInFast();
// Unknown-Phase: so tun, als ob weiter eingeloggt (keine Sperre!)
const effectiveLogged = (__authState === 'unknown' && __lastLoggedIn) ? true : !!logged;
captureIntakeState.logged = effectiveLogged;

if (!effectiveLogged){
  captureIntakeState.totals = { water_ml: 0, salt_g: 0, protein_g: 0 };
  setCaptureIntakeDisabled(true);
  updateCaptureIntakeStatus();
  try{ __lsTotals = { water_ml: 0, salt_g: 0, protein_g: 0 }; updateLifestyleBars(); }catch(_){ }
  return;
}

setCaptureIntakeDisabled(false);
try{
  const uid = await getUserId();
  // Unknown-Phase: UID kann transient null sein -> NICHT sperren
  if (!uid && __authState !== 'unknown'){
    captureIntakeState.logged = false;
    captureIntakeState.totals = { water_ml: 0, salt_g: 0, protein_g: 0 };
    setCaptureIntakeDisabled(true);
  } else {
      const totals = await loadIntakeToday({ user_id: uid, dayIso });
      captureIntakeState.totals = totals || { water_ml: 0, salt_g: 0, protein_g: 0 };
      captureIntakeState.logged = true;
      try{ __lsTotals = captureIntakeState.totals; updateLifestyleBars(); }catch(_){ }
    }
  }catch(e){
    captureIntakeState.totals = { water_ml: 0, salt_g: 0, protein_g: 0 };
    try{ diag.add?.('Capture intake load error: ' + (e?.message || e)); }catch(_){}

  try{ updateLifestyleBars(); }catch(_){ }
  }

  __lastKnownToday = todayStr();
  updateCaptureIntakeStatus();
}

async function handleCaptureIntake(kind){
  const btn = document.getElementById(`cap-${kind}-add-btn`);
  const input = document.getElementById(`cap-${kind}-add`);
  if (!btn || !input) return;

  try { diag.add?.(`[capture] click ${kind}`); } catch(_){}

  try {
    if (!__dateUserSelected) {
      const todayIso = todayStr();
      const dateEl = document.getElementById('date');
      const selected = dateEl?.value || '';
      const stateDay = captureIntakeState.dayIso || '';
      if (stateDay !== todayIso || (selected && selected !== todayIso)) {
        await maybeRefreshForTodayChange({ force: true, source: 'capture:intake-click' });
      }
    }
  } catch(_){ }

  const dayIso = document.getElementById('date')?.value || todayStr();
  captureIntakeState.dayIso = dayIso;

  let value;
  if (kind === 'water'){
    value = Number(input.value);
    if (!(value > 0)){ uiError('Bitte gueltige Wassermenge eingeben.'); try { diag.add?.('[capture] blocked: invalid water value ' + input.value); } catch(_){ } return; }
  } else {
    value = toNumDE(input.value);
    if (!(value > 0)){
      uiError(kind === 'salt' ? 'Bitte gueltige Salzmenge eingeben.' : 'Bitte gueltige Proteinmenge eingeben.');
      try { diag.add?.(`[capture] blocked: invalid ${kind} value ${input.value}`); } catch(_){}
      return;
    }
  }
  try { diag.add?.(`[capture] parsed ${kind}=${value}`); } catch(_){}

  const totals = { ...captureIntakeState.totals };
  let message = '';
  if (kind === 'water'){
    const total = Math.min(6000, Math.max(0, (totals.water_ml || 0) + value));
    totals.water_ml = Math.round(total);
    message = 'Wasser aktualisiert.';
  } else if (kind === 'salt'){
    const total = Math.min(30, Math.max(0, (totals.salt_g || 0) + value));
    totals.salt_g = Number(total.toFixed(2));
    message = 'Salz aktualisiert.';
  } else {
    const total = Math.min(300, Math.max(0, (totals.protein_g || 0) + value));
    totals.protein_g = Number(total.toFixed(2));
    message = 'Protein aktualisiert.';
  }
  try { diag.add?.(`[capture] totals ${JSON.stringify(totals)}`); } catch(_){}

withBusy(btn, true);
try{
    diag.add?.(`[capture] save start ${kind}: ${JSON.stringify(totals)}`);
    await saveIntakeTotals({ dayIso, totals });
    captureIntakeState.totals = totals;
    captureIntakeState.logged = true;
    input.value = '';
    updateCaptureIntakeStatus();
    const needsLifestyle = dayIso === todayStr();
    await requestUiRefresh({ reason: 'capture:intake' });
    uiInfo(message);
    diag.add?.(`[capture] save ok ${kind}`);
  }catch(e){
    const msg = e?.details || e?.message || e;
    if (e?.status === 401 || e?.status === 403) {
      showLoginOverlay(true);
      uiError('Bitte erneut anmelden, um weiter zu speichern.');
    } else {
      uiError('Update fehlgeschlagen: ' + msg);
    }
    try{ diag.add?.(`[capture] save error ${kind}: ` + msg); }catch(_){}
  }finally{
    withBusy(btn, false);
  }
}

function bindIntakeCapture(){
  const wire = (id, kind) => {
    const oldBtn = document.getElementById(id);
    if (!oldBtn) return;

    // alten Button durch Clone ersetzen => entfernt alle alten Listener
    const fresh = oldBtn.cloneNode(true);
    oldBtn.replaceWith(fresh);

    // Safety: niemals "busy"/disabled, und Typ setzen
    fresh.disabled = false;
    fresh.classList.remove('busy');
    fresh.removeAttribute('aria-busy');
    fresh.removeAttribute('data-busy');
    if (!fresh.type) fresh.type = 'button';

    // Click-Handler binden (idempotent, weil frisch)
    fresh.addEventListener('click', () => {
      try { handleCaptureIntake(kind); } catch(_) {}
    });
  };

  wire('cap-water-add-btn',   'water');
  wire('cap-salt-add-btn',    'salt');
  wire('cap-protein-add-btn', 'protein');
}

function setProgState(el, state){
  if (!el) return;
  el.classList.remove('ok','warn','bad');
  if (state) el.classList.add(state);
}

function fmtDE(n, digits){
  if (!Number.isFinite(n)) return '0';
  return n.toFixed(digits).replace('.', ',');
}

function updateLifestyleBars(){
  const wBar = document.getElementById('ls-water-bar');
  const wProg = document.getElementById('ls-water-prog');
  const wLbl = document.getElementById('ls-water-label');
  const sBar = document.getElementById('ls-salt-bar');
  const sProg = document.getElementById('ls-salt-prog');
  const sLbl = document.getElementById('ls-salt-label');
  const pBar = document.getElementById('ls-protein-bar');
  const pProg = document.getElementById('ls-protein-prog');
  const pLbl = document.getElementById('ls-protein-label');

  const w = Math.max(0, Math.min(__lsTotals.water_ml || 0, 6000));
  const s = Math.max(0, Math.min(__lsTotals.salt_g || 0, 30));
  const p = Math.max(0, Math.min(__lsTotals.protein_g || 0, 300));

  const wPct = Math.min(1, w / LS_WATER_GOAL) * 100;
  const sPct = Math.min(1, s / LS_SALT_MAX) * 100;
  const pPct = Math.min(1, p / LS_PROTEIN_GOAL) * 100;

  if (wBar) wBar.style.width = `${wPct.toFixed(1)}%`;
  if (sBar) sBar.style.width = `${sPct.toFixed(1)}%`;
  if (pBar) pBar.style.width = `${pPct.toFixed(1)}%`;

  if (wLbl) {
    let status = '';
    if (w >= LS_WATER_GOAL * 1.1) status = ' * Ziel erreicht';
    else if (w >= LS_WATER_GOAL * 0.9) status = ' * Zielbereich';
    else if (w >= LS_WATER_GOAL * 0.5) status = ' * moderate Aufnahme';
    else status = ' * niedrig';
    wLbl.textContent = `${w|0} / ${LS_WATER_GOAL} ml${status}`;
  }

  if (sLbl) {
    let status = ' * Zielbereich';
    if (s > LS_SALT_MAX) status = ' * ueber Ziel';
    else if (s >= 5) status = ' * Warnung';
    sLbl.textContent = `${fmtDE(s,1)} / ${fmtDE(LS_SALT_MAX,1)} g${status}`;
  }

  if (pLbl) {
    let status = ' * noch offen';
    if (p >= 78 && p <= 90) status = ' * Zielbereich';
    else if (p > 90) status = ' * ueber Ziel';
    pLbl.textContent = `${fmtDE(p,1)} / ${fmtDE(LS_PROTEIN_GOAL,1)} g${status}`;
  }

  // Wasser: <50% rot, 50-89% gelb, 90% gruen
  let wState = 'bad';
  if (w >= LS_WATER_GOAL * 0.9) wState = 'ok';
  else if (w >= LS_WATER_GOAL * 0.5) wState = 'warn';
  setProgState(wProg, wState);

  // Salz: 0-4.9 g gruen, 5-6 gelb, >6 rot
  let sState = 'ok';
  if (s > LS_SALT_MAX) sState = 'bad';
  else if (s >= 5) sState = 'warn';
  setProgState(sProg, sState);

  // Protein: <78 neutral, 78-90 gruen, >90 rot
  let pState = 'neutral';
  if (p >= 78 && p <= 90) pState = 'ok';
  else if (p > 90) pState = 'bad';
  setProgState(pProg, pState);
}

async function renderLifestyle(){
  const logged = await isLoggedIn();
  if (!logged){
    // Nichts anzeigen, Tab ist ohnehin gesperrt
    return;
  }
  try{
    const uid = await getUserId();
    const dayIso = todayStr();
    const cur = await loadIntakeToday({ user_id: uid, dayIso });
    __lsTotals = { water_ml: cur.water_ml||0, salt_g: cur.salt_g||0, protein_g: cur.protein_g||0 };
    updateLifestyleBars();
  }catch(_){ /* ignore */ }
}

function bindLifestyle(){
  const addWaterBtn = document.getElementById('ls-water-add-btn');
  const addSaltBtn = document.getElementById('ls-salt-add-btn');
  const addProtBtn = document.getElementById('ls-protein-add-btn');

  const addWater = async ()=>{
    const el = document.getElementById('ls-water-add');
    const v = Number(el?.value || 0);
    if (!(v>0)) { uiError('Bitte gueltige Wassermenge eingeben.'); return; }

    const dayIso = todayStr();
    let total = Math.min(6000, Math.max(0, (__lsTotals.water_ml||0) + v));
    if (total > 6000) total = 6000;
    try{
      await saveIntakeTotals({ dayIso, totals: { water_ml: total, salt_g: __lsTotals.salt_g||0, protein_g: __lsTotals.protein_g||0 } });
      __lsTotals.water_ml = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Wasser aktualisiert.');
    }catch(e){ uiError('Update fehlgeschlagen: ' + (e?.message||e)); try{ diag.add?.('Lifestyle update error (water): ' + (e?.message||e)); }catch(_){} }
  };

  const addSalt = async ()=>{
    const el = document.getElementById('ls-salt-add');
    const v = toNumDE(el?.value);
    if (!(v>0)) { uiError('Bitte gueltige Salzmenge eingeben.'); return; }
    const dayIso = todayStr();
    let total = (__lsTotals.salt_g||0) + v;
    if (total > 30) total = 30;
    try{
      await saveIntakeTotals({ dayIso, totals: { water_ml: __lsTotals.water_ml||0, salt_g: total, protein_g: __lsTotals.protein_g||0 } });
      __lsTotals.salt_g = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Salz aktualisiert.');
    }catch(e){ uiError('Update fehlgeschlagen: ' + (e?.message||e)); try{ diag.add?.('Lifestyle update error (salt): ' + (e?.message||e)); }catch(_){} }
  };

  const addProtein = async ()=>{
    const el = document.getElementById('ls-protein-add');
    const v = toNumDE(el?.value);
    if (!(v>0)) { uiError('Bitte gueltige Proteinmenge eingeben.'); return; }
    const dayIso = todayStr();
    let total = (__lsTotals.protein_g||0) + v;
    if (total > 300) total = 300;
    try{
      await saveIntakeTotals({ dayIso, totals: { water_ml: __lsTotals.water_ml||0, salt_g: __lsTotals.salt_g||0, protein_g: total } });
      __lsTotals.protein_g = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Protein aktualisiert.');
    }catch(e){ uiError('Update fehlgeschlagen: ' + (e?.message||e)); try{ diag.add?.('Lifestyle update error (protein): ' + (e?.message||e)); }catch(_){} }
  };

  if (addWaterBtn) addWaterBtn.addEventListener('click', addWater);
  if (addSaltBtn) addSaltBtn.addEventListener('click', addSalt);
  if (addProtBtn) addProtBtn.addEventListener('click', addProtein);
}

// PATCH: bestehende day_flags eines Tages aktualisieren (RLS: nur eigene Records)
async function patchDayFlags({ user_id, dayIso, flags }){
  const url = await getConf("webhookUrl");
  if (!url || !user_id || !dayIso) {
    const err = new Error('patchDayFlags: missing params');
    err.status = 401;
    throw err;
  }

  const from = `${dayIso}T00:00:00Z`;
  const toNext = new Date(from); toNext.setUTCDate(toNext.getUTCDate()+1);
  const toIso = toNext.toISOString().slice(0,10);

  const q = `${url}?user_id=eq.${encodeURIComponent(user_id)}&type=eq.day_flags`+
            `&ts=gte.${encodeURIComponent(dayIso)}T00:00:00Z&ts=lt.${encodeURIComponent(toIso)}T00:00:00Z`;
  const res = await fetchWithAuth(
    headers => fetch(q, { method: 'PATCH', headers, body: JSON.stringify({ payload: flags }) }),
    { tag: 'flags:patch', maxAttempts: 2 }
  );
  if (!res.ok) {
    let details = '';
    try { const e = await res.json(); details = e?.message || e?.details || ''; } catch {}
    throw new Error(`patch day_flags failed ${res.status} - ${details}`);
  }
  return await res.json();
}


async function appendNoteRemote(opts){
  const { user_id, dayIso, noteEvent } = opts || {};
  const url = await getConf("webhookUrl");
  if (!url || !user_id || !dayIso) {
    const err = new Error('appendNoteRemote: missing params');
    err.status = 401;
    throw err;
  }

  const from = `${dayIso}T00:00:00Z`;
  const toNext = new Date(from); toNext.setUTCDate(toNext.getUTCDate() + 1);
  const toIso = toNext.toISOString().slice(0, 10);
  const baseQuery = `${url}?user_id=eq.${encodeURIComponent(user_id)}&type=eq.note`
                  + `&ts=gte.${encodeURIComponent(dayIso)}T00:00:00Z&ts=lt.${encodeURIComponent(toIso)}T00:00:00Z`;

  const resGet = await fetchWithAuth(
    headers => fetch(baseQuery, { method: 'GET', headers }),
    { tag: 'note:get', maxAttempts: 2 }
  );
  if (!resGet.ok) throw new Error(`note-get-failed-${resGet.status}`);
  const rows = await resGet.json();
  const existing = Array.isArray(rows) && rows[0] ? rows[0] : null;

  const addition = (noteEvent?.payload?.text || '').trim();
  if (!addition) {
    return existing ? { id: existing.id, text: existing?.payload?.text || '' } : { id: null, text: '' };
  }

  const combineText = (prev, add) => {
    if (!prev) return add;
    return `${prev.trim()}
${add}`.trim();
  };

  if (existing) {
    const combined = combineText(existing?.payload?.text || '', addition);
    const patchRes = await fetchWithAuth(
      headers => fetch(`${url}?id=eq.${encodeURIComponent(existing.id)}`, {
        method: 'PATCH',
        headers,
        body: JSON.stringify({ payload: { text: combined } })
      }),
      { tag: 'note:patch', maxAttempts: 2 }
    );
    if (!patchRes.ok) throw new Error(`note-patch-failed-${patchRes.status}`);
    const patched = await patchRes.json().catch(() => null);
    const patchedId = patched?.[0]?.id ?? existing.id;
    return { id: patchedId, text: combined };
  }

  const body = [{ ...noteEvent, user_id }];
  const postRes = await fetchWithAuth(
    headers => fetch(url, { method: 'POST', headers, body: JSON.stringify(body) }),
    { tag: 'note:post', maxAttempts: 2 }
  );
  if (!postRes.ok) throw new Error(`note-post-failed-${postRes.status}`);
  const created = await postRes.json().catch(() => null);
  const newId = created?.[0]?.id ?? null;
  return { id: newId, text: addition };
}

async function pushPendingToRemote(){
  const url = await getConf("webhookUrl");
  if(!url) return { pushed:0, failed:0 };

  const all = await getAllEntries();
  const pending = all.filter(e => !e.remote_id);

  let pushed = 0, failed = 0;

  for (const e of pending){
    try{
      const uid = await getUserId();

      // 1) Legacy-Entry  0..N Events
      const events = toHealthEvents(e);
      if (!events.length) { 
        // nichts sendbar: als "abgearbeitet" markieren, damit wir nicht haengen bleiben
        await updateEntry(e.id, { remote_id: -1 });
        continue;
      }

      // 2) user_id anhaengen (RLS)
      const payload = uid ? events.map(ev => ({...ev, user_id: uid})) : events;

      // 3) Batch-POST (Array)
      const res = await fetchWithAuth(
        headers => fetch(url, {
          method: "POST",
          headers,
          body: JSON.stringify(payload)
        }),
        { tag: 'pending:post', maxAttempts: 2 }
      );
      if (!res.ok) { failed++; continue; }

      const json = await res.json();
      const firstId = json?.[0]?.id ?? null;

      // 4) Lokal markieren: irgendein Remote-Event existiert  Cloud-Icon ok
      if (firstId != null) {
        await updateEntry(e.id, { remote_id: firstId });
        pushed++;
      } else {
        failed++;
      }

      await sleep(50);
    } catch(err){
      failed++;
      if (err?.status === 401 || err?.status === 403) {
        try { diag.add?.('[push] auth error, abbrechen'); } catch(_){}
        break;
      }
    }
  }

  return { pushed, failed };
}

async function prefillSupabaseConfigForm(){
  try {
    setConfigStatus('', 'info');
    const restInput = document.getElementById('configRestUrl');
    const keyInput = document.getElementById('configAnonKey');
    const adv = document.getElementById('configAdv');
    const rest = await getConf('webhookUrl');
    const keyStored = await getConf('webhookKey');
    if (restInput) {
      restInput.value = rest || '';
    }
    if (keyInput) {
      keyInput.value = keyStored ? keyStored.replace(/^Bearer\s+/i, '') : '';
    }
    if (adv) {
      const hasRest = !!(rest && String(rest).trim());
      const hasKey = !!(keyStored && String(keyStored).trim());
      adv.open = !(hasRest && hasKey) && !DEV_ALLOW_DEFAULTS;
    }
  } catch(_){ }
}

function setConfigStatus(msg, tone = 'info'){
  const el = document.getElementById('configStatus');
  if (!el) return;
  el.textContent = msg || '';
  const colors = { error: '#f87171', success: '#34d399', info: '#9aa3af' };
  el.style.color = colors[tone] || colors.info;
}

function showLoginOverlay(show){
  const ov = document.getElementById('loginOverlay');
  if (!ov) return;
  const dialog = ov.querySelector('[role="dialog"]') || ov;
  if (show){
    ov.style.display = 'flex';
    prefillSupabaseConfigForm();
    focusTrap.activate(dialog);
  } else {
    ov.style.display = 'none';
    focusTrap.deactivate();
  }
}
function setUserUi(email){
  const who = document.getElementById('whoAmI');
  if (who) who.textContent = email ? `Angemeldet als: ${email}` : '';
}

let __lastLoggedIn = false;
let __authState = 'unauth'; // 'auth' | 'unauth' | 'unknown'
let __authGraceTimer = null;
let __pendingSignOut = null;
const AUTH_GRACE_MS = 400;
async function isLoggedInFast({ timeout = 400 } = {}) {
  if (!sbClient) return __lastLoggedIn;
  let timer = null;
  try {
    const sessionPromise = sbClient.auth.getSession();
    const timeoutPromise = new Promise((_, reject) => {
      timer = setTimeout(() => reject(new Error('session-timeout')), timeout);
    });
    const { data } = await Promise.race([sessionPromise, timeoutPromise]);
    if (timer) clearTimeout(timer);
    const logged = !!data?.session;
    if (__authState === 'unknown' && !logged && __lastLoggedIn) {
      return __lastLoggedIn;
    }
    __lastLoggedIn = logged;
    if (__authState !== 'unknown') {
      __authState = logged ? 'auth' : 'unauth';
    }
    return logged;
  } catch(_){
    if (timer) clearTimeout(timer);
    return __lastLoggedIn;
  }
}

function clearAuthGrace(){
  if (__authGraceTimer){
    clearTimeout(__authGraceTimer);
    __authGraceTimer = null;
  }
}

function applyAuthUi(logged){
  try { setAuthGuard(!!logged); } catch(_){}
  try { setDoctorAccess(!!logged); } catch(_){}
  if (logged){
    showLoginOverlay(false);
  } else if (__authState !== 'unknown'){
    showLoginOverlay(true);
  }
}

function finalizeAuthState(logged){
  clearAuthGrace();
  __authState = logged ? 'auth' : 'unauth';
  __lastLoggedIn = logged;
  if (logged){
    __pendingSignOut = null;
  } else if (typeof __pendingSignOut === 'function'){
    Promise.resolve(__pendingSignOut()).catch(()=>{}).finally(()=>{ __pendingSignOut = null; });
  }
  applyAuthUi(logged);
}

function scheduleAuthGrace(){
  clearAuthGrace();
  __authState = 'unknown';
  __authGraceTimer = setTimeout(async ()=>{
    try{
      if (!sbClient){
        finalizeAuthState(false);
        return;
      }
      diag.add?.("[capture] guard: request session");
  const { data } = await sbClient.auth.getSession();
  diag.add?.("[capture] guard: session resp");
      finalizeAuthState(!!data?.session);
    }catch(_){
      finalizeAuthState(false);
    }
  }, AUTH_GRACE_MS);
}

// Buttons binden (einmalig, z. B. in main())
function bindAuthButtons(){
const gbtn = document.getElementById('googleLoginBtn');
const saveBtn = document.getElementById('configSaveBtn');

if (saveBtn) saveBtn.addEventListener('click', async ()=>{
  const restInput = document.getElementById('configRestUrl');
  const keyInput = document.getElementById('configAnonKey');
  const rawRest = (restInput?.value || '').trim();
  const rawKey = (keyInput?.value || '').trim();
  if (!rawRest || !rawKey){
    setConfigStatus('Bitte REST-Endpoint und ANON-Key eingeben.', 'error');
    return;
  }
  if (!/\/rest\/v1\//i.test(rawRest)){
    setConfigStatus('REST-Endpoint muss /rest/v1/ enthalten.', 'error');
    return;
  }
  try {
    new URL(rawRest);
  } catch {
    setConfigStatus('REST-Endpoint ist keine gueltige URL.', 'error');
    return;
  }
  let anonKey = rawKey.startsWith('Bearer ') ? rawKey : `Bearer ${rawKey}`;
  if (isServiceRoleKey(anonKey)){
    setConfigStatus('service_role Schluessel sind nicht erlaubt.', 'error');
    return;
  }
  try {
    setConfigStatus('Speichere Konfiguration ...', 'info');
    await putConf('webhookUrl', rawRest);
    await putConf('webhookKey', anonKey);
    sbClient = null;
    await ensureSupabaseClient();
    await requireSession();
    setConfigStatus('Konfiguration gespeichert.', 'success');
  } catch (e){
    const message = restErrorMessage(e?.status || 0, e?.details || e?.message || '');
    setConfigStatus(message, 'error');
  }
});

if (gbtn) gbtn.addEventListener('click', async ()=>{
  const supa = await ensureSupabaseClient();
  if (!supa) {
    setConfigStatus('Konfiguration fehlt - bitte REST-Endpoint und ANON-Key speichern.', 'error');
    const adv = document.getElementById('configAdv');
    if (adv) adv.open = true;
    const restField = document.getElementById('configRestUrl');
    if (restField){
      restField.focus();
      restField.select?.();
    }
    return;
  }
  const { error } = await supa.auth.signInWithOAuth({
    provider: 'google',
    options: { redirectTo: `${window.location.origin}${window.location.pathname}` }
  });
  if (error) setConfigStatus('Google-Login fehlgeschlagen: ' + error.message, 'error');
});
}

// Beim Start Session pruefen
async function requireSession(){
if(!sbClient){
setUserUi('');
if (__authState !== 'unknown') {
  showLoginOverlay(true);
}
setAuthGuard(false);
setDoctorAccess(false);
__lastLoggedIn = false;
return false;
}
try{
const { data: { session } } = await sbClient.auth.getSession();
const logged = !!session;
__lastLoggedIn = logged;
setUserUi(session?.user?.email || '');
if (logged){
  __authState = 'auth';
  clearAuthGrace();
} else if (!__authGraceTimer){
  __authState = 'unauth';
}
applyAuthUi(logged);
return logged;
}catch(_){
return false;
}
}

// Reagiert auch auf spaetere Logins (z. B. nach Redirect)
function watchAuthState(){
  sbClient.auth.onAuthStateChange(async (event, session)=>{
    const logged = !!session;
    if (logged) {
      setUserUi(session?.user?.email || '');
      finalizeAuthState(true);
      await afterLoginBoot();
      await setupRealtime();
      await requestUiRefresh();
      await refreshCaptureIntake();
      await refreshAppointments();
      return;
    }

    setUserUi('');
    __lastLoggedIn = false;
    __pendingSignOut = async () => {
      teardownRealtime();
      await refreshCaptureIntake();
      await refreshAppointments();
    };

    if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {
      finalizeAuthState(false);
    } else {
      scheduleAuthGrace();
    }
  });
}

// Alles, was NACH Login laufen soll (deine bestehende Logik)
let __booted = false; // ganz oben im Script oder vor afterLoginBoot definieren

async function afterLoginBoot(){
  if (__booted) return;
  __booted = true;
  // Keine Auto-Sync/Realtime bis Arzt-Ansicht umgestellt ist
  await requestUiRefresh({ reason: 'boot:afterLogin' });
}

/* ===== CSV/JSON export (Daily) ===== */
function dl(filename, content, mime){
const a = document.createElement("a");
a.href = URL.createObjectURL(new Blob([content], {type:mime}));
a.download = filename;
a.click();
URL.revokeObjectURL(a.href);
}

/* ===== Doctor view ===== */
function setDocBadges({ training, bad, visible } = {}) {
  const t = document.getElementById('docTrainCnt');
  const b = document.getElementById('docBadCnt');
  if (!t || !b) return;

  if (training !== undefined) t.querySelector('.val').textContent = String(training);
  if (bad !== undefined)      b.querySelector('.val').textContent = String(bad);

  if (visible !== undefined) {
    t.classList.toggle('hidden', !visible);
    b.classList.toggle('hidden', !visible);
  }
}

const __t0 = performance.now();
async function renderDoctor(){
  const host = $("#doctorView");
  if (!host) return;

  if (!(await isLoggedIn())){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte anmelden, um die Arzt-Ansicht zu sehen.</div>`;
    setDocBadges({ visible: false });
    return;
  }
  // Nur sperren, wenn die Arzt-Ansicht wirklich aktiv angezeigt wird
  const doctorSection = document.getElementById('doctor');
  const isActive = !!doctorSection && doctorSection.classList.contains('active');
  if (!__doctorUnlocked){
    if (isActive){
      host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte Arzt-Ansicht kurz entsperren.</div>`;
      setDocBadges({ visible: false });
      try { await requireDoctorUnlock(); } catch(_) {}
      if (!__doctorUnlocked) return;
    } else {
      return;
    }
  }
  host.innerHTML = "";

  // Anzeige-Helper
  const dash = v => (v === null || v === undefined || v === "" ? "-" : String(v));
  const onClass = b => (b ? "on" : "");
  const fmtDateDE = (iso) => {
    const d = new Date(iso + "T00:00:00Z");
    return d.toLocaleDateString("de-AT", { weekday:"short", day:"2-digit", month:"2-digit", year:"numeric" });
  };

  // Zeitraum lesen
  const from = $("#from").value;
  const to   = $("#to").value;
  if (!from || !to){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte Zeitraum waehlen.</div>`;
    setDocBadges({ visible: false });
    return;
  }

  //  Server lesen  Tagesobjekte
  let daysArr = [];
  try{
    daysArr = await fetchDailyOverview(from, to);
  }catch(_){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Fehler beim Laden aus der Cloud.</div>`;
    setDocBadges({ visible: false });
    return;
  }

  // KPIs
  const trainingDays = daysArr.filter(d => !!d.flags.training).length;
  const badDays = daysArr.filter(d => {
    const f = d.flags;
    return !!(f.water_lt2 || f.salt_gt5 || f.protein_ge90 || f.sick || f.meds);
  }).length;
  setDocBadges({ training: trainingDays, bad: badDays, visible: true });

  // Renderer je Tag
  const renderDoctorDay = (day) => `
<section class="doctor-day" data-date="${day.date}">
  <div class="col-date">
    <div class="date-top">
      <span class="date-label">${fmtDateDE(day.date)}</span>
      <span class="date-cloud" title="In Cloud gespeichert?">${day.hasCloud ? "&#9729;&#65039;" : ""}</span>
    </div>
    <div class="date-actions">
      <button class="btn ghost btn-xs" data-del-day="${day.date}">Loeschen</button>
    </div>
  </div>

  <div class="col-measure">
    <div class="measure-head">
      <div></div>
      <div>Sys</div><div>Dia</div><div>Puls</div><div>MAP</div>
    </div>
    <div class="measure-grid">
      <div class="measure-row">
        <div class="label">morgens</div>
        <div class="num ${ (day.morning.sys!=null && day.morning.sys>130) ? 'alert' : '' }">${dash(day.morning.sys)}</div>
        <div class="num ${ (day.morning.dia!=null && day.morning.dia>90)  ? 'alert' : '' }">${dash(day.morning.dia)}</div>
        <div class="num">${dash(day.morning.pulse)}</div>
        <div class="num ${ (day.morning.map!=null && day.morning.map>100) ? 'alert' : '' }">${dash(fmtNum(day.morning.map))}</div>
      </div>
      <div class="measure-row">
        <div class="label">abends</div>
        <div class="num ${ (day.evening.sys!=null && day.evening.sys>130) ? 'alert' : '' }">${dash(day.evening.sys)}</div>
        <div class="num ${ (day.evening.dia!=null && day.evening.dia>90)  ? 'alert' : '' }">${dash(day.evening.dia)}</div>
        <div class="num">${dash(day.evening.pulse)}</div>
        <div class="num ${ (day.evening.map!=null && day.evening.map>100) ? 'alert' : '' }">${dash(fmtNum(day.evening.map))}</div>
      </div>
    </div>
  </div>

  <div class="col-special">
    <div class="weight-line">
      <div>Gewicht</div>
      <div class="num">${dash(fmtNum(day.weight))}</div>
    </div>

    <div class="waist-line">
      <div>Bauchumfang (cm)</div>
      <div class="num">${dash(fmtNum(day.waist_cm))}</div>
    </div>

    <div class="flags">
      <div class="flag"><span class="flag-box ${onClass(day.flags.water_lt2)}"></span><span>&lt;2L Wasser</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.salt_gt5)}"></span><span>Salz &gt;5g</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.protein_ge90)}"></span><span>Protein &ge; 90 g</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.sick)}"></span><span>Krank</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.meds)}"></span><span>Medikamente</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.training)}"></span><span>Training</span></div>
    </div>

    <div class="notes">${nl2br((day.notes || "").trim() || "-")}</div>
  </div>
</section>
`;

  // Rendern / Leerzustand
  if (!daysArr.length){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Keine Eintraege im Zeitraum</div>`;
  } else {
    host.innerHTML = daysArr.map(renderDoctorDay).join("");

    //  Loeschen: alle Server-Events des Tages entfernen
    host.querySelectorAll('[data-del-day]').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const date = btn.getAttribute('data-del-day');
        if (!date) return;
        if (!confirm(`Alle Eintraege in der Cloud fuer ${date} loeschen?`)) return;

        btn.disabled = true;
        const old = btn.textContent;
        btn.textContent = 'Loesche...';
        try{
          const r = await deleteRemoteDay(date);
          if (!r.ok){
            alert(`Server-Loeschung fehlgeschlagen (${r.status||"?"}).`);
          }
          await requestUiRefresh({ reason: 'doctor:delete' });
        } finally {
          btn.disabled = false; btn.textContent = old;
        }
      });
    });
  }
}

/* ===== Simple SVG Chart (Daily) - final, ohne Doppel-Helper & mit WHO-Ampel ===== */

/* Fallbacks nur, wenn extern nicht verfuegbar */
const safeEnsureSupabaseClient = async () => {
  try { if (typeof ensureSupabaseClient === "function") return await ensureSupabaseClient(); } catch(_) {}
  return null;
};
const safeGetConf = async (k) => {
  try { if (typeof getConf === "function") return await getConf(k); } catch(_) {}
  return null;
};

const chartPanel = {
  el: null,
  svg: null,
  legend: null,
  open: false,
  tip: null,
  tipSticky: false,
  SHOW_BODY_COMP_BARS: true,

  init() {
    this.el = $("#chart");
    this.svg = $("#chartSvg");
    this.legend = $("#chartLegend");

    // Panel initial nicht anzeigen
    if (this.el) this.el.style.display = "none";

    // Close + Metric-Select
    const closeBtn = $("#chartClose");
    if (closeBtn) closeBtn.addEventListener("click", () => this.hide());
    const metricSel = $("#metricSel");
    if (metricSel) metricSel.addEventListener("change", () => this.draw());

    // Tooltip (hover/click)
    const contentHost = this.el?.querySelector(".content") || this.el || document.body;
    const tip = document.createElement("div");
    Object.assign(tip.style, {
      position: "absolute",
      inset: "auto auto auto auto",
      transform: "translate(8px,8px)",
      display: "none",
      pointerEvents: "none",
      zIndex: 2,
      background: "rgba(16,19,26,.98)",
      border: "1px solid rgba(60,68,90,.6)",
      borderRadius: "8px",
      padding: "8px 10px",
      fontSize: "12px",
      lineHeight: "1.35",
      maxWidth: "280px",
      boxShadow: "0 6px 18px rgba(0,0,0,.35)",
      color: "var(--fg)",
      textShadow: "0 1px 1px rgba(0,0,0,.35)",
    });
    tip.id = "chartTip";
    contentHost.style.position = "relative";
    contentHost.appendChild(tip);
    this.tip = tip;

    // ARIA Live-Region (nur Text, fuer Screenreader)
    const live = document.createElement("div");
    live.id = "chartAria";
    live.setAttribute("aria-live", "polite");
    live.setAttribute("role", "status");
    Object.assign(live.style, {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: 0,
      border: 0,
      margin: "-1px",
      clip: "rect(0 0 0 0)",
      overflow: "hidden",
      whiteSpace: "nowrap",
    });
    contentHost.appendChild(live);
    this.live = live;

    // Interaktivitaet
    if (this.svg) {
      this.svg.addEventListener("pointermove", (e) => {
        if (this.tipSticky) return;
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("flag-hit"));
        if (!(isPt || isHit)) { this.hideTip(); return; }
        const date = tgt.getAttribute("data-date") || "";
        const hasNote = !!(tgt.getAttribute("data-note"));
        const hasFlags = this.hasFlagsForDate?.(date);
        if (!(hasNote || hasFlags)) { this.hideTip(); return; }
        this.fillTipFromTarget(tgt);
        this.positionTip(e);
      });

      this.svg.addEventListener("pointerleave", () => {
        if (this.tipSticky) return;
        this.hideTip();
      });

      // Click/Tap: Tooltip toggeln (mobil-freundlich)
      this.svg.addEventListener("click", (e) => {
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("flag-hit"));
        if (!(isPt || isHit)) { if (this.tipSticky) { this.tipSticky = false; this.hideTip(); } return; }
        const date = tgt.getAttribute("data-date") || "";
        const hasNote = !!(tgt.getAttribute("data-note"));
        const hasFlags = this.hasFlagsForDate?.(date);
        if (!(hasNote || hasFlags)) { if (this.tipSticky) { this.tipSticky = false; this.hideTip(); } return; }
        this.fillTipFromTarget(tgt);
        this.tipSticky = !this.tipSticky;
        this.positionTip(e);
      });

      // Keyboard: Enter/Space toggelt Tooltip, ESC schliesst
      this.svg.addEventListener("keydown", (e) => {
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("flag-hit"));
        if (!(isPt || isHit)) return;
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          const date = tgt.getAttribute("data-date") || "";
          const hasNote = !!(tgt.getAttribute("data-note"));
          const hasFlags = this.hasFlagsForDate?.(date);
          if (!(hasNote || hasFlags)) return;
          this.fillTipFromTarget(tgt);
          this.tipSticky = !this.tipSticky;
        } else if (e.key === "Escape") {
          this.tipSticky = false; this.hideTip();
        }
      });
    }

    // Redraw bei Resize/Orientation
    if (this.el) {
      const ro = new ResizeObserver(() => { if (this.open) this.draw(); });
      ro.observe(this.el);
      this._ro = ro;
    }
    window.addEventListener("orientationchange", () => {
      setTimeout(() => { if (this.open) this.draw(); }, 150);
    });

    // KPI-Box: Felder sicherstellen
    this.ensureKpiFields();
  },

  toggle() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
    }
  },

  show() {
    this.open = true;
    if (this.el) {
      this.el.style.display = "block";
      focusTrap.activate(this.el);
    }
  },

  hide() {
    this.open = false;
    if (this.el) {
      this.el.style.display = "none";
      focusTrap.deactivate();
    }
    this.tipSticky = false;
    this.hideTip();
  },

  // ----- Helpers -----
async getFiltered() {
  const from = $("#from")?.value;
  const to   = $("#to")?.value;

  // Wenn eingeloggt: Cloud nehmen (Events -> Daily), sonst fallback: lokale Entries
  if (await isLoggedIn()) {
    // gleiche Aggregation wie Arzt-Ansicht
    const days = await fetchDailyOverview(from, to);
    // Fuer die Chart-Logik bauen wir flache "entry"-aehnliche Objekte
    const flat = [];
    for (const d of days) {
      // Morgen
      if (d.morning.sys != null || d.morning.dia != null || d.morning.pulse != null) {
        const ts = Date.parse(d.date + "T07:00:00Z"); // Fix-Zeit am Tag
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Morgen",
          sys: d.morning.sys,
          dia: d.morning.dia,
          pulse: d.morning.pulse,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90,
          fat_kg: null,
          muscle_kg: null
        });
      }
      // Abend
      if (d.evening.sys != null || d.evening.dia != null || d.evening.pulse != null) {
        const ts = Date.parse(d.date + "T19:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Abend",
          sys: d.evening.sys,
          dia: d.evening.dia,
          pulse: d.evening.pulse,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90,
          fat_kg: null,
          muscle_kg: null
        });
      }
      // Body (Gewicht/Bauch)
      if (d.weight != null || d.waist_cm != null) {
        const ts = Date.parse(d.date + "T12:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Tag",
          sys: null, dia: null, pulse: null,
          weight: d.weight,
          waist_cm: d.waist_cm,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90,
          fat_kg: d.fat_kg,
          muscle_kg: d.muscle_kg
        });
      }
    }
    // Ergaenze Tage mit ausschliesslich Flags (ohne BP/Body), damit Flags-Overlay immer angezeigt wird
    for (const d of days) {
      const hasFlags = !!(d?.flags?.training || d?.flags?.sick || d?.flags?.water_lt2 || d?.flags?.salt_gt5 || d?.flags?.protein_ge90 || d?.flags?.meds);
      if (!hasFlags) continue;
      const already = flat.some(e => e?.date === d.date);
      if (!already) {
        const ts = Date.parse(d.date + "T12:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Tag",
          sys: null, dia: null, pulse: null,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90,
          fat_kg: null,
          muscle_kg: null
        });
      }
    }
    return flat.sort((a,b) => (a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime)));
  }

  // Fallback: lokal (wenn nicht eingeloggt)
  const entries = typeof getAllEntries === "function" ? await getAllEntries() : [];
  return entries
    .filter(e => {
      if (from && e.date < from) return false;
      if (to   && e.date > to)   return false;
      return true;
  })
    .sort((a,b) => (a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime)));
},

  // Hoehe laden (Konfig oder Fallback 183 cm)
  async getHeightCm() {
    // 1) Supabase-Profil
    const supa = await safeEnsureSupabaseClient();
    if (supa) {
      try {
        const { data, error } = await supa.from("user_profile").select("height_cm").single();
        if (!error && data?.height_cm) return Number(data.height_cm);
      } catch(_) {}
    }
    // 2) lokale Konfig
    const v = await safeGetConf("height_cm");
    const n = Number(v);
    if (Number.isFinite(n) && n > 0) return n;
    return 183;
  },

  // Tooltip
  hideTip() {
    if (this.tip) {
      this.tip.style.display = "none";
      this.tip.textContent = "";
    }
  },
  positionTip(e) {
    if (!this.tip || !this.el) return;
    const hostRect = (this.el.querySelector(".content") || this.el).getBoundingClientRect();
    const x = e.clientX - hostRect.left;
    const y = e.clientY - hostRect.top;
    this.tip.style.left = `${x + 10}px`;
    this.tip.style.top  = `${y + 10}px`;
    if (this.tip.style.display !== "block") this.tip.style.display = "block";
  },
  fillTipFromTarget(tgt) {
    if (!this.tip) return;
    const note = tgt.getAttribute("data-note") || "";
    const date = tgt.getAttribute("data-date") || "";
    const ctx  = tgt.getAttribute("data-ctx")  || "";
    const flags = (typeof this.flagsByDate?.get === 'function') ? this.flagsByDate.get(date) : null;
    const items = [];
    if (flags) {
      if (flags.training)         items.push("Training");
      if (flags.sick)             items.push("Krank");
      if (flags.low_intake)       items.push("< 2 L Wasser");
      if (flags.salt_high)        items.push("> 5 g Salz");
      if (flags.protein_high90)   items.push("Protein  90 g");
      if (flags.valsartan_missed) items.push("Valsartan vergessen");
      if (flags.forxiga_missed)   items.push("Forxiga vergessen");
      if (flags.nsar_taken)       items.push("NSAR genommen");
      if (!flags.valsartan_missed && !flags.forxiga_missed && !flags.nsar_taken && flags.meds) items.push("Medikamente");
    }

    const parts = [];
    const hdr = (date || ctx) ? `<div style="opacity:.85;margin-bottom:4px">${esc([date, ctx].filter(Boolean).join(" . "))}</div>` : "";
    if (hdr) parts.push(hdr);
    if (note) parts.push(`<div style="white-space:pre-wrap;margin-bottom:${items.length? '6' : '0'}px">${esc(note)}</div>`);
    if (items.length) {
      const lis = items.map(esc).map(t => `<li>${t}</li>`).join("");
      parts.push(`<div style="margin-top:${note? '0' : '2'}px"><strong>Flags:</strong><ul style="margin:4px 0 0 16px; padding:0">${lis}</ul></div>`);
    }
    if (!parts.length) { this.hideTip(); return; }
    this.tip.innerHTML = parts.join("");
    if (this.live) this.live.textContent = `${date || ''} ${ctx || ''} ${note ? 'Notiz vorhanden. ' : ''}${items.length ? 'Flags: ' + items.join(', ') : ''}`.trim();
  },

  /* ---------- KPI-Felder + WHO-Ampellogik ---------- */
  ensureKpiFields() {
    const box = $("#chartAverages");
    if (!box) return;
    const need = [
      { k: "sys",  label: "Durchschnitt Sys: -" },
      { k: "dia",  label: "Durchschnitt Dia: -" },
      { k: "map",  label: "Durchschnitt MAP: -" },
      { k: "bmi",  label: "BMI (letzter): -" },
      { k: "whtr", label: "WHtR (letzter): -" },
    ];
    need.forEach((n) => {
      if (!box.querySelector(`[data-k="${n.k}"]`)) {
        const span = document.createElement("span");
        span.setAttribute("data-k", n.k);
        span.textContent = n.label;
        box.appendChild(span);
      }
    });
  },

  // WHO-Farben
  kpiColorBMI(v) {
    if (v == null) return "#9aa3af";        // unknown
    if (v < 18.5) return "#60a5fa";         // untergew.
    if (v < 25)   return "#10b981";         // normal
    if (v < 30)   return "#f59e0b";         // uebergew.
    return "#ef4444";                        // adipoes
  },
  kpiColorWHtR(v) {
    if (v == null) return "#9aa3af";
    if (v < 0.5)   return "#10b981";        // ok
    if (v <= 0.6)  return "#f59e0b";        // erhoeht
    return "#ef4444";                        // hoch
  },

  // Ein Punkt pro KPI, korrekt eingefaerbt; saubere Separatoren
  layoutKpis() {
    const box = $("#chartAverages");
    if (!box) return;

    // 1) Alle alten Deko-Elemente entfernen (auch statische .sep aus dem HTML!)
    [...box.querySelectorAll(".kpi-dot, .kpi-sep, .sep")].forEach(n => n.remove());

    // 2) Sichtbare KPI-Spans ermitteln (display != "none")
    const items = [...box.querySelectorAll('[data-k]')].filter(el => el.style.display !== "none");

    // 3) Pro Item farbigen Punkt einsetzen + exakt einen Separator zwischen Items
    const makeDot = (color) => {
      const d = document.createElement("span");
      d.className = "kpi-dot";
      Object.assign(d.style, {
        display: "inline-block",
        width: "9px", height: "9px",
        borderRadius: "50%",
        margin: "0 8px 0 12px",
        background: color,
        verticalAlign: "middle",
        boxShadow: "0 0 4px rgba(0,0,0,.35)"
      });
      return d;
    };
    const makeSep = () => {
      const s = document.createElement("span");
      s.className = "kpi-sep";
      s.textContent = "*";
      Object.assign(s.style, {
        color: "#6b7280",
        margin: "0 10px",
        userSelect: "none"
      });
      return s;
    };

    items.forEach((el, idx) => {
      let color = "#9aa3af";
      const k = el.getAttribute("data-k");

      // Wert aus Text extrahieren (erste Zahl im Text)
      const m = el.textContent.match(/([\d.]+)/);
      const v = m ? parseFloat(m[1]) : null;

      if (k === "bmi") {
        color = this.kpiColorBMI(Number.isFinite(v) ? v : null);
      } else if (k === "whtr") {
        color = this.kpiColorWHtR(Number.isFinite(v) ? v : null);
      } else {
        // BP-KPIs neutral blau
        color = "#60a5fa";
      }

      el.before(makeDot(color));
      if (idx < items.length - 1) el.after(makeSep());
    });

    box.style.display = items.length ? "inline-flex" : "none";
    box.style.alignItems = "center";
  },

  // ----- Zeichnen -----
  async draw() {
    const t0 = performance.now?.() ?? Date.now();
if (!(await isLoggedIn())) {
  if (this.svg) this.svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Bitte anmelden</text>';
  if (this.legend) this.legend.innerHTML = "";
  return;
}
const metric = $("#metricSel")?.value || "bp";

    const data   = await this.getFiltered();

    // X-Basis
    const xsAll = data.map(e => e.ts ?? Date.parse(e.dateTime));
    let series = [];
    let barSeries = [];
    let X = xsAll;

    // KPI-Box
    const avgBox = $("#chartAverages");

    // Schwellen (nur BP)
    const TH_SYS = 130;
    const TH_DIA = 90;

    // Tagesstempel (UTC, 00:00)
    const toDayTs = (isoDate /* "YYYY-MM-DD" */) => {
      if (!isoDate) return NaN;
      const [y, m, d] = isoDate.split("-").map(Number);
      return Date.UTC(y, (m || 1) - 1, d || 1);
    };

    // Tageskommentare (erste Zeile)
    const notesByDate = new Map();
    for (const e of data) {
      const hasDayLike = e?.context === "Tag" || isWeightOnly(e);
      const txt = (e?.notes || "").trim();
      if (hasDayLike && txt) {
        const firstLine = txt.split(/\r?\n/)[0].trim();
        if (firstLine) notesByDate.set(e.date, firstLine);
      }
    }

    // Fuer BP benoetigen wir Meta je Punkt
    let meta = null;

    if (metric === "bp") {
      // Nur echte Messungen
      const mData = data.filter(
        e => (e.context === "Morgen" || e.context === "Abend") && (e.sys != null || e.dia != null)
      );

      // Meta
      meta = mData.map(e => ({
        date: e.date,
        ctx:  e.context,
        sys:  e.sys != null ? Number(e.sys) : null,
        dia:  e.dia != null ? Number(e.dia) : null,
        note: notesByDate.get(e.date) || "",
      }));

      // X auf Tage normalisieren
      const xsBP = mData.map(e => toDayTs(e.date));

      // Werte-Reihen (Index passend zu meta)
      const sysM = mData.map(e => (e.context === "Morgen" && e.sys != null) ? Number(e.sys) : null);
      const sysA = mData.map(e => (e.context === "Abend"  && e.sys != null) ? Number(e.sys) : null);
      const diaM = mData.map(e => (e.context === "Morgen" && e.dia != null) ? Number(e.dia) : null);
      const diaA = mData.map(e => (e.context === "Abend"  && e.dia != null) ? Number(e.dia) : null);

      // KPIs ( ueber alle Messungen)
      const avg = (arr) => {
        const v = arr.filter(x => x != null);
        return v.length ? v.reduce((p,c) => p + c, 0) / v.length : null;
      };
      const mapArr = mData.map(e =>
        e.sys != null && e.dia != null
          ? Number(e.dia) + (Number(e.sys) - Number(e.dia)) / 3
          : null
      );

      if (avgBox) {
        const avgSys = avg(mData.map(e => (e.sys != null ? Number(e.sys) : null)));
        const avgDia = avg(mData.map(e => (e.dia != null ? Number(e.dia) : null)));
        const avgMap = avg(mapArr);

        const f0 = (v) => (v == null ? "-" : Math.round(v).toString());

        // Zeige BP-KPIs, blende BMI/WHtR aus
        const sEl  = avgBox.querySelector('[data-k="sys"]');
        const dEl  = avgBox.querySelector('[data-k="dia"]');
        const mEl  = avgBox.querySelector('[data-k="map"]');
        const bmiEl  = avgBox.querySelector('[data-k="bmi"]');
        const whtrEl = avgBox.querySelector('[data-k="whtr"]');
        if (sEl)  { sEl.style.display  = ""; sEl.textContent  = "Durchschnitt Sys: " + f0(avgSys); }
        if (dEl)  { dEl.style.display  = ""; dEl.textContent  = "Durchschnitt Dia: " + f0(avgDia); }
        if (mEl)  { mEl.style.display  = ""; mEl.textContent  = "Durchschnitt MAP: " + f0(avgMap); }
        if (bmiEl)  bmiEl.style.display  = "none";
        if (whtrEl) whtrEl.style.display = "none";

        avgBox.style.display = (avgSys != null || avgDia != null || avgMap != null) ? "inline-flex" : "none";
        this.layoutKpis();
      }

      // Serien definieren
      series = [
        { name: "Sys Morgens", values: sysM, color: "#93c5fd", type: "sys" },
        { name: "Sys Abends",  values: sysA, color: "#2563eb", type: "sys" },
        { name: "Dia Morgens", values: diaM, color: "#f9a8d4", type: "dia" },
        { name: "Dia Abends",  values: diaA, color: "#db2777", type: "dia" },
      ];

      X = xsBP; // wichtig
} else if (metric === "weight") {
  // Serien: Gewicht + Bauchumfang
  series = [
    {
      name: "Gewicht (kg)",
      values: data.map(e => e.weight != null ? Number(e.weight) : null),
      color: "#f59e0b", // Amber
      type: "misc",
    },
    {
      name: "Bauchumfang (cm)",
      values: data.map(e => e.waist_cm != null ? Number(e.waist_cm) : null),
      color: "#10b981", // Gruen
      type: "misc",
    }
  ];

  // KPI-Leiste: BMI & WHtR aus dem LETZTEN verfuegbaren Wert
  if (avgBox) {
    // BP-KPIs ausblenden
    ["sys","dia","map"].forEach(k => {
      const el = avgBox.querySelector(`[data-k="${k}"]`);
      if (el) el.style.display = "none";
    });

    // letzten Weight/Bauchumfang finden (data ist aufsteigend sortiert)
    let lastWeight = null, lastWaist = null;
    for (let i = data.length - 1; i >= 0; i--) {
      if (lastWeight == null && data[i].weight   != null) lastWeight = Number(data[i].weight);
      if (lastWaist  == null && data[i].waist_cm != null) lastWaist  = Number(data[i].waist_cm);
      if (lastWeight != null && lastWaist != null) break;
    }

    const heightCm = await this.getHeightCm();
    const hM = heightCm > 0 ? heightCm / 100 : null;

    const bmi  = (lastWeight != null && hM)         ? lastWeight / (hM * hM) : null;
    const whtr = (lastWaist  != null && heightCm>0) ? lastWaist  / heightCm  : null;

    const bmiEl  = avgBox.querySelector('[data-k="bmi"]');
    const whtrEl = avgBox.querySelector('[data-k="whtr"]');

    if (bmiEl)  { bmiEl.textContent  = `BMI (letzter): ${bmi  == null ? "-" : bmi.toFixed(1)}`;  bmiEl.style.display  = ""; }
    if (whtrEl) { whtrEl.textContent = `WHtR (letzter): ${whtr == null ? "-" : whtr.toFixed(2)}`; whtrEl.style.display = ""; }

    avgBox.style.display = "inline-flex";
    this.layoutKpis();
  }

  const muscleKg = data.map(e => e.muscle_kg != null ? Number(e.muscle_kg) : null);
  const fatKg    = data.map(e => e.fat_kg    != null ? Number(e.fat_kg)    : null);
  barSeries = [
    { name: "Muskelmasse (kg)", values: muscleKg, color: "#4DA8FF" },
    { name: "Fettmasse (kg)",   values: fatKg,    color: "#D2A85F" },
  ];
}

  // --- Render-Prep ---
    if (this.svg) this.svg.innerHTML = "";
    if (this.legend) this.legend.innerHTML = "";
    if (!this.tipSticky) this.hideTip();

    // Wenn es Flags gibt, soll das Chart nicht fruehzeitig abbrechen
    const hasBarData = barSeries.some(s => s.values.some(v => v != null));
    const hasAnyFlagsData = (metric !== "weight") && Array.isArray(data) && data.some(e => !!(e?.training || e?.low_intake || e?.sick || e?.salt_high || e?.protein_high90 || e?.valsartan_missed || e?.forxiga_missed || e?.nsar_taken));
    const hasAny = series.some(s => s.values.some(v => v != null)) || hasBarData || hasAnyFlagsData;
    if (!hasAny) {
      if (this.svg) this.svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Keine darstellbaren Werte</text>';
      return;
    }

    // Dynamische Groesse
    const bbox = this.svg?.getBoundingClientRect?.() || { width: 640, height: 280 };
    const W = Math.max(300, Math.floor(bbox.width  || 640));
    const H = Math.max(200, Math.floor(bbox.height || 280));
    if (this.svg) this.svg.setAttribute("viewBox", `0 0 ${W} ${H}`);

    const PL = 48, PR = 16, PT = 12, PB = 28;
    const innerW = W - PL - PR, innerH = H - PT - PB;

    // === Flags -> X-Bereich erweitern (immer) + Lookup fuer Tooltip ===
    let flagTs = [];
    if (metric === "weight") {
      this.flagsByDate = new Map();
      this.hasFlagsForDate = () => false;
    } else {
      const dayFlagsTmp = new Map(); // date -> { training:bool, badCount:int, seen:{} }
      const flagsByDate = new Map(); // date -> detailed flags for tooltip
      for (const e of data) {
        if (!e?.date) continue;
        let rec = dayFlagsTmp.get(e.date);
        if (!rec) {
          rec = {
            training: false,
            badCount: 0,
            seen: { water:false, salt:false, protein:false, sick:false, meds:false },
          };
          dayFlagsTmp.set(e.date, rec);
        }
        if (e.training) rec.training = true;
        const meds = !!(e.valsartan_missed || e.forxiga_missed || e.nsar_taken);
        const flags = {
          water: !!e.low_intake,
          salt:  !!e.salt_high,
          protein: !!e.protein_high90,
          sick:  !!e.sick,
          meds,
        };
        for (const k of Object.keys(flags)) {
          if (flags[k] && !rec.seen[k]) { rec.seen[k] = true; rec.badCount++; }
        }

        // Tooltip-Detailflags sammeln
        let f = flagsByDate.get(e.date);
        if (!f) f = { training:false, sick:false, low_intake:false, salt_high:false, protein_high90:false, valsartan_missed:false, forxiga_missed:false, nsar_taken:false, meds:false };
        f.training = f.training || !!e.training;
        f.sick = f.sick || !!e.sick;
        f.low_intake = f.low_intake || !!e.low_intake;
        f.salt_high = f.salt_high || !!e.salt_high;
        f.protein_high90 = f.protein_high90 || !!e.protein_high90;
        f.valsartan_missed = f.valsartan_missed || !!e.valsartan_missed;
        f.forxiga_missed   = f.forxiga_missed   || !!e.forxiga_missed;
        f.nsar_taken       = f.nsar_taken       || !!e.nsar_taken;
        f.meds = f.meds || meds;
        flagsByDate.set(e.date, f);
      }
      flagTs = [...dayFlagsTmp.keys()].map(d => Date.parse(d + "T00:00:00Z"));
      this.flagsByDate = flagsByDate;
      this.hasFlagsForDate = (dayIso) => {
        if (!dayIso || !this.flagsByDate) return false;
        const f = this.flagsByDate.get(dayIso);
        if (!f) return false;
        return !!(f.training || f.sick || f.low_intake || f.salt_high || f.protein_high90 || f.valsartan_missed || f.forxiga_missed || f.nsar_taken || f.meds);
      };
    }

    // Skalen
    const xVals = X.filter(t => Number.isFinite(t));
    let xmin = Math.min(...xVals);
    let xmax = Math.max(...xVals);

    if (!Number.isFinite(xmin) || !Number.isFinite(xmax)) {
      // Fallback
      xmin = Date.now() - 7 * 864e5;
      xmax = Date.now();
    }

    // Union mit Flag-Tagen (immer)
    if (flagTs.length) {
      xmin = Math.min(xmin, Math.min(...flagTs));
      xmax = Math.max(xmax, Math.max(...flagTs));
    }

    // Padding (2%)
    const pad = xmax > xmin ? (xmax - xmin) * 0.02 : 0;
    xmin -= pad; xmax += pad;

    let allY = [
      ...series.flatMap(s => s.values.filter(v => v != null)),
      ...barSeries.flatMap(s => s.values.filter(v => v != null)),
    ];
    if (metric === "weight") allY.push(0);
    if (!allY.length) allY = [0];
    const yminRaw = Math.min(...allY);
    const ymaxRaw = Math.max(...allY);
    const range   = Math.max(1, ymaxRaw - yminRaw);
    const ypad    = Math.max(range * 0.08, 1);
    const y0 = yminRaw - ypad;
    const y1 = ymaxRaw + ypad;

    const x = (t) => PL + ((t - xmin) / Math.max(1, xmax - xmin)) * innerW;
    const y = (v) => PT + (1 - (v - y0) / Math.max(1, y1 - y0)) * innerH;

    const line = (x1,y1_,x2,y2,stroke,dash="") =>
      `<line x1="${x1}" y1="${y1_}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="1" ${dash ? `stroke-dasharray="${dash}"` : ""} />`;
    const text = (tx,ty,str,anchor="end") =>
      `<text x="${tx}" y="${ty}" fill="#9aa3af" font-size="11" text-anchor="${anchor}">${esc(str)}</text>`;

    // Grid + Labels
    let grid = "";
    const ticks = 9;
    for (let i=0; i<=ticks; i++) {
      const vv = y0 + (i * (y1 - y0)) / ticks;
      const yy = y(vv);
      grid += line(PL, yy, W-PR, yy, "#2a3140");
      grid += text(PL - 6, yy + 4, Math.round(vv).toString());
    }
    // vertikale Wochenlinien + Datum
    const week = 7 * 24 * 3600 * 1000;
    let start = xmin - (xmin % week) + week;
    for (let t = start; t < xmax; t += week) {
      const xx = x(t);
      grid += line(xx, PT, xx, H - PB, "#1b1f28", "3 3");
      const d = new Date(t);
      const lbl = `${String(d.getDate()).padStart(2,"0")}.${String(d.getMonth()+1).padStart(2,"0")}.`;
      grid += text(xx, H - 8, lbl, "middle");
    }
    // Achsen
    grid += line(PL, PT, PL, H - PB, "#2b2f3a");
    grid += line(PL, H - PB, W - PR, H - PB, "#2b2f3a");

    // Schwellenlinien (BP)
    if (metric === "bp") {
      const ySys = y(TH_SYS);
      const yDia = y(TH_DIA);
      grid += line(PL, ySys, W - PR, ySys, "#ef4444", "6 4");
      grid += line(PL, yDia, W - PR, yDia, "#ef4444", "6 4");
grid += text(W - PR - 2, ySys + 4, "Sys 130", "end");
grid += text(W - PR - 2, yDia  + 4, "Dia 90",  "end");
    }

    if (this.svg) this.svg.insertAdjacentHTML("beforeend", grid);

    // === Flags Overlay (nur fuer BP) ===
    if (this.svg && metric !== "weight") {
      const dayFlags = new Map(); // date -> { training:bool, badCount:int, seen:{} }
      for (const e of data) {
        if (!e?.date) continue;
        let rec = dayFlags.get(e.date);
        if (!rec) {
          rec = { training:false, badCount:0, seen:{ water:false, salt:false, protein:false, sick:false, meds:false } };
          dayFlags.set(e.date, rec);
        }
        if (e.training) rec.training = true;
        const meds = !!(e.valsartan_missed || e.forxiga_missed || e.nsar_taken);
        const flags = {
          water: !!e.low_intake, salt: !!e.salt_high, protein: !!e.protein_high90, sick: !!e.sick, meds
        };
        for (const k of Object.keys(flags)) {
          if (flags[k] && !rec.seen[k]) { rec.seen[k] = true; rec.badCount++; }
        }
      }

      const toDayTsLocal = (iso) => Date.parse(iso + "T00:00:00Z");
      const flaggedDays = [...dayFlags.keys()]
        .filter(d => {
          const r = dayFlags.get(d);
          return r && (r.training || r.badCount > 0);
        })
        .sort();

      if (flaggedDays.length) {
        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.setAttribute("class","flags");
        g.setAttribute("pointer-events","auto");
        g.setAttribute("aria-hidden","true");

        const uniqDays = [...new Set([...flaggedDays.map(d => toDayTsLocal(d)), ...X.filter(Boolean)])].sort((a,b)=>a-b);
        const dayXs = uniqDays.map(t => x(t));
        const minStep = dayXs.length > 1 ? Math.min(...dayXs.slice(1).map((v,i)=>v - dayXs[i])) : innerW;
        const bandW   = Math.max(10, Math.floor(minStep * 0.45));
        const yBottom = PT + innerH;
        const slotH   = innerH / 6; // 1 Training + bis zu 5 Bad

        for (const d of flaggedDays) {
          const t = toDayTsLocal(d);
          const cx = x(t), xLeft = Math.round(cx - bandW/2);
          const rec = dayFlags.get(d);
          let used = 0;

          // Training (gruen)
          if (rec.training) {
            const yTop = Math.round(yBottom - (used + 1) * slotH);
            const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
            r.setAttribute("x", xLeft); r.setAttribute("y", yTop);
            r.setAttribute("width", bandW); r.setAttribute("height", Math.ceil(slotH));
            r.setAttribute("fill", "#10b981"); r.setAttribute("fill-opacity","0.22");
            r.setAttribute("stroke", "#fff");  r.setAttribute("stroke-opacity","0.06");
            r.setAttribute("shape-rendering","crispEdges");
            g.appendChild(r);
            used++;
          }
          // Bad-Flags (rot gestapelt)
          for (let i=0; i<rec.badCount; i++) {
            const yTop = Math.round(yBottom - (used + 1) * slotH);
            const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
            r.setAttribute("x", xLeft); r.setAttribute("y", yTop);
            r.setAttribute("width", bandW); r.setAttribute("height", Math.ceil(slotH));
            r.setAttribute("fill", "#ef4444"); r.setAttribute("fill-opacity","0.18");
            r.setAttribute("stroke", "#fff");  r.setAttribute("stroke-opacity","0.06");
            r.setAttribute("shape-rendering","crispEdges");
            g.appendChild(r);
            used++;
          }

          // Interaktiver Hit-Bereich pro Tag ueber alle Slots
          const totalSlots = used;
          if (totalSlots > 0) {
            const yTopAll = Math.round(yBottom - totalSlots * slotH);
            const hit = document.createElementNS("http://www.w3.org/2000/svg","rect");
            hit.setAttribute("x", xLeft); hit.setAttribute("y", yTopAll);
            hit.setAttribute("width", bandW); hit.setAttribute("height", Math.ceil(totalSlots * slotH));
            hit.setAttribute("fill", "transparent");
            hit.setAttribute("pointer-events", "all");
            hit.setAttribute("class", "flag-hit");
            hit.setAttribute("data-date", d);
            hit.setAttribute("role", "button");
            hit.setAttribute("tabindex", "0");
            // ARIA-Label aus Flags ableiten
            try {
              const f = this.flagsByDate?.get?.(d);
              if (f) {
                const items = [];
                if (f.training) items.push("Training");
                if (f.sick) items.push("Krank");
                if (f.low_intake) items.push("< 2 L Wasser");
                if (f.salt_high) items.push("> 5 g Salz");
                if (f.protein_high90) items.push("Protein  90 g");
                if (f.valsartan_missed) items.push("Valsartan vergessen");
                if (f.forxiga_missed) items.push("Forxiga vergessen");
                if (f.nsar_taken) items.push("NSAR genommen");
                if (!f.valsartan_missed && !f.forxiga_missed && !f.nsar_taken && f.meds) items.push("Medikamente");
                if (items.length) hit.setAttribute("aria-label", `Flags: ${items.join(", ")}`);
              }
            } catch(_){}
            g.appendChild(hit);
          }
        }
        this.svg.appendChild(g); // hinter den Linien/Punkten
      }
    }

    // Koerper: Kompositionsbalken (Muskel/Fett) als hinterer Layer
    if (metric === "weight" && this.SHOW_BODY_COMP_BARS && this.svg) {
      const baseline = y(0);
      const muscleSeries = barSeries[0] || { values: [] };
      const fatSeries    = barSeries[1] || { values: [] };
      const entries = data.map((entry, idx) => {
        const ts = X[idx];
        if (!Number.isFinite(ts)) return null;
        const muscle = muscleSeries.values[idx];
        const fat = fatSeries.values[idx];
        if (muscle == null && fat == null) return null;
        return { ts, muscle, fat };
      }).filter(Boolean);

      if (entries.length) {
        const uniqTs = [...new Set(entries.map(e => e.ts))].sort((a,b)=>a-b);
        const dayXs = uniqTs.map(t => x(t));
        const baseStep = dayXs.length > 1
          ? Math.min(...dayXs.slice(1).map((v,i) => v - dayXs[i]))
          : innerW / Math.max(1, uniqTs.length);
        const groupWidth = Math.max(12, Math.min(36, Math.floor(baseStep * 0.5)));
        const gap = Math.max(2, Math.floor(groupWidth * 0.12));
        const barWidth = Math.max(4, Math.floor((groupWidth - gap) / 2));

        if (barWidth > 0 && Number.isFinite(baseline)) {
          let barsSvg = '<g class="body-bars" aria-hidden="true">';
          for (const { ts, muscle, fat } of entries) {
            const center = x(ts);
            const start = center - groupWidth / 2;
            const hasMuscle = muscle != null;
            const hasFat = fat != null;
            let muscleX = start;
            let fatX = start + barWidth + gap;
            if (hasMuscle && !hasFat) {
              muscleX = center - barWidth / 2;
            }
            if (!hasMuscle && hasFat) {
              fatX = center - barWidth / 2;
            }

            if (hasMuscle) {
              const yVal = y(muscle);
              const h = Math.abs(baseline - yVal);
              if (Number.isFinite(yVal) && h > 0.5) {
                const top = Math.min(baseline, yVal);
                barsSvg += `<rect x="${muscleX.toFixed(1)}" y="${top.toFixed(1)}" width="${barWidth}" height="${h.toFixed(1)}" fill="#4DA8FF" fill-opacity="0.55" stroke="none" pointer-events="none" />`;
              }
            }

            if (hasFat) {
              const yVal = y(fat);
              const h = Math.abs(baseline - yVal);
              if (Number.isFinite(yVal) && h > 0.5) {
                const top = Math.min(baseline, yVal);
                barsSvg += `<rect x="${fatX.toFixed(1)}" y="${top.toFixed(1)}" width="${barWidth}" height="${h.toFixed(1)}" fill="#D2A85F" fill-opacity="0.55" stroke="none" pointer-events="none" />`;
              }
            }
          }
          barsSvg += '</g>';
          this.svg.insertAdjacentHTML("beforeend", barsSvg);
        }
      }
    }

    // Linien + Punkte
const isFiniteTs = (t) => Number.isFinite(t);

const mkPath = (values, color) => {
  let d = "";
  values.forEach((v,i) => {
    if (v == null || !isFiniteTs(X[i])) return; // statt !X[i]
    d += (d === "" ? "M" : "L") + `${x(X[i]).toFixed(1)},${y(v).toFixed(1)} `;
  });
  return `<path d="${d}" fill="none" stroke="${color}" stroke-width="2.2" pointer-events="none" />`;
};

const mkDots = (values, color, kind) => {
  let out = "";
  values.forEach((v, i) => {
    if (v == null || !Number.isFinite(X[i])) return;
    const cx = x(X[i]).toFixed(1);
    const cy = y(v).toFixed(1);

    // Tooltip-Infos (nur bei BP vorhanden)
    const m = (kind === "sys" || kind === "dia") ? (meta?.[i] || {}) : {};
    const date = (m.date || (data?.[i]?.date || ""));
    const ctx  = (m.ctx  || (kind === "misc" ? "Tag" : ""));
    const note = (m.note || "");
    const labelBase = (kind === "sys" || kind === "dia") ? `${kind.toUpperCase()} ${v}` : `${v}`;
    const aria = `${date} ${ctx} ${labelBase}`.trim();

    out += `<circle class="pt" cx="${cx}" cy="${cy}" r="2.6" fill="${color}"
                data-kind="${esc(kind)}" data-val="${v}"
                data-date="${esc(date)}" data-ctx="${esc(ctx)}"
               data-note="${esc(note)}" tabindex="0" role="button" aria-label="${esc(aria)}" title="${esc(aria)}"
               stroke="rgba(0,0,0,0)" stroke-width="12" pointer-events="stroke" />`;
  });
  return out;
};

const mkAlertDots = (seriesItem) => {
  if (metric !== "bp") return "";
  const isSys = seriesItem.type === "sys";
  const thr   = isSys ? TH_SYS : TH_DIA;
  const kind  = isSys ? "sys" : "dia";
  let out = "";
  seriesItem.values.forEach((v, i) => {
    if (v == null || !isFiniteTs(X[i])) return;
    if (v > thr) {
      const cx = x(X[i]).toFixed(1), cy = y(v).toFixed(1);
      const m = meta?.[i] || {};
      out += `<circle class="pt" cx="${cx}" cy="${cy}" r="5.2" fill="#ef4444" stroke="#000" stroke-width="0.8"
               data-kind="${kind}" data-val="${v}"
               data-date="${esc(m.date || "")}" data-ctx="${esc(m.ctx || "")}"
               data-note="${esc(m.note || "")}" />`;
    }
  });
  return out;
};

    // Zeichnen
    series.forEach((s) => {
      if (!this.svg) return;
      this.svg.insertAdjacentHTML("beforeend", mkPath(s.values, s.color));
      this.svg.insertAdjacentHTML(
        "beforeend",
        mkDots(s.values, s.color, (s.type === "sys" || s.type === "dia") ? s.type : "misc")
      );
      if (metric === "bp") {
        this.svg.insertAdjacentHTML("beforeend", mkAlertDots(s));
      }
      // Legende
      if (this.legend) {
        const wrap = document.createElement("span");
        wrap.style.display = "inline-flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        const dot = Object.assign(document.createElement("span"), { className: "dot" });
        dot.style.background = s.color;
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        const label = document.createElement("span");
        label.textContent = s.name;
        wrap.append(dot, label);
        this.legend.appendChild(wrap);
      }
    });

    if (metric === "weight" && this.legend) {
      barSeries.forEach((s) => {
        if (!s.values.some(v => v != null)) return;
        const wrap = document.createElement("span");
        wrap.style.display = "inline-flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        const dot = Object.assign(document.createElement("span"), { className: "dot" });
        dot.style.background = s.color;
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        const label = document.createElement("span");
        label.textContent = s.name;
        wrap.append(dot, label);
        this.legend.appendChild(wrap);
      });
    }

    if (this.tipSticky) { this.tipSticky = false; this.hideTip(); }

    const sPerf = (perfStats.add?.("drawChart", (performance.now?.() ?? Date.now()) - t0), perfStats.snap?.("drawChart")) || {p50:0,p90:0,p95:0,p99:0,count:0};
    if (sPerf && typeof sPerf.count === 'number' && (sPerf.count % 25 === 0)) {
      diag.add?.(`[perf] drawChart p50=${sPerf.p50|0}ms p90=${sPerf.p90|0}ms p95=${sPerf.p95|0}ms p99=${sPerf.p99|0}ms (n=${sPerf.count})`);
    }
  },
};

/* --- Button-Flash (nur Platzhalter, wie gehabt) --- */


function flashButtonOk(btn, successHtml){
  if (!btn) return;
  const base = btn.dataset.label || btn.innerHTML;
  btn.dataset.label = base;
  btn.disabled = true;
  btn.innerHTML = successHtml;
  setTimeout(()=>{
    btn.innerHTML = btn.dataset.label;
    btn.disabled = false;
  }, 1200);
}

/* ===== Tabs / Segments ===== */
async function setTab(name){
  if (name !== "doctor" && document.body.classList.contains('app-locked')){
    __pendingAfterUnlock = null;
    lockUi(false);
  }
  if (name === "doctor"){
    const logged = await isLoggedInFast();
    if (!logged){
      showLoginOverlay(true);
      return;
    }
    if (!__doctorUnlocked){
      __pendingAfterUnlock = 'doctor';
      const ok = await requireDoctorUnlock();
      if (!ok) return;
      __pendingAfterUnlock = null;
    }
  }
  
  $$(".view").forEach(v => v.classList.remove("active"));
  $("#"+name).classList.add("active");
  $$(".tabs .btn").forEach(b =>
    b.classList.toggle("primary", b.dataset.tab === name)
  );
  if (name === "doctor") { await requestUiRefresh({ reason: 'tab:doctor' }); }
  if (name === "capture") { try { await refreshCaptureIntake(); resetCapturePanels(); updateBpCommentWarnings?.(); } catch(_){} }
  
}

function bindTabs(){
  $$(".tabs .btn").forEach(b =>
    b.addEventListener("click", async (e) => {
      const tab = e.currentTarget.dataset.tab;
      if (tab === "doctor") {
        const logged = await isLoggedInFast();
        if (!logged) {
          showLoginOverlay(true);
          return;
        }
      }
      setTab(tab);
    })
  );
}

/* ===== Save flows ===== */
// Replace sugar toggle with protein (runtime migration for legacy layouts)
// Migration entfernt: Markup nutzt direkt #proteinHighToggle
function setProteinHigh(on){
  proteinHigh = !!on;
  setToggle($("#proteinHighToggle"), proteinHigh, "&#x1F969; Protein >= 90 g (aktiv)", "&#x1F969; Protein >= 90 g");
}
let trainingActive=false, lowIntakeActive=false, sickActive=false, valsartanMissed=false, forxigaMissed=false, nsarTaken=false,
saltHigh=false, proteinHigh=false;
function setToggle(el, on, activeText, baseText){
el = el || null;
if (!el) return;
el.classList.toggle("active", !!on);
el.setAttribute("aria-pressed", on ? "true" : "false");
el.innerHTML = on ? activeText : baseText;
}
function setTraining(on){ trainingActive=!!on; setToggle($("#trainingToggle"), trainingActive, "&#x1F3CB;&#xFE0F; Training heute (aktiv)", "&#x1F3CB;&#xFE0F; Training heute"); }
function setLowIntake(on){ lowIntakeActive=!!on; setToggle($("#lowIntakeToggle"), lowIntakeActive, "&#x1F4A7; < 2 L (aktiv)", "&#x1F4A7; < 2 L getrunken"); }
function setSaltHigh(on){ saltHigh = !!on; setToggle($("#saltHighToggle"), saltHigh, "&#x1F9C2; > 5 g Salz (aktiv)", "&#x1F9C2; > 5 g Salz"); }
// Kommentar-Pflicht fuer BP: Grenzwerte markieren
function requiresBpComment(which){
  const sys = Number($(bpSelector('sys', which)).value);
  const dia = Number($(`#dia${which}`).value);
  const el = document.getElementById(which === "M" ? "bpCommentM" : "bpCommentA");
  const comment = (el?.value || "").trim();
  return ((sys > 130) || (dia > 90)) && !comment;
}
function updateBpCommentWarnings(){
  ['M','A'].forEach(which => {
    const el = document.getElementById(which === "M" ? "bpCommentM" : "bpCommentA");
    if (!el) return;
    const needs = requiresBpComment(which);
    el.style.outline = needs ? "2px solid var(--danger)" : "";
    if (needs) el.setAttribute("aria-invalid","true");
    else el.removeAttribute("aria-invalid");
  });
}

/* === Panel Reset Helpers (V1.5.7) === */
function bpFieldId(base, ctx){
  if (base === 'sys' && ctx === 'M') return 'captureAmount';
  return base + ctx;
}

function bpSelector(base, ctx){
  return base === 'sys' && ctx === 'M' ? '#captureAmount' : `#${base}${ctx}`;
}

function resetBpPanel(which, opts = {}) {
  const { focus = true } = opts;
  const ctx = which === 'A' ? 'A' : 'M';
  ['sys','dia','pulse','bpComment'].forEach(id => {
    const el = document.getElementById(bpFieldId(id, ctx));
    if (el) el.value = '';
  });
  try { updateBpCommentWarnings?.(); } catch(_){}
  if (focus) {
    const target = document.getElementById(bpFieldId('sys', ctx));
    if (target) target.focus();
  }
}
function resetBodyPanel(opts = {}) {
  const { focus = true } = opts;
  const weightEl = document.getElementById('weightDay');
  const waistEl = document.getElementById('input-waist-cm');
  const fatEl = document.getElementById('fatPctDay');
  const muscleEl = document.getElementById('musclePctDay');
  if (weightEl) weightEl.value = '';
  if (waistEl) waistEl.value = '';
  if (fatEl) { fatEl.value = ''; clearFieldError(fatEl); }
  if (muscleEl) { muscleEl.value = ''; clearFieldError(muscleEl); }
  if (focus && weightEl) weightEl.focus();
}
function resetFlagsPanel(opts = {}) {
  const { focus = true } = opts;
  try {
    setTraining(false);
    setLowIntake(false);
    setSick(false);
    setValsartanMiss(false);
    setForxigaMiss(false);
    setNsar(false);
    setSaltHigh(false);
    if (typeof setProteinHigh === 'function') setProteinHigh(false);
  } catch(_){ }
  const commentEl = document.getElementById('flagsComment');
  if (commentEl) commentEl.value = '';
  if (focus && commentEl) commentEl.focus();
}
function resetCapturePanels(opts = {}) {
  const { focus = true } = opts;
  resetBpPanel('M', { focus: false });
  resetBpPanel('A', { focus: false });
  resetBodyPanel({ focus: false });
  resetFlagsPanel({ focus: false });
  const ctxSel = document.getElementById('bpContextSel');
  if (ctxSel) ctxSel.value = 'M';
  document.querySelectorAll('.bp-pane').forEach(pane => {
    pane.classList.toggle('active', pane.dataset.context === 'M');
  });
  try { updateBpCommentWarnings?.(); } catch(_){ }
  if (focus) {
    const first = document.getElementById('captureAmount');
    if (first) first.focus();
  }
}
function addCapturePanelKeys(){
  const bind = (selectors, onEnter, onEsc) => {
    document.querySelectorAll(selectors).forEach(el => {
      el.addEventListener('keydown', e => {
        if (e.key === 'Enter') { e.preventDefault(); onEnter?.(); }
        if (e.key === 'Escape') { e.preventDefault(); onEsc?.(); }
      });
    });
  };
  bind('#captureAmount, #diaM, #pulseM, #bpCommentM', () => document.getElementById('saveBpPanelBtn')?.click(), () => resetBpPanel('M'));
  bind('#sysA, #diaA, #pulseA, #bpCommentA', () => document.getElementById('saveBpPanelBtn')?.click(), () => resetBpPanel('A'));
  bind('#weightDay, #input-waist-cm, #fatPctDay, #musclePctDay', () => document.getElementById('saveBodyPanelBtn')?.click(), () => resetBodyPanel());
  bind('#flagsComment', () => document.getElementById('saveFlagsPanelBtn')?.click(), () => resetFlagsPanel());
}function setSick(on){
sickActive=!!on; setToggle($("#sickToggle"), sickActive, "&#x1F912; Krank (Forxiga pausiert) (aktiv)", "&#x1F912; Krank (Forxiga pausiert)");
if(sickActive){ setForxigaMiss(true); $("#forxigaMissToggle").disabled=true; $("#forxigaMissToggle").style.opacity=0.6; }
else { $("#forxigaMissToggle").disabled=false; $("#forxigaMissToggle").style.opacity=1; }
}
function setValsartanMiss(on){ valsartanMissed=!!on; setToggle($("#valsartanMissToggle"), valsartanMissed, "&#x1F48A; Valsartan vergessen (aktiv)", "&#x1F48A; Valsartan vergessen"); }
function setForxigaMiss(on){ forxigaMissed=!!on; setToggle($("#forxigaMissToggle"), forxigaMissed, "&#x23F0; Forxiga vergessen (aktiv)", "&#x23F0; Forxiga vergessen"); }
function setNsar(on){ nsarTaken=!!on; setToggle($("#nsarToggle"), nsarTaken, "&#x1F489; NSAR genommen (aktiv)", "&#x1F489; NSAR genommen"); }
function blockHasData(which){
  const getVal = (sel) => document.querySelector(sel)?.value?.trim();
  const sys = getVal(bpSelector('sys', which));
  const dia = getVal(`#dia${which}`);
  const pulse = getVal(`#pulse${which}`);
  const commentEl = document.getElementById(which === "M" ? "bpCommentM" : "bpCommentA");
  const comment = (commentEl?.value || "").trim();
  return !!(sys || dia || pulse || comment);
}
async function saveBlock(contextLabel, which, includeWeight=false, force=false){
const date = $("#date").value || todayStr();
const time = which === 'M' ? '07:00' : '22:00';

const sys   = $(bpSelector('sys', which)).value   ? toNumDE($(bpSelector('sys', which)).value)   : null;
const dia   = $(`#dia${which}`).value   ? toNumDE($(`#dia${which}`).value)   : null;
const pulse = $(`#pulse${which}`).value ? toNumDE($(`#pulse${which}`).value) : null;

const commentEl = document.getElementById(which === 'M' ? 'bpCommentM' : 'bpCommentA');
const comment = (commentEl?.value || '').trim();

const hasAny = (sys != null) || (dia != null) || (pulse != null);
const hasComment = comment.length > 0;

if (!force && !hasAny && !hasComment) return false;

if (hasAny){
  if ((sys != null && dia == null) || (dia != null && sys == null)){
    uiError('Bitte beide Blutdruck-Werte (Sys und Dia) eingeben.');
    return false;
  }
  if (pulse != null && (sys == null || dia == null)){
    uiError('Puls kann nur mit Sys und Dia zusammen gespeichert werden.');
    return false;
  }

  const currentISO = new Date(date + "T" + time).toISOString();
  const ts = new Date(date + "T" + time).getTime();

  const entry = {
    date, time, dateTime: currentISO, ts,
    context: contextLabel,
    sys, dia, pulse,
    weight: null,
    map: (sys!=null && dia!=null) ? calcMAP(sys, dia) : null,
    notes: '',
    training: false,
    low_intake: false,
    sick: false,
    valsartan_missed: false,
    forxiga_missed: false,
    nsar_taken: false,
    salt_high: false,
    protein_high90: false
  };

  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
}

if (hasComment){
  try {
    await appendNote(date, which === 'M' ? '[Morgens] ' : '[Abends] ', comment);
    if (commentEl) commentEl.value = '';
    updateBpCommentWarnings();
  } catch(err) {
    diag.add?.('BP-Kommentar Fehler: ' + (err?.message || err));
  }
}

return hasAny || hasComment;
}

function baseEntry(date, time, contextLabel){
const iso = new Date(date + "T" + time).toISOString();
const ts = new Date(date + "T" + time).getTime();
return {
date, time, dateTime: iso, ts,
context: contextLabel, 
sys: null, dia: null, pulse: null, weight: null, map: null,
notes: ($("#notesDay")?.value || "").trim(),
training: trainingActive,
low_intake: lowIntakeActive,
sick: sickActive,
valsartan_missed: valsartanMissed,
forxiga_missed: forxigaMissed,
nsar_taken: nsarTaken,
salt_high: saltHigh,
protein_high90: proteinHigh
};
}

async function appendNote(date, prefix, text){
  const trimmed = (text || '').trim();
  if (!trimmed) return;
  const stamp = allocateNoteTimestamp(date);
  const entry = baseEntry(date, stamp.time, 'Tag');
  entry.dateTime = stamp.iso;
  entry.ts = stamp.ts;
  entry.notes = prefix + trimmed;
  entry.training = false;
  entry.low_intake = false;
  entry.sick = false;
  entry.valsartan_missed = false;
  entry.forxiga_missed = false;
  entry.nsar_taken = false;
  entry.salt_high = false;
  entry.protein_high90 = false;
  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
}

function allocateNoteTimestamp(date){
  const base = new Date(date + "T22:30:00");
  const now = Date.now();
  const minuteOffset = now % 60;
  const secondOffset = Math.floor(now / 1000) % 60;
  base.setMinutes(base.getMinutes() + minuteOffset);
  base.setSeconds(base.getSeconds() + secondOffset);
  const iso = base.toISOString();
  return { iso, ts: base.getTime(), time: iso.slice(11,16) };
}

async function saveFlagsCommentNote(date, text){
  const trimmed = (text || '').trim();
  if (!trimmed) return false;
  await appendNote(date, '[Flags] ', trimmed);
  return true;
}

async function saveDaySummary(options = {}){
  const { includeBody = true, includeFlags = true, includeFlagsComment = true } = options;
  const date = $("#date")?.value || todayStr();
  const time = "12:00";

  const entry = baseEntry(date, time, "Tag");
  let validationFailed = false;

  const notesRaw = ($("#notesDay")?.value || "").trim();
  if (includeBody){
    entry.notes = notesRaw;
    const w = $("#weightDay")?.value?.trim();
    entry.weight = w ? Number((w||"").replace(',', '.')) : null;
    const waistRaw = $("#input-waist-cm")?.value?.trim();
    entry.waist_cm = waistRaw ? toNumDE(waistRaw) : null;

    const fatPctEl = document.getElementById('fatPctDay');
    const musclePctEl = document.getElementById('musclePctDay');
    const parsePct = (el, label) => {
      if (!el) return null;
      const raw = (el.value || '').trim();
      if (!raw){
        clearFieldError(el);
        return null;
      }
      const pct = toNumDE(raw);
      if (!Number.isFinite(pct) || pct < 0 || pct > 100){
        setFieldError(el);
        uiError(`Bitte g?ltigen Wert f?r ${label} (0?100 %) eingeben.`);
        if (!validationFailed) el.focus();
        validationFailed = true;
        return null;
      }
      clearFieldError(el);
      return pct;
    };

    const fatPct = parsePct(fatPctEl, 'Fett');
    const musclePct = parsePct(musclePctEl, 'Muskel');
    entry.fat_pct = fatPct;
    entry.muscle_pct = musclePct;
  } else {
    entry.notes = '';
    entry.weight = null;
    entry.waist_cm = null;
    entry.fat_pct = null;
    entry.muscle_pct = null;
    clearFieldError(document.getElementById('fatPctDay'));
    clearFieldError(document.getElementById('musclePctDay'));
  }

  if (validationFailed) return false;

  if (includeFlags){
    entry.training = trainingActive;
    entry.low_intake = lowIntakeActive;
  entry.sick = sickActive;
  entry.valsartan_missed = valsartanMissed;
  entry.forxiga_missed = forxigaMissed;
  entry.nsar_taken = nsarTaken;
  entry.salt_high = saltHigh;
  entry.protein_high90 = proteinHigh;
} else {
  entry.training = null;
  entry.low_intake = null;
  entry.sick = null;
  entry.valsartan_missed = null;
  entry.forxiga_missed = null;
  entry.nsar_taken = null;
  entry.salt_high = null;
  entry.protein_high90 = null;
}

  const flagsComment = includeFlagsComment ? ($("#flagsComment")?.value || "").trim() : "";
let saved = false;

const hasBodyContent = includeBody && ((entry.weight != null) || (entry.waist_cm != null) || !!entry.notes);
const hasFlagContent = includeFlags && !!(trainingActive || lowIntakeActive || sickActive ||
  valsartanMissed || forxigaMissed || nsarTaken ||
  saltHigh || proteinHigh);

if (hasBodyContent || hasFlagContent){
  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
  saved = true;
}

if (includeFlagsComment && flagsComment){
  const savedNote = await saveFlagsCommentNote(date, flagsComment);
  if (savedNote){
    const el = document.getElementById('flagsComment');
    if (el) el.value = '';
    diag.add('Flags-Kommentar gespeichert');
    saved = true;
  }
}

return saved;
}

async function withRetry(fn, {tries=3, base=300}={}) {
let lastErr;
for (let i=0;i<tries;i++){
try { return await fn(); }
catch (e) {
const code = e?.status ?? e?.response?.status ?? 0;
if (!(code >= 500 && code < 600)) throw e;
await new Promise(r => setTimeout(r, base * Math.pow(2,i)));
lastErr = e;
}
}
throw lastErr;
}

async function fetchWithAuth(makeRequest, { tag = '', retry401 = true, maxAttempts = 2 } = {}) {
  const supa = await ensureSupabaseClient();
  if (!supa) {
    const err = new Error('auth-client-missing');
    err.status = 401;
    try { showLoginOverlay(true); } catch(_) {}
    throw err;
  }

  const signalAuth = () => {
    try { showLoginOverlay(true); } catch(_) {}
  };

  const loadHeaders = async (forceRefresh = false) => {
    if (forceRefresh) {
      try {
        await supa.auth.refreshSession();
      } catch (refreshErr) {
        try { diag.add?.(`[auth] refresh error: ${refreshErr?.message || refreshErr}`); } catch(_) {}
      }
    }
    return await getHeaders();
  };

  let headers = await loadHeaders(false);
  if (!headers) {
    headers = await loadHeaders(true);
  }
  if (!headers) {
    const err = new Error('auth-headers-missing');
    err.status = 401;
    signalAuth();
    throw err;
  }

  let attempts = 0;
  let refreshed = false;
  const max = Math.max(0, maxAttempts);

  while (true) {
    let res;
    try {
      res = await makeRequest(headers);
    } catch (err) {
      if (attempts < max) {
        attempts += 1;
        await sleep(200 * attempts);
        continue;
      }
      throw err;
    }

    if (!res || typeof res.status !== 'number') {
      const err = new Error('invalid-response');
      err.status = 0;
      throw err;
    }

    if (res.status === 401 || res.status === 403) {
      if (retry401 && !refreshed) {
        refreshed = true;
        try { diag.add?.(`[auth] ${tag || 'request'} ${res.status} -> refresh`); } catch(_) {}
        headers = await loadHeaders(true);
        if (!headers) {
          const err = new Error('auth-headers-missing');
          err.status = res.status;
          signalAuth();
          throw err;
        }
        attempts = 0;
        continue;
      }
      const err = new Error('auth-http');
      err.status = res.status;
      err.response = res;
      signalAuth();
      throw err;
    }

    if (res.status >= 500 && res.status < 600 && attempts < max) {
      attempts += 1;
      await sleep(200 * attempts);
      continue;
    }

    return res;
  }
}
  
async function syncWebhook(entry, localId){
  const url = await getConf("webhookUrl");
  if(!url){
    const err = new Error("syncWebhook: missing webhookUrl");
    err.status = 401;
    showLoginOverlay(true);
    throw err;
  }

  try{
    const uid = await getUserId();
    const events = toHealthEvents(entry);
    if (!events.length){
      diag.add("Webhook: keine Events zu senden");
      return;
    }

    const payload = events.map(ev => (uid ? { ...ev, user_id: uid } : ev));
    const res = await fetchWithAuth(
      headers => fetch(url, { method:"POST", headers, body: JSON.stringify(payload) }),
      { tag: 'webhook:post', maxAttempts: 2 }
    );

    if(!res.ok){
      let details = "";
      try {
        const e = await res.clone().json();
        details = (e?.message || e?.details || "");
      } catch { /* plain text? */ }

      if (res.status === 409 || /duplicate|unique/i.test(details)) {
        const flagsEv = events.find(ev => ev.type === 'day_flags');
        try {
          if (flagsEv && uid) {
            const dayIso = entry.date;
            await patchDayFlags({ user_id: uid, dayIso, flags: flagsEv.payload });
            const others = events.filter(ev => ev.type !== 'day_flags');
            if (others.length) {
              const res2 = await fetchWithAuth(
                headers => fetch(url, { method: "POST", headers, body: JSON.stringify(others.map(ev => ({ ...ev, user_id: uid }))) }),
                { tag: 'webhook:fallback', maxAttempts: 2 }
              );
              if (!res2.ok) throw new Error(`rest-post-failed-${res2.status}`);
            }
            uiInfo("Flags aktualisiert.");
            diag.add("Fallback: day_flags via PATCH");
            return;
          }
        } catch (_) { /* fallback failed */ }
        const noteEv = events.find(ev => ev.type === 'note');
        try {
          if (noteEv && uid) {
            const dayIso = entry.date;
            const merged = await appendNoteRemote({ user_id: uid, dayIso, noteEvent: noteEv });
            await updateEntry(localId, { remote_id: merged?.id ?? -1 });
            uiInfo('Kommentar aktualisiert.');
            diag.add('Fallback: note via PATCH');
            return;
          }
        } catch (_) { /* fallback failed */ }
      }

      if (res.status === 409 || /duplicate|unique/i.test(details)) {
        uiError("Es gibt bereits einen Eintrag fuer diesen Tag/Kontext.");
      } else if (res.status === 422 || /invalid|range|pflicht|check constraint/i.test(details)) {
        uiError("Eingaben ungueltig - bitte Wertebereiche/Pflichtfelder pruefen.");
      } else {
        uiError(`Speichern fehlgeschlagen (HTTP ${res.status}).`);
      }

      diag.add(`Webhook-Fehler ${res.status}: ${details || "-"}`);
      const err = new Error(`save-failed-${res.status}`);
      err.status = res.status;
      err.details = details;
      throw err;
    }

    const json = await res.json();
    const firstId = json?.[0]?.id ?? null;
    if(firstId != null){
      await updateEntry(localId, { remote_id: firstId });
      uiInfo("Gespeichert.");
      diag.add(`Webhook: OK (${events.length} Event(s))`);
    } else {
      uiError("Unerwartete Antwort vom Server - kein Datensatz zurueckgegeben.");
    }
  }catch(e){
    if (e?.status === 401 || e?.status === 403) {
      uiError("Bitte erneut anmelden, um weiter zu speichern.");
    } else {
      uiError("Netzwerkfehler beim Speichern. Bitte spaeter erneut versuchen.");
    }
    try { diag.add("Webhook: Netzwerkfehler"); } catch(_){ }
    throw e;
  }
}
/* ===== Realtime / Auto-Sync ===== */
let sbClient = null;

let __channels = [];
let __rtReady = false;

function trackChannel(ch){ __channels.push(ch); return ch; }

function teardownRealtime(){
  try{
    if (__channels.length) {
      __channels.forEach(ch => ch.unsubscribe?.());
      diag.add(`Realtime: ${__channels.length} Channel(s) unsubscribed`);
    }
  }catch(e){ diag.add("Realtime: unsubscribe error"); }
  __channels = [];
  __rtReady = false;
}

window.addEventListener('beforeunload', () => {
  teardownRealtime();
  if (__midnightTimer) {
    clearTimeout(__midnightTimer);
    __midnightTimer = null;
  }
  if (__noonTimer) {
    clearTimeout(__noonTimer);
    __noonTimer = null;
  }
  if (__dayHeartbeat) {
    clearInterval(__dayHeartbeat);
    __dayHeartbeat = null;
  }
});


function baseUrlFromRest(restUrl){
if(!restUrl) return null;
const i = restUrl.indexOf("/rest/");
return i>0 ? restUrl.slice(0, i) : null;
}

async function getUserId(){
try{
const supa = await ensureSupabaseClient();
if(!supa) return null;
const { data: { user } } = await supa.auth.getUser();
return user?.id ?? null;
}catch{ return null; }
}

async function ensureSupabaseClient(){
if (sbClient) return sbClient;

const rest = await getConf("webhookUrl");
const keyConf = await getConf("webhookKey"); // ANON key (nicht service_role)
if (!rest || !keyConf) {
  setConfigStatus('Bitte REST-Endpoint und ANON-Key speichern.', 'error');
  diag.add("Supabase Auth: fehlende Konfiguration");
  return null;
}

// NEU: niemals mit service_role starten
const trimmedKey = String(keyConf || '').trim();
if (isServiceRoleKey(trimmedKey)) {
  setConfigStatus('service_role Schluessel sind nicht erlaubt.', 'error');
  diag.add("Sicherheitsblock: service_role Key erkannt - Abbruch");
  return null;
}

const supabaseUrl = baseUrlFromRest(rest);
const anonKey = trimmedKey.replace(/^Bearer\s+/i,"");
if (!supabaseUrl) {
  setConfigStatus('REST-Endpoint ist ungueltig.', 'error');
  diag.add("Supabase Auth: ungueltige URL");
  return null;
}
if (!anonKey) {
  setConfigStatus('ANON-Key ist ungueltig.', 'error');
  diag.add("Supabase Auth: ungueltiger Key");
  return null;
}

sbClient = window.supabase.createClient(supabaseUrl, anonKey, {
auth: { persistSession:false, autoRefreshToken:true, detectSessionInUrl:true } // Session nur im RAM
});
diag.add("Supabase: Client (Auth) initialisiert");
setConfigStatus('', 'info');
return sbClient;
}

async function setupRealtime(){
  try{
    const supa = await ensureSupabaseClient();
    if (!supa) return;

    // Idempotenz: wenn schon "ready", nichts tun
    if (__rtReady && __channels.length > 0) {
      return;
    }

    // Bestehende Channels schliessen, um Doppelbindungen zu vermeiden
    if (__channels.length > 0) teardownRealtime();

    // Channel auf health_events - RLS begrenzt automatisch auf auth.uid()
    trackChannel(
      supa.channel('rt-health-events')
        .on('postgres_changes',
            { event: '*', schema: 'public', table: 'health_events' },
            (payload) => {
              // Optional: Zeitraum grob pruefen? (einfach halten: immer refreshen)
              livePulse();
              requestUiRefresh({ reason: 'realtime' });
            })
        .subscribe((status) => {
          if (status === 'SUBSCRIBED') { __rtReady = true; diag.add?.('Realtime: appointments subscribed'); }
        })
    );
    trackChannel(
      supa.channel('rt-appointments')
        .on('postgres_changes',
            { event: '*', schema: 'public', table: 'appointments' },
            (payload) => {
              livePulse();
              requestUiRefresh({ reason: 'realtime:appointments', appointments: true });
            })
        .subscribe((status) => {
          if (status === 'SUBSCRIBED') { __rtReady = true; diag.add?.('Realtime: subscribed'); }
        })
    );
  }catch(e){
    diag.add?.('Realtime: setup failed');
  }
}

/* ===== App-Lock (Passkey + PIN) ===== */
/* Doctor-only Unlock (no global lock) */
let __doctorUnlocked = false;
let __pendingAfterUnlock = null;
async function isWebAuthnAvailable(){
  if (!window?.PublicKeyCredential) return false;
  try{
    return await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
  }catch(_){
    return false;
  }
}

function configureLockOverlay({ hasPasskey = false, webAuthnAvailable = false, message = '', highlightSetup = false } = {}){
  const passBtn = document.getElementById('unlockPasskeyBtn');
  if (passBtn){
    const enable = webAuthnAvailable && hasPasskey;
    passBtn.disabled = !enable;
    passBtn.title = enable ? '' : (webAuthnAvailable ? 'Bitte zuerst Passkey einrichten.' : 'Passkey/WebAuthn nicht verfgbar.');
  }
  const setupBtn = document.getElementById('setupPasskeyBtn');
  if (setupBtn){
    setupBtn.disabled = !webAuthnAvailable;
    setupBtn.style.display = webAuthnAvailable ? 'block' : 'none';
    setupBtn.classList.toggle('flash', !!highlightSetup && webAuthnAvailable);
  }
  setLockMsg(message);
}

async function requireDoctorUnlock(){
  if (!(await isLoggedInFast())) { showLoginOverlay(true); return false; }
  if (__doctorUnlocked) return true;

  let credId = null;
  try { credId = await getConf(LOCK_CRED_ID_KEY); } catch(_){ credId = null; }
  const hasPasskey = !!credId;
  const webAuthnAvailable = await isWebAuthnAvailable();

  if (hasPasskey && webAuthnAvailable){
    const ok = await unlockWithPasskey();
    if (ok) return true;

    configureLockOverlay({
      hasPasskey: true,
      webAuthnAvailable: true,
      message: 'Entsperren abgebrochen  du kannst Passkey erneut versuchen oder PIN nutzen.'
    });
    lockUi(true);
    return false;
  }

  if (!hasPasskey && webAuthnAvailable){
    configureLockOverlay({
      hasPasskey: false,
      webAuthnAvailable: true,
      message: 'Kein Passkey eingerichtet. Bitte Passkey einrichten oder PIN nutzen.',
      highlightSetup: true
    });
    lockUi(true);
    return false;
  }

  configureLockOverlay({
    hasPasskey,
    webAuthnAvailable: false,
    message: 'Passkey / Windows Hello ist auf diesem Gert nicht verfgbar. Bitte PIN verwenden.'
  });
  lockUi(true);
  return false;
}
async function resumeAfterUnlock(intent){
  const target = intent || __pendingAfterUnlock || 'doctor';
  __pendingAfterUnlock = null;
  if (target === 'chart'){
    await setTab('doctor');
    setDocBadges({ visible: true });
    chartPanel.show();
    await requestUiRefresh({ reason: 'unlock:chart', chart: true });
    return;
  }
  if (target === 'export'){
    await setTab('doctor');
    const all = await getAllEntries();
    dl('gesundheitslog.json', JSON.stringify(all,null,2), 'application/json');
    return;
  }
  await setTab('doctor');
}

/* Kleine Utils */
const u8 = (len)=>{ const a=new Uint8Array(len); crypto.getRandomValues(a); return a; };
const b64u = {
  enc: (buf)=> btoa(String.fromCharCode(...new Uint8Array(buf)))
                .replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''),
  dec: (str)=> Uint8Array.from(atob(str.replace(/-/g,'+').replace(/_/g,'/')), c=>c.charCodeAt(0))
};
async function sha256(text){
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return b64u.enc(buf);
}

/* Config-Keys in IndexedDB.CONF */
const LOCK_ENABLED_KEY   = "app_lock_enabled";     // bool
const LOCK_CRED_ID_KEY   = "lock_cred_id";         // base64url
const LOCK_PIN_HASH_KEY  = "lock_pin_hash";        // SHA-256 b64url
const LOCK_LAST_OK_KEY   = "lock_last_ok";         // timestamp

/* UI Helpers */
function lockUi(on){
  document.body.classList.toggle('app-locked', !!on);
  const ov = document.getElementById('appLock');
  if (ov){
    const dialog = ov.querySelector('[role="dialog"]') || ov;
    ov.style.display = on ? 'flex' : 'none';
    if (on){
      focusTrap.activate(dialog);
      requestAnimationFrame(()=>{
        const pin = document.getElementById('pinInput');
        const pass = document.getElementById('unlockPasskeyBtn');
        if (pin && typeof pin.focus === 'function'){
          pin.focus();
          pin.select?.();
          return;
        }
        if (pass && !pass.disabled && typeof pass.focus === 'function'){
          pass.focus();
        }
      });
    } else {
      focusTrap.deactivate();
      const pin = document.getElementById('pinInput');
      if (pin && typeof pin.blur === 'function'){ pin.blur(); }
    }
  }
}
function setLockMsg(msg){
  const el = document.getElementById('lockMsg');
  if (el) el.textContent = msg || '';
}

/* Setup: Passkey registrieren (platform) */
async function registerPasskey(){
  try{
    const rpId = location.hostname;
    const userId = u8(16);
    const challenge = u8(32);
    const pubKeyOpts = {
      publicKey: {
        challenge,
        rp: { name: "Gesundheits-Logger", id: rpId },
        user: { id: userId, name: "local-user", displayName: "Local User" },
        pubKeyCredParams: [{ type:'public-key', alg:-7 }, { type:'public-key', alg:-257 }],
        timeout: 60000,
        authenticatorSelection: { authenticatorAttachment: 'platform', userVerification: 'preferred', residentKey: 'preferred' },
        attestation: 'none'
      }
    };
    const cred = await navigator.credentials.create(pubKeyOpts);
    if (!cred) throw new Error("Keine Antwort vom Authenticator.");
    const idB64 = b64u.enc(cred.rawId);
    await putConf(LOCK_CRED_ID_KEY, idB64);
    await putConf(LOCK_ENABLED_KEY, true);
    const waAvailable = await isWebAuthnAvailable();
    configureLockOverlay({ hasPasskey: true, webAuthnAvailable: waAvailable, message: 'Passkey eingerichtet - bitte kurz entsperren.' });
    setLockMsg('Passkey eingerichtet.');
    return true;
  }catch(e){
    setLockMsg("Passkey-Setup fehlgeschlagen: " + (e.message||e));
    return false;
  }
}

/* Entsperren per Passkey (nur Besitz+UV Check - lokal ausreichend fuer App-Lock) */
async function unlockWithPasskey(){
  try{
    const credId = await getConf(LOCK_CRED_ID_KEY);
    if (!credId){
      setLockMsg("Noch kein Passkey eingerichtet.");
      return false;
    }
    const allow = [{ type:'public-key', id: b64u.dec(credId) }];
    const challenge = u8(32);
    const opts = { publicKey: { challenge, rpId: location.hostname, timeout: 60000, allowCredentials: allow, userVerification:'preferred' } };
    const assertion = await navigator.credentials.get(opts);
    if (!assertion) throw new Error("Abgebrochen.");
    // Lokaler Gate: Erfolg der Challenge => entsperrt
    await putConf(LOCK_LAST_OK_KEY, Date.now());
    __doctorUnlocked = true;
    lockUi(false);
    try {
      await resumeAfterUnlock();
    } catch(_) {}
    return true;
  }catch(e){
    setLockMsg("Passkey fehlgeschlagen: " + (e.message||e));
    return false;
  }
}

/* PIN setzen/pruefen */
async function setPinInteractive(){
  const pin = prompt("Neue PIN (4-10 Ziffern):") || "";
  if (!/^\d{4,10}$/.test(pin)){ alert("Ungueltige PIN."); return false; }
  const hash = await sha256("pin:"+pin);
  await putConf(LOCK_PIN_HASH_KEY, hash);
  await putConf(LOCK_ENABLED_KEY, true);
  setLockMsg("PIN gesetzt ");
  return true;
}
async function unlockWithPin(){
  const input = document.getElementById('pinInput');
  const pin = (input?.value||"").trim();
  if (!pin){ setLockMsg("PIN eingeben."); return false; }
  const saved = await getConf(LOCK_PIN_HASH_KEY);
  if (!saved){ setLockMsg("Keine PIN hinterlegt."); return false; }
  const hash = await sha256("pin:"+pin);
  if (hash !== saved){ setLockMsg("PIN falsch."); return false; }
  await putConf(LOCK_LAST_OK_KEY, Date.now());
  input.value = "";
  __doctorUnlocked = true;
  lockUi(false);
  try { await resumeAfterUnlock(); } catch(_) {}
  return true;
}

/* Events binden (einmal in main()) */
function bindAppLockButtons(){
  const btnPass = document.getElementById('unlockPasskeyBtn');
  const btnPin  = document.getElementById('unlockPinBtn');
  const btnSetPass = document.getElementById('setupPasskeyBtn');
  const btnSetPin  = document.getElementById('setPinBtn');

  if (btnPass) btnPass.addEventListener('click', unlockWithPasskey);
  if (btnPin)  btnPin.addEventListener('click', unlockWithPin);
  if (btnSetPass) btnSetPass.addEventListener('click', registerPasskey);
  if (btnSetPin)  btnSetPin.addEventListener('click', setPinInteractive);
  const pinInput = document.getElementById('pinInput');
  if (pinInput) pinInput.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){ e.preventDefault(); unlockWithPin(); }
  });
  const overlay = document.getElementById('appLock');
if (overlay) overlay.addEventListener('click', (e)=>{ 
  if (e.target === overlay){ 
    __pendingAfterUnlock = null; 
    lockUi(false); 
    try { document.querySelectorAll('details[open]').forEach(d => d.removeAttribute('open')); } catch(_) {}
  } 
});

  const cancelBtn = document.getElementById('lockCancelBtn');
  if (cancelBtn) cancelBtn.addEventListener('click', ()=>{ 
  __pendingAfterUnlock = null; 
  lockUi(false); 
  try { document.querySelectorAll('details[open]').forEach(d => d.removeAttribute('open')); } catch(_) {}
});
}

/* ===== Main ===== */
async function main(){
diag.init(); helpPanel.init(); await initDB();
updateStickyOffsets();
try {
const haveUrl = await getConf("webhookUrl");
const haveKey = await getConf("webhookKey");
if (DEV_ALLOW_DEFAULTS) {
  if (!haveUrl && SUPABASE_URL_DEFAULT) await putConf("webhookUrl", DEFAULT_WEBHOOK_ENTRIES);
  if (!haveKey && SUPABASE_ANON_DEFAULT) await putConf("webhookKey", `Bearer ${SUPABASE_ANON_DEFAULT}`);
}
} catch (_) {}
chartPanel.init(); bindTabs();
const todayIso = todayStr();
$("#date").value = todayIso;
__lastKnownToday = todayIso;
__dateUserSelected = false;
__bpUserOverride = false;
prepareIntakeStatusHeader();
$("#from").value = new Date(Date.now()-90*24*3600*1000).toISOString().slice(0,10);
$("#to").value = todayIso;
setTab("capture");
await ensureSupabaseClient();
try{ resetCapturePanels(); updateBpCommentWarnings?.(); }catch(_){ }
try { addCapturePanelKeys?.(); } catch(_){ }
bindAuthButtons();
if (sbClient) watchAuthState()

// Wenn schon eingeloggt ? App starten, sonst Login-Leiste zeigen
const hasSession = await requireSession();
if (hasSession) {
  await afterLoginBoot(); // wichtig fuer Reload mit persistierter Session
      // Doctor-Unlock: nur bei Arzt-Ansicht (kein globaler App-Lock)  //  App-Lock direkt nach Boot pruefen/anzeigen
  await setupRealtime();  //  NEU: Realtime direkt aktivieren
  await requestUiRefresh();
}
  try {
    await refreshCaptureIntake();
  } catch(_) {}
await maybeRefreshForTodayChange({ force: true, source: 'boot' });
  __lastKnownToday = todayStr();
  scheduleMidnightRefresh();
  scheduleNoonSwitch();
  maybeAutoApplyBpContext({ source: 'boot-post-refresh' });
await refreshAppointments();
bindAppLockButtons();     //  Buttons der Lock-Card binden

// Konfiguration laden
const savedUrl = await getConf("webhookUrl");
const savedKey = await getConf("webhookKey");
// Diagnose: aktive REST-URL und Key-Typ
try{
  diag.add?.('Config URL: ' + (savedUrl || '(none)'));
  diag.add?.('Config Key: ' + (savedKey ? (isServiceRoleKey(savedKey) ? 'service_role(BLOCKED)' : 'anon/ok') : '(none)'));
}catch(_){ }
if (!savedUrl || !savedKey) {
  setTab("capture"); // In Erfassung bleiben
}

// Sanfte Warnung
// === Live-Kommentar-Pflicht: sofort roter Rand bei Grenzwertueberschreitung ===
['#captureAmount','#diaM','#bpCommentM','#sysA','#diaA','#bpCommentA'].forEach(sel=>{
  const el = $(sel); if(!el) return;
  el.addEventListener('input', updateBpCommentWarnings);
});
updateBpCommentWarnings();


// Toggle-Handler
const bpContextSel = document.getElementById('bpContextSel');
__bpPanesCache = Array.from(document.querySelectorAll('.bp-pane'));
if (bpContextSel){
  applyBpContext(bpContextSel.value || 'M');
  maybeAutoApplyBpContext({ force: true, source: 'boot' });
  bpContextSel.addEventListener('change', (e)=>{
    __bpUserOverride = true;
    applyBpContext(e.target.value);
    updateBpCommentWarnings();
  });
}

const saveBpPanelBtn = document.getElementById('saveBpPanelBtn');
if (saveBpPanelBtn){
  saveBpPanelBtn.addEventListener('click', async (e)=>{
    try {
      const logged = await isLoggedInFast();
      if (!logged) { diag.add?.('[panel] bp save while auth unknown'); }
    } catch(_) {}
    const btn = e.currentTarget;
    const ctxSel = document.getElementById('bpContextSel');
    const which = (ctxSel?.value === 'A') ? 'A' : 'M';
    updateBpCommentWarnings();
    if (requiresBpComment(which)){
      alert("Bitte Kommentar eingeben bei Grenzwertueberschreitung (Sys>130 oder Dia>90).");
      const target = document.getElementById(which === 'M' ? 'bpCommentM' : 'bpCommentA');
      if (target) target.focus();
      return;
    }
    withBusy(btn, true);
    let savedOk = false;
    try{
      const saved = await saveBlock(which === 'M' ? 'Morgen' : 'Abend', which, false, false);
      if (!saved){
        uiError('Keine Daten fuer diesen Messzeitpunkt eingegeben.');
      } else {
        savedOk = true;
        await requestUiRefresh({ reason: 'panel:bp' });
      }
    }catch(err){
      diag.add?.('Panel BP Fehler: ' + (err?.message || err));
      uiError('Speichern fehlgeschlagen. Bitte erneut versuchen.');
    }finally{
      withBusy(btn, false);
    }
    if (savedOk){
      updateBpCommentWarnings();
      resetBpPanel(which); flashButtonOk(btn, '&#x2705; Blutdruck gespeichert');
    }
  });
}

const saveBodyPanelBtn = document.getElementById('saveBodyPanelBtn');
if (saveBodyPanelBtn){
  saveBodyPanelBtn.addEventListener('click', async (e)=>{
    try {
      const logged = await isLoggedInFast();
      if (!logged) { diag.add?.('[panel] body save while auth unknown'); }
    } catch(_) {}
    const btn = e.currentTarget;
    withBusy(btn, true);
    let savedOk = false;
    try{
      const saved = await saveDaySummary({ includeBody: true, includeFlags: false, includeFlagsComment: false });
      if (!saved){
        uiError('Keine Koerperdaten eingegeben.');
      } else {
        savedOk = true;
        await requestUiRefresh({ reason: 'panel:body' });
      }
    }catch(err){
      diag.add?.('Panel Koerper Fehler: ' + (err?.message || err));
      uiError('Speichern fehlgeschlagen. Bitte erneut versuchen.');
    }finally{
      withBusy(btn, false);
    }
      if (savedOk){
        resetBodyPanel();
        await prefillBodyInputs();
        flashButtonOk(btn, '&#x2705; Koerper gespeichert');
      }
  });
}

const saveFlagsPanelBtn = document.getElementById('saveFlagsPanelBtn');
if (saveFlagsPanelBtn){
  saveFlagsPanelBtn.addEventListener('click', async (e)=>{
    try {
      const logged = await isLoggedInFast();
      if (!logged) { diag.add?.('[panel] flags save while auth unknown'); }
    } catch(_) {}
    const btn = e.currentTarget;
    withBusy(btn, true);
    let savedOk = false;
    try{
      const saved = await saveDaySummary({ includeBody: false, includeFlags: true, includeFlagsComment: true });
      if (!saved){
        uiError('Keine Flag-Daten eingegeben.');
      } else {
        savedOk = true;
        await requestUiRefresh({ reason: 'panel:flags' });
      }
    }catch(err){
      diag.add?.('Panel Flags Fehler: ' + (err?.message || err));
      uiError('Speichern fehlgeschlagen. Bitte erneut versuchen.');
    }finally{
      withBusy(btn, false);
    }
    if (savedOk){
      resetFlagsPanel(); flashButtonOk(btn, '&#x2705; Flags gespeichert');
    }
  });
}

const bindToggle = (id, setter, getVal)=>{
  const el = $(id);
  el.addEventListener("click", ()=>{
    setter(!getVal());
  });
};
bindToggle("#trainingToggle", setTraining, ()=>trainingActive);
bindToggle("#lowIntakeToggle", setLowIntake, ()=>lowIntakeActive);
bindToggle("#sickToggle", setSick, ()=>sickActive);
bindToggle("#valsartanMissToggle", setValsartanMiss, ()=>valsartanMissed);
bindToggle("#forxigaMissToggle", setForxigaMiss, ()=>forxigaMissed);
bindToggle("#nsarToggle", setNsar, ()=>nsarTaken);
bindToggle("#saltHighToggle", setSaltHigh, ()=>saltHigh);
bindToggle("#proteinHighToggle", setProteinHigh, ()=>proteinHigh);

// Sync toggles when the date changes in capture view
const dateEl = document.getElementById('date');
  if (dateEl) {
    dateEl.addEventListener('change', async () => {
      try {
        const todayIso = todayStr();
        __dateUserSelected = (dateEl.value || '') !== todayIso;
        // was du beim Datum aendern haben willst:
        await refreshCaptureIntake();
        await syncCaptureToggles();
        resetCapturePanels();
        updateBpCommentWarnings?.();
        await prefillBodyInputs();
      } catch(_) {}
    });
  }

// Apply Range -> Arztansicht neu rendern
const applyBtn = $("#applyRange");
if (applyBtn) {
  applyBtn.addEventListener("click", async () => {
    await requestUiRefresh({ reason: 'doctor:range' });
    setDocBadges({ visible: true });
  });
}

$("#doctorChartBtn").addEventListener("click", async ()=>{
  try {
    const logged = await isLoggedInFast();
    if (!logged) { diag.add?.('[doctor] chart open while auth unknown'); }
  } catch(_) {}
  if (!__doctorUnlocked){
    __pendingAfterUnlock = 'chart';
    const ok = await requireDoctorUnlock();
    if (!ok) return;
    __pendingAfterUnlock = null;
  }
  setDocBadges({ visible: true });
  chartPanel.show();
  await requestUiRefresh({ reason: 'doctor:chart-open', chart: true });
});

document.addEventListener('keydown', (e)=>{
  if (e.key !== 'Escape') return;

  try {
    if (chartPanel?.open) {
      chartPanel.hide();
      e.preventDefault();
      return;
    }
    if (helpPanel?.open) {
      helpPanel.hide();
      e.preventDefault();
      return;
    }
    if (diag?.open) {
      diag.hide();
      e.preventDefault();
      return;
    }
  } catch(_){ }

  try {
    const appLock = document.getElementById('appLock');
    if (appLock && appLock.style.display !== 'none') {
      __pendingAfterUnlock = null;
      lockUi(false);
      e.preventDefault();
      return;
    }
    const login = document.getElementById('loginOverlay');
    if (login && login.style.display !== 'none') {
      showLoginOverlay(false);
      e.preventDefault();
      return;
    }
  } catch(_){ }
});

let __lastResumeAt = 0;
let __resumeRunning = false;
const RESUME_COOLDOWN_MS = 250;

async function resumeFromBackground({ source = 'resume' } = {}) {
  const now = Date.now();
  if (__resumeRunning) {
    diag.add?.(`[resume] skipped (running) - ${source}`);
    return;
  }
  if (__lastResumeAt && (now - __lastResumeAt) < RESUME_COOLDOWN_MS) {
    diag.add?.(`[resume] skipped (cooldown) - ${source}`);
    return;
  }
  __resumeRunning = true;
  __lastResumeAt = now;
  try {
    if (!diag?.logEl) {
      try { diag.init(); } catch(_) {}
    }
    diag.add?.(`[resume] start: ${source}`);
    // sanftes Repaint
    try { await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r))); } catch(_) {}
    updateStickyOffsets();
    scheduleAuthGrace();

    const supa = await ensureSupabaseClient();
    diag.add?.('[resume] supabase client ' + (supa ? 'ready' : 'missing'));
    if (!supa) { diag.add?.('[resume] no supabase client -> login overlay'); finalizeAuthState(false); showLoginOverlay(true); return; }

    // Session pr?fen (Timeout-safe) und ggf. auffrischen
    let loggedIn = await isLoggedInFast({ timeout: 800 });
    diag.add?.(`[resume] loggedFast=${loggedIn}`);
    if (!loggedIn) {
      diag.add?.('[resume] session miss -> refresh');
      try {
        const refreshed = await supa.auth.refreshSession();
        loggedIn = !!refreshed?.data?.session;
        diag.add?.(`[resume] refresh result=${loggedIn}`);
      } catch(e) {
        diag.add?.('[resume] refresh error: ' + (e?.message || e));
      }
    }
    finalizeAuthState(loggedIn);
    diag.add?.(`[resume] logged=${loggedIn}`);
    if (!loggedIn) { diag.add?.('[resume] no session -> login overlay'); showLoginOverlay(true); return; }

    // *** Intake-Pills zuerst auf den aktuellen Tagesstand bringen ***
    try {
      await maybeRefreshForTodayChange({ force: true, source: source || 'resume' });
      diag.add?.('[resume] day state refreshed');
    } catch(e) {
      diag.add?.('[resume] day refresh error: ' + (e?.message || e));
    }
    try { bindIntakeCapture(); diag.add?.('[resume] intake listeners rebound'); } catch(_){}

    // Realtime nur bei Bedarf neu aufbauen
    if (!__rtReady || __channels.length === 0) {
      diag.add?.('Resume: re-setupRealtime');
      try { await setupRealtime(); diag.add?.('[resume] realtime ensured'); }
      catch(e) { diag.add?.('[resume] realtime error: ' + (e?.message || e)); throw e; }
    }

    // Gezielter UI-Refresh (Doctor immer; Lifestyle/Charts nur wenn aktiv/offen; Appointments explizit)
    await requestUiRefresh({ reason: 'resume', appointments: true });
    diag.add?.('[resume] ui refresh requested');

    scheduleNoonSwitch();
    maybeAutoApplyBpContext({ source });

    // sanfte Fokusreparatur
    try {
      let focusTarget = null;
      if (document.activeElement?.matches?.('input, select, textarea')) {
        focusTarget = document.activeElement;
      } else if (document.getElementById('capture')?.classList.contains('active')) {
        focusTarget = document.getElementById('captureAmount');
      }
      if (focusTarget) {
        ensureNotObscured(focusTarget);
        try { focusTarget.focus?.(); } catch(_) {}
      }
    } catch(_) {}

    diag.add?.('Resume: done');
  } catch (e) {
    diag.add?.('Resume error: ' + (e?.message || e));
  } finally {
    __resumeRunning = false;
  }
}
// <-- Ende von async function resumeFromBackground

// --- Resume-Listener ---
document.addEventListener('visibilitychange', () => {
  diag.add?.(`[event] visibilitychange -> ${document.visibilityState}`);
  if (document.visibilityState !== 'visible') return;
  (async () => { await resumeFromBackground({ source: 'visibility' }); })();
});

window.addEventListener('pageshow', (event) => {
  diag.add?.(`[event] pageshow (persisted=${event.persisted ? 1 : 0})`);
  if (event.persisted || document.visibilityState === 'visible') {
    (async () => { await resumeFromBackground({ source: 'pageshow' }); })();
  }
});

window.addEventListener('focus', () => {
  diag.add?.('[event] focus');
  (async () => { await resumeFromBackground({ source: 'focus' }); })();
});

// --- Arzt-Export ---
$("#doctorExportJson").addEventListener("click", async () => {
  try {
    const logged = await isLoggedInFast();
    if (!logged) { diag.add?.('[doctor] export while auth unknown'); }
  } catch(_) {}
  if (!__doctorUnlocked) {
    __pendingAfterUnlock = 'export';
    const ok = await requireDoctorUnlock();
    if (!ok) return;
    __pendingAfterUnlock = null;
  }
  const all = await getAllEntries();
  dl("gesundheitslog.json", JSON.stringify(all, null, 2), "application/json");
});

// --- Lifestyle binden und initial (falls bereits angemeldet) laden ---
bindIntakeCapture();
bindAppointmentsPanel();
try { if (await isLoggedInFast()) { await cleanupOldIntake(); } } catch(_) {}

// Initial Render
await requestUiRefresh({ reason: 'boot:initial', appointments: true });

// --- Failsafe: nach Reload alles sicher freigeben (falls etwas "disabled" haengen blieb)
$$('#appMain input, #appMain select, #appMain textarea, #appMain button, nav.tabs button').forEach(el=>{
el.disabled = false;
});
document.body.classList.remove('auth-locked');

// Auto-Push Pending sobald online
window.addEventListener('online', async ()=>{
const resPush = await pushPendingToRemote();
if(resPush.pushed || resPush.failed){
diag.add('Online-Push: OK=' + resPush.pushed + ', FAIL=' + resPush.failed);
if (typeof reconcileFromRemote === 'function') {
  await reconcileFromRemote();
}
}
});
}

resetAppointmentsUi();

/* boot */
if (!window.__bootDone) {
  window.__bootDone = true;
  if (document.readyState === "loading") {
    window.addEventListener("DOMContentLoaded", main);

    window.addEventListener('focus', () => {
      try { maybeRefreshForTodayChange({ source: 'focus' }); } catch(_){ }
    });
  } else {
    main();
  }
}

/* === Debug-Notizen
- V1.5: Realtime ueber supabase-js; Projekt-URL aus REST-URL abgeleitet.
- Auto-Sync: push pending ? reconcile (Entries) ohne Wipe.
- Realtime-Events: INSERT/UPDATE ? upsert, DELETE ? lokal entfernen.
- UI-Refresh: Arzt-Ansicht sofort; Charts nur, wenn Panel offen.
=== */
</script>
<!-- Login-Overlay (zentriert) -->
<div id="loginOverlay" style="display:none">
  <div class="login-card" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
    <h3 id="loginTitle">Willkommen</h3>
    <p class="small" style="margin:0 0 8px">Melde dich an, um Arzt-Ansicht & Diagramme zu nutzen.</p>
    <button class="btn primary" id="googleLoginBtn" type="button" style="width:100%;height:48px;margin-bottom:12px">Mit Google anmelden</button>
    <details id="configAdv" class="config-box" style="margin-bottom:12px">
      <summary class="small" style="cursor:pointer;list-style:none;padding:8px 0">Erweiterte Einstellungen</summary>
      <div style="display:flex;flex-direction:column;gap:6px;margin-top:4px">
        <label class="small" for="configRestUrl">Supabase REST-Endpoint</label>
        <input id="configRestUrl" type="url" inputmode="url" placeholder="https://...supabase.co/rest/v1/health_events" style="width:100%;padding:10px;border-radius:8px;border:1px solid #d1d5db">
        <label class="small" for="configAnonKey" style="margin-top:4px">Supabase ANON-Key</label>
        <textarea id="configAnonKey" rows="3" placeholder="ANON-Key (kein service_role)" style="width:100%;padding:10px;border-radius:8px;border:1px solid #d1d5db;resize:vertical"></textarea>
        <button class="btn ghost" id="configSaveBtn" type="button" style="width:100%;margin-top:4px">Konfiguration speichern</button>
        <div id="configStatus" class="small" style="min-height:16px;color:#9aa3af"></div>
      </div>
    </details>
    <div id="whoAmI" class="small" style="text-align:center;margin-top:6px"></div>
  </div>
</div>

<!-- App-Lock Overlay (zentriert) -->
<div id="appLock" style="display:none">
  <div class="lock-card" role="dialog" aria-modal="true" aria-labelledby="lockTitle">
    <h3 id="lockTitle">App gesperrt</h3>
    <p class="small" style="margin:0 0 8px">
      Bitte entsperren: bevorzugt per Passkey (Finger/Face). Alternativ PIN.
    </p>

    <div class="row" style="gap:8px">
      <button class="btn primary" id="unlockPasskeyBtn" type="button" style="width:100%;height:48px">
        Per Passkey entsperren
      </button>
    </div>

    <div class="pin-wrap">
      <input id="pinInput" type="password" inputmode="numeric" autocomplete="off" placeholder="PIN (optional)">
      <button class="btn ghost" id="unlockPinBtn" type="button">PIN</button>
    </div>

    <div class="small" style="margin-top:8px; opacity:.8">
      <button class="btn ghost" id="setupPasskeyBtn" type="button" style="width:100%;margin-top:6px">
        Passkey einrichten
      </button>
      <button class="btn ghost" id="setPinBtn" type="button" style="width:100%;margin-top:6px">
        PIN setzen/aendern
      </button>
    </div>

    <button class="btn ghost" id="lockCancelBtn" type="button" style="width:100%;margin-top:8px">
      Abbrechen
    </button>

    <div id="lockMsg" class="small" style="margin-top:6px;color:#6b7280"></div>
  </div>
</div>

</body>
</html>

<!-- marker -->
