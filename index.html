<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />

<!-- ANKER: bootstrap-logger -->
<script>
(function(){
  function log(msg){
    try{
      var el = document.getElementById("diagLog") || document.getElementById("touchLog");
      if(!el){
        var fb = document.createElement("pre");
        fb.id="touchLog";
        fb.style.cssText="position:fixed;bottom:0;left:0;right:0;max-height:40vh;overflow:auto;background:#111;color:#eee;font-size:12px;padding:4px;z-index:10000";
        document.body.appendChild(fb);
        el=fb;
      }
      el.textContent = (msg + "\n" + el.textContent).slice(0,5000);
    }catch(e){ /* not fatal */ }
  }
  window.addEventListener("error", e=>{
    log("[Error] "+(e.message||e)+" @"+(e.filename||"")+"#"+(e.lineno||0));
  });
  window.addEventListener("unhandledrejection", e=>{
    log("[Promise] "+(e.reason?.message||e.reason||"Unknown"));
  });
  window.addEventListener("error", e=>{
    if(e.target && (e.target.src||e.target.href)){
      log("[Resource] "+(e.target.src||e.target.href)+" failed to load");
    }
  }, true);
window.addEventListener("keydown", e=>{
  if(e.key === "F9"){   // Hotkey pruefen
    var el = document.getElementById("touchLog");
    if(!el){
      // Falls Panel fehlt  neu erstellen
      el = document.createElement("pre");
      el.id = "touchLog";
      el.style.cssText="display:block;position:fixed;bottom:0;left:0;right:0;max-height:40vh;overflow:auto;background:#111;color:#eee;font-size:12px;padding:4px;z-index:10000";
      document.body.appendChild(el);
    }
    // Toggle Sichtbarkeit
    el.style.display = (el.style.display==="none" ? "block" : "none");
  }
});
})();
</script>

<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Gesundheits-Logger (V1.4.5)</title>
<style>

/* ANKER: chart-controls styles (move to assets/app.css bei naechster Release) */
  /* Dropdown optisch kompakter */
  #chart .controls .compact { max-width: 240px; }

  /* KPI-Zeile: -Werte neben dem Dropdown */
  #chart .controls .kpis {
    display: inline-flex;
    gap: 16px;
    align-items: center;
    margin-left: 16px;
    color: var(--text, #e5e7eb);
    font-size: 0.95rem;
    white-space: nowrap;
  }
  #chart .controls .kpis .sep { opacity: .6; }
  
body.auth-locked main{ opacity:.6; }
:root { --bg:#0b0c10; --card:#15171c; --fg:#e8e8e8; --muted:#9aa3af; --accent:#4f46e5; --warn:#f59e0b; --ok:#10b981; --danger:#ef4444; }
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial;background:var(--bg);color:var(--fg);-webkit-tap-highlight-color:transparent;touch-action:manipulation;overscroll-behavior-y:none}
header{position:sticky;top:0;background:linear-gradient(180deg,rgba(11,12,16,.95),rgba(11,12,16,.7));backdrop-filter:blur(6px);z-index:10;padding:10px 12px;border-bottom:1px solid #1f232b}
h1{margin:0;font-size:20px}
nav.tabs{display:flex;gap:8px;padding:8px 12px;position:sticky;top:54px;background:rgba(11,12,16,.9);backdrop-filter:blur(6px);z-index:11}
nav.tabs button{flex:1;min-width:100px;touch-action:manipulation}
main{padding:12px;position:relative;z-index:1}
.card{background:var(--card);border:1px solid #242833;border-radius:16px;padding:14px;margin-bottom:12px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
.row{display:flex;gap:8px;flex-wrap:wrap}
.grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
@media (max-width:640px){ .grid{grid-template-columns:1fr} }
label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
input, select, textarea {width:100%;padding:12px;border-radius:12px;border:1px solid #2b2f3a;background:#0f1116;color:var(--fg);font-size:16px}
textarea{min-height:64px;resize:vertical}

.small{font-size:12px;color:var(--muted)}
.btn{appearance:none;border:none;border-radius:12px;padding:12px 14px;font-weight:600;color:white;background:#2b2f3a;cursor:pointer;touch-action:manipulation;transition: background .25s ease, color .25s ease, transform .06s ease, box-shadow .25s ease}
.btn:disabled{opacity:.6;cursor:not-allowed}
.btn:active{ transform: scale(0.98) }
.btn.primary{background:var(--accent)}
.btn.ghost{background:#0f1116;border:1px solid #2b2f3a;color:var(--fg)}
.btn.warn{background:var(--warn);color:#1a1200}
.btn.toggle.active{ background: var(--ok); color:#06110b; border-color: transparent; }
/* Tabs: aktiver Zustand = wie Primary */
nav.tabs .btn.primary {
  background: var(--accent);
  color: #fff;
  border-color: transparent;
}

.btn.flash{background:linear-gradient(90deg,var(--accent) 0%,#7c3aed 50%,var(--accent) 100%)!important;background-size:200% 100%;color:#fff!important;animation:flashGradient 1s ease forwards,flashPop .2s ease;box-shadow:0 6px 24px rgba(79,70,229,.35)}
@keyframes flashGradient{0%{background-position:0% 50%}100%{background-position:100% 50%}}
@keyframes flashPop {
0% { transform: scale(1) }
50% { transform: scale(1.03) }
100% { transform: scale(1) }
}

/* Toolbar mit zentrierter Mitte + Badges rechts */
#doctorCard .toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: space-between; /* Titel links + Mitte + Badges rechts */
}

#doctorCard .toolbar .center-group {
  flex: 1;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center; /* Buttons + Datum + Anwenden mittig */
}

#doctorCard .toolbar .badge {
  margin-left: 8px;
}

.spacer{flex:1}
section.view{display:none}
section.view.active{display:block}

#doctorCard .toolbar{border-bottom:1px solid #242833;padding-bottom:8px;margin-bottom:8px}

#err{position:fixed;left:8px;right:8px;bottom:8px;background:#3d0d0d;color:#fecaca;padding:8px 10px;border-radius:10px;display:none;z-index:9999}

/* === Arzt-Ansicht (Daily): 3-Spalten-Layout je Tag === */
.doctor-view .doctor-day{
display:grid;
grid-template-columns: 1fr; /* Standard = gestapelt */
gap:12px;
align-items:start;
padding:12px 14px;
margin:8px 0;
border-radius:12px;
background:var(--card);
border:1px solid #242833;
box-shadow:0 6px 18px rgba(0,0,0,.25);
page-break-inside:avoid;
break-inside:avoid;
}

  /* --- Arzt-Toolbar Badges (Daily KPIs) --- */
.badge {
  display: inline-block;
  padding: 6px 12px;         /* etwas mehr Platz */
  border: 1.5px solid #2b2f3a;
  border-radius: 12px;       /* runder = moderner */
  font-size: 13px;           /* +1pt groesser */
  font-weight: 600;          /* kraeftiger */
  margin-left: 10px;
}
.badge.good{border-color:var(--ok); color:var(--ok)}
.badge.bad{ border-color:var(--danger); color:var(--danger)}
.badge.hidden{ display:none !important; }

/* Tablet/Desktop: nebeneinander */
@media (min-width: 900px){
.doctor-view .doctor-day{
grid-template-columns: 18% 46% 36%;
}
}

/* Zwischenbereich: 2 Spalten */
@media (min-width: 600px) and (max-width: 899px){
.doctor-view .doctor-day{
grid-template-columns: 40% 60%;
grid-template-areas:
"date measure"
"date special";
}
.doctor-view .col-date{ grid-area: date; }
.doctor-view .col-measure{ grid-area: measure; }
.doctor-view .col-special{ grid-area: special; }
}

/* Spalte A - Datum */
.doctor-view .col-date{
display:flex; align-items:center;
font-weight:800;
font-size:clamp(16px,1.6vw,20px);
letter-spacing:.2px;
}
  /* Datumsspalte mit Cloud + Delete untereinander */
.doctor-view .col-date{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.doctor-view .col-date .date-top{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}
.doctor-view .col-date .date-label{
  font-weight:800;
  font-size:clamp(16px,1.6vw,20px);
  letter-spacing:.2px;
}
.doctor-view .col-date .date-cloud{ font-size:16px; line-height:1; }
.doctor-view .col-date .date-actions{
  display:flex;
  justify-content:flex-start; /* oder center, wenn du's mittig magst */
}
.btn-xs{ padding:6px 10px; font-size:12px; border-radius:8px; }

/* Spalte B - Messungen */
.doctor-view .col-measure{ display:grid; grid-template-rows:auto 1fr; gap:6px; }
/* Kopf und Werte-Spalten: gleiche Breiten wie Zahlen, Label links fix */
.doctor-view .measure-head,
.doctor-view .measure-grid{
display:grid;
grid-template-columns: minmax(70px, auto) repeat(4, 1fr);
gap:4px;
}
.doctor-view .measure-head{ font-size:12px; opacity:.8; }


/* Head-Zellen als Flex: rechtsbuendig wie die Zahlen */
.doctor-view .measure-head > div{ display:flex; align-items:center; }
.doctor-view .measure-head > div:first-child{ justify-content:flex-start; }
.doctor-view .measure-head > div:not(:first-child){ justify-content:flex-end; }
.doctor-view .measure-row{ display:contents; }
.doctor-view .label{ display:flex; align-items:center; font-size:13px; opacity:.9; }

/* Zahlenbild */
.doctor-view .num{
font-variant-numeric: tabular-nums lining-nums;
-moz-font-feature-settings:"tnum","lnum";
-webkit-font-feature-settings:"tnum","lnum";
font-feature-settings:"tnum","lnum";
text-align:right;
display:flex; align-items:center; justify-content:flex-end;

min-width: 4ch; /* Basisschutz gegen Abschneiden */
white-space: nowrap;
}
  
  /* Grenzwert-Highlight fuer Arzt-Ansicht */
.doctor-view .num.alert{ color: var(--danger); }

.doctor-view .measure-grid .num,
.doctor-view .col-special .num{
text-align:right; justify-content:flex-end;
}

/* Spalte C - Spezialinfos */
/* Gewicht: Ueberschrift + Zahl darunter */
.doctor-view .weight-line,
.doctor-view .waist-line{
  display:flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  background: transparent;
  border: none;
  padding: 0;
  font-weight: 600;
}

.doctor-view .weight-line > :first-child,
.doctor-view .waist-line > :first-child{
  font-size: 12px;
  opacity:.8;
  font-weight:600;
  letter-spacing:.2px;
}

.doctor-view .weight-line .num,
.doctor-view .waist-line .num{
  font-size:clamp(16px,1.6vw,20px);
  font-weight:700;
  line-height:1.1;
  text-align:center;
}

/* Spalten C/D/E: Gewicht | Flags | Kommentar */
.doctor-view .col-special{
  display: grid;
  grid-template-columns: minmax(120px, max-content) 220px 1fr; /* C | D | E */
  column-gap: 16px;
  row-gap: 6px;
  align-items: start; /* <-- alles oben ausrichten */
}

/* Elemente gezielt in Spalten setzen */
.doctor-view .col-special > .weight-line,
.doctor-view .col-special > .waist-line { grid-column: 1; }
.doctor-view .col-special > .flags       { grid-column: 2; }
.doctor-view .col-special > .notes       { grid-column: 3; }

/* D: Flags - Desktop: eine Spalte untereinander */
.doctor-view .flags{
  display:grid;
  grid-template-columns: repeat(2, max-content); /* 2 Spalten */
  justify-content:start;
  align-items:start;
  gap: 6px 16px; /* vertikal 6px, horizontal 16px */
}

.doctor-view .weight-line .num,
.doctor-view .waist-line .num{ font-variant-numeric: tabular-nums; } /* Spalten wirken ruhiger */
.doctor-view .flag span:last-child{ white-space:nowrap; }
.doctor-view .flag{ display:grid; grid-template-columns:18px 1fr; align-items:center; gap:6px; font-size:12px; opacity:.95; }
.doctor-view .flag-box{
width:16px; height:16px; border:1.5px solid #2b2f3a; border-radius:3px; display:inline-block; position:relative;
}
.doctor-view .flag-box.on::after{
content:""; position:absolute; inset:2px; background:var(--accent); border-radius:2px;
}

/* Notizen: im Screen 3 Zeilen, im Druck voll */
/* Kommentar: Titel + Box */
/* Kommentar: Kopf + Wert, ohne Kasten */
.doctor-view .notes{
  font-size: 13px;
  line-height: 1.35;
  display: -webkit-box;
  -webkit-line-clamp: 3;      /* 3 Zeilen, bei Bedarf 2 setzen */
  -webkit-box-orient: vertical;
  overflow: hidden;
  word-break: break-word;
  padding: 0;                 /* kein Box-Feeling */
  background: transparent;
  border: none;
}
.doctor-view .notes::before{
  content: "Kommentar";
  display: block;
  font-size: 12px;
  opacity: .8;
  font-weight: 600;
  letter-spacing: .2px;
  margin-bottom: 4px;
}
/* NICHT ausblenden, auch wenn leer - der Renderer liefert "-" */

/* Mobile-Optimierung */
@media (max-width: 599px){

  /* Kopf & Werte: schmaelere Label-Spalte + garantierte Zahlbreite */
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(72px, 1fr) repeat(4, minmax(56px, 1fr));
  }
  .doctor-view .measure-head{ font-size: 11px; }

  /* Zahlen duerfen nicht schrumpfen  keine abgeschnittenen Dezimalstellen */
  .doctor-view .num{
    min-width: 4.5ch; /* ~ "96.7" passt sicher */
    white-space: nowrap;
    flex: 0 0 auto;
  }
.doctor-view .col-special .weight-line .num,
.doctor-view .col-special .waist-line .num{
  min-width: 5ch;
}

  /* Spalten: Gewicht | Flags nebeneinander, Kommentar darunter ueber volle Breite */
  .doctor-view .col-special{
    grid-template-columns: minmax(110px, max-content) 1fr; /* Flags bekommen flex Breite */
    column-gap: 12px;
  }
  .doctor-view .col-special > .notes{
    grid-column: 1 / -1; /* Kommentar ueber beide Spalten */
  }

  /* Kommentar: mobil 4 Zeilen anzeigen */
  .doctor-view .notes{
    -webkit-line-clamp: 4; /* bei Bedarf auf 5 erhoehen */
  }

  /* Flags: kompakt in 2 Spalten, keine abgeschnittenen Labels */
  .doctor-view .flags{
    display: grid;
    grid-template-columns: repeat(2, max-content);
    justify-content: start;
    align-items: center;
    column-gap: 14px;
    row-gap: 6px;
    margin-top: 6px;
  }
  .doctor-view .flag span:last-child{ white-space: nowrap; }
}

/* Extra-eng ( 390px Breite) */
@media (max-width: 390px){
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(66px, 1fr) repeat(4, minmax(50px, 1fr));
  }
  .doctor-view .flags{
    grid-template-columns: repeat(3, max-content);
  }
}

/* Panels */
.panel{position:fixed;right:8px;bottom:8px;max-height:80vh;overflow:auto;background:#0f1116;border:1px solid #2b2f3a;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.35);display:none;z-index:9998}
/* Panel (Charts) - Fullscreen */
.panel.chart{
  inset: 0;                 /* volle Flaeche (top/right/bottom/left = 0) */
  width: 100vw;
  height: 100dvh;           /* korrekt auf Mobile (sichtbare Hoehe) */
  max-width: 100vw;
  max-height: 100dvh;
  border-radius: 0;         /* keine abgerundeten Ecken im Vollbild */
}

/* Flex-Layout: Header fix oben, Inhalt fuellt Rest */
.panel.chart{
  /* Sichtbarkeit steuert JS; NICHT auf block setzen */
}
.panel.chart header{ 
  /* bleibt oben, keine Aenderung noetig - aber fixere Hoehe ist hilfreich */
  min-height: 44px;
}
.panel.chart .content{
  /* Inhalt fuellt den verfuegbaren Raum */
  height: calc(100dvh - 44px - 2px); /* 44px Header + 1px border oben/unten */
  display: flex;
  flex-direction: column;
  overflow: auto;
}
.panel header{display:flex;gap:6px;align-items:center;justify-content:space-between;padding:8px;border-bottom:1px solid #2b2f3a}
.panel h4{margin:0;font-size:14px}
.panel .content{
  padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) 
           max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
  font-size: 13px;
  line-height: 1.45;
}
#diag pre{margin:0;padding:8px;font-size:12px;white-space:pre-wrap}

/* FABs */
.fab-wrap{position:fixed;right:8px;bottom:8px;display:flex;flex-direction:column;gap:8px;z-index:9999}
.fab{width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;border:1px solid #2b2f3a;background:#0f1116;cursor:pointer}
.fab:hover{box-shadow:0 8px 24px rgba(0,0,0,.35)}

/* Chart panel */
#chart .controls{
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  margin-bottom:6px;
}
/* ANKER: flags-overlay CSS */
#chartSvg .flags { pointer-events: auto; }
#chart .controls > * {flex:1}
#chart .controls .half{flex:0 0 calc(50% - 4px)}
  
  /* SVG fuellt verbleibende Hoehe vollstaendig */
#chart svg{
  flex: 1 1 auto;
  width: 100%;
  height: 100%;     /* statt auto */
  min-height: 160px;
  display: block;
  background: #0f1116;
  border: 1px solid #2b2f3a;
  border-radius: 10px;
}

#chart .legend{display:flex;gap:10px;font-size:12px;color:var(--muted);margin-top:6px;flex-wrap:wrap}

.dot{width:8px;height:8px;border-radius:50%;display:inline-block;margin-right:6px;border:1px solid #000}

/* Busy overlay */
#busy{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);z-index:99998}
#busy .box{background:#10131a;border:1px solid #2b2f3a;border-radius:12px;padding:12px 16px;font-weight:600}

.seg{display:flex;gap:8px;margin:8px 0 12px}
.seg .seg-btn.active{background:var(--accent);color:#fff}
.hidden{display:none!important}
:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

/* App-Lock Overlay */
#appLock{
  position: fixed; inset: 0; z-index: 10001;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.45); backdrop-filter: blur(2px);
}
#appLock .lock-card{
  width: min(420px, 92vw);
  background: #fff; color: #111;
  border-radius: 16px; padding: 18px;
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
  border: 1px solid #e5e7eb;
}
#appLock .lock-card h3{ margin: 0 0 6px; }
#appLock .btn.primary{ background: var(--accent); color: #fff; }
#appLock .pin-wrap{ display:flex; gap:8px; margin-top:8px; }
#appLock .pin-wrap input{
  flex:1; background:#f8fafc; color:#111; border:1px solid #e5e7eb;
}

/* Body-State: solange gelockt ist, Interaktion sperren (Overlay deckt ohnehin ab) */
body.app-locked main, body.app-locked nav, body.app-locked header{
  filter: blur(0); /* bewusst ohne Blur, nur visuelles Dimmen optional */
}
body.app-locked { pointer-events: auto; } /* Overlay nimmt Events ab */

/* Login-Overlay */
#loginOverlay{

  position: fixed; inset: 0; z-index: 10000;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.35); backdrop-filter: blur(2px);
}
#loginOverlay .login-card{
  width: min(420px, 92vw);
  background: #fff; color: #111;
  border-radius: 16px; padding: 18px;
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
  border: 1px solid #e5e7eb;
}
#loginOverlay .login-card h3{ margin: 0 0 6px; }
  #loginOverlay .btn.primary{ background: var(--accent); color: #fff; }
  
/* Lifestyle: Progress Bars */
.progress{ position: relative; height:16px; background:#0f1116; border:1px solid #2b2f3a; border-radius:10px; overflow:hidden; margin-top:6px }
.progress .bar{ position:absolute; inset:0 auto 0 0; width:0%; background:var(--accent); transition: width .25s ease; }
.progress .label{ position:relative; z-index:1; text-align:center; font-size:12px; color:var(--muted); line-height:16px }
.progress.ok   .bar{ background: var(--ok); }
.progress.warn .bar{ background: var(--warn); }
.progress.bad  .bar{ background: var(--danger); }
.progress.neutral .bar{ background: var(--muted); }

</style>
</head>
<body>
<!-- ANKER: touch-log-fallback -->
<pre id="touchLog" style="display:none;position:fixed;bottom:0;left:0;right:0;max-height:40vh;overflow:auto;background:#111;color:#eee;font-size:12px;padding:4px;z-index:10000"></pre>

<header>
<div style="display:flex;align-items:center;gap:10px">
<h1>Gesundheits-Logger</h1><span class="small">V1.4.5</span>
<div class="spacer"></div>
<button class="btn ghost" id="helpToggle" type="button">Hilfe</button>
<button class="btn ghost" id="diagToggle" type="button">Log</button>
</div>
</header>

<nav class="tabs">
<button class="btn ghost" data-tab="capture" id="tab-capture" type="button">Erfassen</button>
<button class="btn ghost" data-tab="doctor" id="tab-doctor" type="button">Arzt-Ansicht</button>
<button class="btn ghost" data-tab="lifestyle" id="tab-lifestyle" type="button">Lifestyle</button>
</nav>

<!-- Hilfe-Panel -->
<div id="help" class="panel" role="dialog" aria-modal="false" aria-labelledby="helpTitle">
<header>
<h4 id="helpTitle">Hilfe * Was soll ich ankreuzen?</h4>
<button class="btn ghost" id="helpClose" type="button">x</button>
</header>
<div class="content">
<strong>&#x1F489; NSAR genommen</strong> ankreuzen, wenn du ein Schmerz-/Entzuendungsmedikament der Klasse NSAR genommen hast.
<ul>
<li><em>Beispiele (AT, frei):</em> Ibuprofen, Diclofenac, Naproxen.</li>
<li><em>Kombo-Achtung:</em> Viele "Erkaeltungs-/Kopfweh"-Mittel enthalten NSAR.</li>
<li><em>Bei Nierenkrankheit:</em>NSAR moeglichst vermeiden, Alternativen mit Arzt besprechen.</li>
</ul>
</div>
</div>

<!-- Diagnose-Panel -->
<div id="diag" class="panel" role="dialog" aria-modal="false" aria-labelledby="diagTitle">
<header>
<h4 id="diagTitle">Touch-Log</h4>
<button class="btn ghost" id="diagClose" type="button">x</button>
</header>
<pre id="diagLog" class="content" style="margin:0"></pre>
</div>

<!-- Diagramm-Panel (Daily) -->
<div id="chart" class="panel chart" role="dialog" aria-modal="false" aria-labelledby="chartTitle">
<header>
<h4 id="chartTitle">Diagramm (Daily)</h4>
<button class="btn ghost" id="chartClose" type="button">x</button>
</header>
<div class="content">
<div class="controls">
<select id="metricSel" class="half compact" aria-label="Messgroesse auswaehlen">
    <option value="bp">Blutdruck (Sys/Dia)</option>
    <option value="weight">Koerper</option>
</select>

  <!-- ANKER: chart-averages (Daily) -->
  <div id="chartAverages" class="kpis" aria-live="polite">
    <span data-k="sys">Durchschnitt Sys: -</span>
    <span class="sep" aria-hidden="true">*</span>
    <span data-k="dia">Durchschnitt Dia: -</span>
    <span class="sep" aria-hidden="true">*</span>
    <span data-k="map">Durchschnitt MAP: -</span>
  </div>
</div>

<svg id="chartSvg" viewBox="0 0 640 280" preserveAspectRatio="none" role="img" aria-label="Werteverlauf"></svg>
<div class="legend" id="chartLegend"></div>
<div class="small" style="opacity:.7;margin-top:6px">Zeitraum: nutzt die <em>Arzt-Ansicht</em> (von/bis).</div>
</div>
</div>

<div id="err" role="status" aria-live="polite"></div>
<div id="busy"><div class="box"> Bitte warten...</div></div>

<main>
<!-- Capture -->
<section class="view active" id="capture">
 
  <!-- Daily-Capture -->
  <section class="card" id="entry">
    <div class="row">
      <div style="flex:1">
        <label>Datum</label>
        <input type="date" id="date">
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Morgens</h3>
      <div class="grid">
        <div><label>Systolisch (mmHg)</label><input type="number" id="sysM" inputmode="numeric" placeholder="z. B. 128"></div>
        <div><label>Diastolisch (mmHg)</label><input type="number" id="diaM" inputmode="numeric" placeholder="z. B. 82"></div>
        <div><label>Puls (bpm)</label><input type="number" id="pulseM" inputmode="numeric" placeholder="z. B. 66"></div>
      </div>
      <div class="row" style="margin-top:6px">
        <textarea id="bpCommentM" class="small" placeholder="Kommentar Morgens (optional)"></textarea>
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Abends</h3>
      <div class="grid">
        <div><label>Systolisch (mmHg)</label><input type="number" id="sysA" inputmode="numeric" placeholder="z. B. 128"></div>
        <div><label>Diastolisch (mmHg)</label><input type="number" id="diaA" inputmode="numeric" placeholder="z. B. 82"></div>
        <div><label>Puls (bpm)</label><input type="number" id="pulseA" inputmode="numeric" placeholder="z. B. 66"></div>
      </div>
      <div class="row" style="margin-top:6px">
        <textarea id="bpCommentA" class="small" placeholder="Kommentar Abends (optional)"></textarea>
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      
<h3 class="blockTitle">Koerper</h3>
<div class="grid" style="grid-template-columns:1fr 1fr">
  <div>
    <label>Gewicht (kg)</label>
    <input type="number" step="0.1" id="weightDay" inputmode="decimal" placeholder="z. B. 84.2">
  </div>
  <div>
    <label>Bauchumfang (cm)</label>
    <input id="input-waist-cm" type="text" inputmode="decimal" autocomplete="off" placeholder="z. B. 104,5" />
  </div>
</div>
</div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Kommentar</h3>
      <div class="row">
        <div style="flex:1">
          <textarea id="notesDay" placeholder="Allgemeiner Kommentar zum Tag (optional)"></textarea>
        </div>
      </div>
    </div>

    <div class="row" style="align-items:center; gap:8px; margin-top:4px">
      <button class="btn toggle" id="trainingToggle" type="button" aria-pressed="false">&#x1F3CB;&#xFE0F; Training heute</button>
      <button class="btn toggle" id="sickToggle" type="button" aria-pressed="false">&#x1F912; Krank (Forxiga pausiert)</button>
      <button class="btn toggle" id="valsartanMissToggle" type="button" aria-pressed="false">&#x1F48A; Valsartan vergessen</button>
      <button class="btn toggle" id="forxigaMissToggle" type="button" aria-pressed="false">&#x23F0; Forxiga vergessen</button>
      <button class="btn toggle" id="lowIntakeToggle" type="button" aria-pressed="false">&#x1F4A7; &lt; 2 L getrunken</button>
      <button class="btn toggle" id="saltHighToggle" type="button" aria-pressed="false" title="> 5 g Salz">&#x1F9C2; &gt; 5 g Salz</button>
      <button class="btn toggle" id="sugarHighToggle" type="button" aria-pressed="false" title="> 10 g Zucker">&#x1F36C; &gt; 10 g Zucker</button>
      <button class="btn toggle" id="nsarToggle" type="button" aria-pressed="false" title="Nicht-steroidale Antirheumatika">&#x1F489; NSAR genommen</button>
      <div class="spacer"></div>
    </div>

    <div class="row" style="margin-top:8px">
      <div style="flex:1">
        <label>Kommentar zu Flags</label>
        <textarea id="flagsComment" placeholder="Kommentar zu Flags (optional)" rows="2"></textarea>
      </div>
    </div>

    <div class="row" style="align-items:center; gap:8px; margin-top:12px">
      <button class="btn primary" id="saveAllBtn" type="button">&#x1F4BE; Speichern</button>
      <div class="spacer"></div>
    </div>
  </section>
</section>

<!-- Lifestyle (Heute) -->
<section class="view" id="lifestyle">
  <section class="card" id="lifestyleCard">
    <strong style="display:block;margin-bottom:8px">Lifestyle Intake (heute)</strong>

    <div class="row">
      <div style="flex:1;min-width:180px">
        <label>Wasser hinzufuegen (ml)</label>
        <input type="number" id="ls-water-add" min="0" step="50" inputmode="numeric" placeholder="z. B. 250">
      </div>
      <div style="width:140px;align-self:flex-end">
        <button class="btn primary" id="ls-water-add-btn" type="button">+ Menge</button>
      </div>
    </div>
    <div class="progress" id="ls-water-prog" aria-label="Wasser Fortschritt">
      <div class="bar" id="ls-water-bar"></div>
      <div class="label" id="ls-water-label">0 / 2000 ml</div>
    </div>

    <div class="row" style="margin-top:12px">
      <div style="flex:1;min-width:180px">
        <label>Salz hinzufuegen (g)</label>
        <input type="text" id="ls-salt-add" inputmode="decimal" autocomplete="off" placeholder="z. B. 0,5">
      </div>
      <div style="width:140px;align-self:flex-end">
        <button class="btn primary" id="ls-salt-add-btn" type="button">+ Menge</button>
      </div>
    </div>
    <div class="progress" id="ls-salt-prog" aria-label="Salz Fortschritt">
      <div class="bar" id="ls-salt-bar"></div>
      <div class="label" id="ls-salt-label">0,0 / 6,0 g</div>
    </div>

    <div class="row" style="margin-top:12px">
      <div style="flex:1;min-width:180px">
        <label>Protein hinzufuegen (g)</label>
        <input type="text" id="ls-protein-add" inputmode="decimal" autocomplete="off" placeholder="z. B. 20,0">
      </div>
      <div style="width:140px;align-self:flex-end">
        <button class="btn primary" id="ls-protein-add-btn" type="button">+ Menge</button>
      </div>
    </div>
    <div class="progress" id="ls-protein-prog" aria-label="Protein Fortschritt">
      <div class="bar" id="ls-protein-bar"></div>
      <div class="label" id="ls-protein-label">0,0 / 90,0 g</div>
    </div>

    <div class="small" style="opacity:.75;margin-top:10px">
      Ziele: Wasser 2000 ml * Salz max. 6 g * Protein Ziel 90 g (gruen bei 78-89 g)
    </div>
  </section>
  <div class="small" style="margin-top:6px;opacity:.7">Hinweis: nur der heutige Intake wird gespeichert und synchronisiert.</div>
</section>

<!-- Doctor -->
<section class="view" id="doctor">
  <section class="card" id="doctorCard">
    <div class="toolbar">
      <strong id="doctorTitle">Arzt-Ansicht</strong>

      <div class="center-group">
        <label class="small">Von <input type="date" id="from" style="width:auto"></label>
        <label class="small">Bis <input type="date" id="to" style="width:auto"></label>
        <button class="btn ghost" id="applyRange" type="button">Anwenden</button>
        <button class="btn ghost" id="doctorChartBtn" type="button" title="Werte als Grafik">Werte anzeigen</button>
        <button class="btn ghost" id="doctorExportJson" type="button">Export JSON</button>
      </div>

      <span id="docTrainCnt" class="badge good" title="Anzahl Tage mit Training im Zeitraum"> Trainingstage: <span class="val">0</span></span>
      <span id="docBadCnt" class="badge bad" title="Anzahl Tage mit mind. einem Bad-Flag"> Tage mit Bad-Flag: <span class="val">0</span></span>
    </div> <!--  Toolbar sauber schliessen -->

    <div style="overflow:auto" id="doctorDailyWrap">
      <div class="doctor-view" id="doctorView"></div>
    </div>

        <div class="small" style="margin-top:6px">
      Tipp: "Werte anzeigen" oeffnet die passende Grafik zum aktuellen Tab (Daily).
    </div>
  </section>
</section>

<!-- Supabase (UMD, v2) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

<script>
/* ===== Supabase Defaults (ANON only - niemals service_role!) ===== */
const SUPABASE_URL_DEFAULT = "https://jlylmservssinsavlkdi.supabase.co";
const SUPABASE_ANON_DEFAULT = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpseWxtc2VydnNzaW5zYXZsa2RpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNTQ2NjAsImV4cCI6MjA3MDgzMDY2MH0.4BpnwDJAlPohSYLfNcaEJfxQNvlHBbMvxVcCOAWpkFA";
const DEFAULT_WEBHOOK_ENTRIES = `${SUPABASE_URL_DEFAULT}/rest/v1/health_events`;

/* ===== Fehlerbox ===== */
window.addEventListener('unhandledrejection', (e)=>{
const box = document.getElementById('err');
box.style.display='block';
box.textContent = 'Fehler: ' + (e.reason?.message || e.reason || 'Unbekannter Fehler');
});

/* ===== Diagnostics ===== */
const perfStats = (() => {
const buckets = Object.create(null);
const add = (k, ms) => (buckets[k] ??= []).push(ms);
const pct = (arr, p) => {
if (!arr.length) return 0;
const a = [...arr].sort((x,y)=>x-y);
const i = Math.ceil((p/100)*a.length)-1;
return a[Math.max(0, Math.min(i, a.length-1))];
};
const snap = (k) => {
const arr = buckets[k] || [];
return { count: arr.length, p50: pct(arr,50), p95: pct(arr,95), p99: pct(arr,99) };
};
return { add, snap };
})();

const diag = { el:null, logEl:null, open:false, lines:[],
add(msg){ const t=new Date().toLocaleTimeString(); this.lines.unshift(`[${t}] ${msg}`); this.lines=this.lines.slice(0,80); if(this.logEl) this.logEl.textContent = this.lines.join('\n'); },
init(){ this.el=document.getElementById('diag'); this.logEl=document.getElementById('diagLog');
const t1=document.getElementById('diagToggle'); const t2=document.getElementById('diagToggleFab');
const close=document.getElementById('diagClose');
const toggle=()=>{ this.open=!this.open; this.el.style.display=this.open?'block':'none'; };
t1.addEventListener('click', toggle);
if (t2) t2.addEventListener('click', toggle);
close.addEventListener('click', ()=>{ this.open=false; this.el.style.display='none'; });
}
};

/* ===== Help panel ===== */
const helpPanel={ el:null, open:false,
init(){ this.el=document.getElementById('help');
const t1=document.getElementById('helpToggle'); const t2=document.getElementById('helpToggleFab'); const close=document.getElementById('helpClose');
const toggle=()=>{ this.open=!this.open; this.el.style.display=this.open?'block':'none'; };
t1.addEventListener('click', toggle);
if (t2) t2.addEventListener('click', toggle);
close.addEventListener('click', ()=>{ this.open=false; this.el.style.display='none'; });
}
};

/* ===== Helpers ===== */
  // --- Debounce ---
function debounce(fn, wait=250){
  let t = null;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
}
// UI-Refresh: rendert nur, wenn Arzt-Ansicht sichtbar; Chart nur wenn offen
const requestUiRefresh = debounce(async (reason = '') => {
  try{
    const doctorActive = document.getElementById('doctor')?.classList?.contains('active');
    if (doctorActive) await renderDoctor();
    const lifestyleActive = document.getElementById('lifestyle')?.classList?.contains('active');
    if (lifestyleActive && typeof renderLifestyle === 'function') await renderLifestyle();
    if (chartPanel?.open) await chartPanel.draw();
  }catch(e){ /* still ok */ }
}, 250);

// kleines visuelles Ping bei Realtime
function livePulse(){
  const el = document.getElementById('doctorLive');
  if (!el) return;
  el.classList.add('pulse');
  setTimeout(() => el.classList.remove('pulse'), 900);
}

// --- Service-Role-Schutz (NIEMALS im Browser) ---
function isServiceRoleKey(raw){
  const tok = String(raw||"").trim().replace(/^Bearer\s+/i,'');
  try{
    const payload = JSON.parse(atob(tok.split('.')[1].replace(/-/g,'+').replace(/_/g,'/')));
    return payload?.role === 'service_role';
  }catch{
    return false; // Fallback: lieber konservativ sein
  }
}

// ANKER: sb-rest
async function sbSelect({ table, select, filters = [], order = null, limit = null }) {
  // Basis-URL aus gespeicherter REST-URL ableiten (z. B. .../rest/v1/health_events)
  const restUrl = await getConf("webhookUrl");
  const base    = baseUrlFromRest(restUrl) || SUPABASE_URL_DEFAULT;
  if (!base) throw new Error("REST-Basis fehlt");

  const url = new URL(`${base}/rest/v1/${table}`);
  if (select) url.searchParams.set('select', select);
  for (const [k, v] of filters) url.searchParams.set(k, v);
  if (order) url.searchParams.set('order', order);
  if (limit) url.searchParams.set('limit', String(limit));

  // WICHTIG: mit User-JWT lesen (RLS)!
  const headers = await getHeaders();
  if (!headers) throw new Error("Nicht angemeldet - keine Leseberechtigung.");

  const res = await withRetry(() => fetch(url.toString(), { headers }));
  if (!res.ok) {
    let details = '';
    try { const e = await res.json(); details = e?.message || e?.details || ''; } catch {}
    throw new Error(`REST ${table} failed ${res.status} - ${details}`);
  }
  return await res.json();
}
  
// ANCHOR: num-helper-de
function toNumDE(s) {
  if (s == null) return null;
  const v = String(s).trim();
  if (!v) return null;
  const n = parseFloat(v.replace(',', '.'));
  return Number.isFinite(n) ? n : null;
}

// ANKER: ui-utils
function uiError(msg) {
  const box = document.getElementById('err');
  if (box) {
    box.setAttribute('role','status');
    box.setAttribute('aria-live','polite');
    box.textContent = String(msg || 'Fehler');
    box.style.display = 'block';
    setTimeout(()=>{ box.style.display='none'; }, 5000);
  } else {
    alert(msg);
  }
}

function uiInfo(msg) {
  const box = document.getElementById('err');
  if (box) {
    box.setAttribute('role','status');
    box.setAttribute('aria-live','polite');
    box.textContent = String(msg || 'OK');
    box.style.display = 'block';
    setTimeout(()=>{ box.style.display='none'; }, 2000);
  } else {
    console.log(msg);
  }
}

function withBusy(el, on=true){
  if (!el) return;
  el.disabled = !!on;
  el.classList.toggle('is-busy', !!on);
}
  
/* ===== Auth-Guard ===== */
async function isLoggedIn(){
try{
if(!sbClient) return false;
const { data:{ session } } = await sbClient.auth.getSession();
return !!session;
}catch{ return false; }
}

/** Schaltet optisch auf "gesperrt" - ohne Controls hart zu deaktivieren */
function setAuthGuard(logged){
  // Nur visuelles Dimmen; die Save-Logik prueft isLoggedIn() ohnehin.
  document.body.classList.toggle('auth-locked', !logged);
  // Kein auto-boot mehr hier - Start erfolgt in main()/watchAuthState.
}

function setDoctorAccess(enabled){
  // Tab-Button
  const tabBtn = document.getElementById('tab-doctor');
  if (tabBtn){
    tabBtn.disabled = !enabled;
    tabBtn.classList.toggle('ghost', !enabled);
    tabBtn.title = enabled ? '' : 'Bitte zuerst anmelden';
  }
  // "Werte anzeigen"-Button
  const chartBtn = document.getElementById('doctorChartBtn');
  if (chartBtn){
    chartBtn.disabled = !enabled;
    chartBtn.title = enabled ? 'Werte als Grafik' : 'Bitte zuerst anmelden';
  }
  // Lifestyle-Tab mitsteuern
  const lifeBtn = document.getElementById('tab-lifestyle');
  if (lifeBtn){
    lifeBtn.disabled = !enabled;
    lifeBtn.classList.toggle('ghost', !enabled);
    lifeBtn.title = enabled ? '' : 'Bitte zuerst anmelden';
  }
}
  
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const fmtNum = (n, d=1) => (n===null||n===undefined||isNaN(n)) ? "" : Number(n).toFixed(d);
const pad2 = n => n.toString().padStart(2,'0');
const todayStr = () => { const d = new Date(); const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; };
const timeStr = () => { const d = new Date(); return pad2(d.getHours())+":"+pad2(d.getMinutes()); };
function esc(s){ return String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function nl2br(s){ return esc(s).replace(/\n/g, "<br>"); }
function calcMAP(sys, dia){ if (sys==null || dia==null) return null; return Number(dia) + (Number(sys)-Number(dia))/3; }
  // === Mapping: lokaler Erfassungseintrag -> 0..N health_events ===
// Erzeugt pro Eingabe die noetigen Events (bp/body/day_flags/note)
function toHealthEvents(entry){
  const tsIso = entry.dateTime; // ISO Timestamp des Eintrags
  const out = [];

  // 1) Blutdruck-Messungen (Morgen/Abend)
  if (entry.context === "Morgen" || entry.context === "Abend"){
    const hasVitals = (entry.sys != null) || (entry.dia != null) || (entry.pulse != null);
    if (hasVitals){
      const payload = {};
      if (entry.sys   != null) payload.sys   = Number(entry.sys);
      if (entry.dia   != null) payload.dia   = Number(entry.dia);
      if (entry.pulse != null) payload.pulse = Number(entry.pulse);
      payload.ctx = entry.context; // "Morgen" | "Abend"
      out.push({ ts: tsIso, type: "bp", payload });
    }
  }

  // 2) Tageszusammenfassung (Gewicht, Bauchumfang, Flags, Kommentar)
  if (entry.context === "Tag"){
    // body (Gewicht + Bauchumfang)
    const hasBody = (entry.weight != null) || (entry.waist_cm != null);
    if (hasBody){
      const payload = {};
      if (entry.weight   != null) payload.kg = Number(entry.weight);
      if (entry.waist_cm != null) payload.cm = Number(entry.waist_cm);
      out.push({ ts: tsIso, type: "body", payload });
    }

    // day_flags (alle Booleans)
    const flags = {
      training:         !!entry.training,
      sick:             !!entry.sick,
      low_intake:       !!entry.low_intake,
      salt_high:        !!entry.salt_high,
      protein_high90:   !!entry.protein_high90,
      valsartan_missed: !!entry.valsartan_missed,
      forxiga_missed:   !!entry.forxiga_missed,
      nsar_taken:       !!entry.nsar_taken,
    };
    const anyFlag = Object.values(flags).some(Boolean);
    if (anyFlag){
      out.push({ ts: tsIso, type: "day_flags", payload: flags });
    }

    // note (optional, 1 Zeile Text)
    const note = (entry.notes || "").trim();
    if (note){
      out.push({ ts: tsIso, type: "note", payload: { text: note } });
    }
  }

  return out;
}

// "Legacy": Measurement Eintrag, der nur Gewicht enthaelt
function isWeightOnly(e){
const hasVitals = !!(e?.sys || e?.dia || e?.pulse);
return !hasVitals && (e?.weight != null);
}

function setBusy(on){
document.body.classList.toggle('is-busy', !!on);
const b = document.getElementById('busy');
if (b) b.style.display = on ? 'flex' : 'none';
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function softWarnRange(el, min, max){
const v = Number(el.value);
if (!isNaN(v) && (v < min || v > max)) {
el.style.outline = '2px solid var(--warn)';
} else {
el.style.outline = '';
}
}

/* ===== IndexedDB ===== */
let db;
const DB_NAME = "healthlog_db";
const STORE   = "entries";
const CONF    = "config";

function initDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, 5);

    req.onupgradeneeded = (e)=>{
      db = e.target.result;
      // entries
      if(!db.objectStoreNames.contains(STORE)){
        const s = db.createObjectStore(STORE,{ keyPath:"id", autoIncrement:true });
        s.createIndex("byDateTime","dateTime",{unique:false});
        s.createIndex("byRemote","remote_id",{unique:false});
      } else {
        const s = e.target.transaction.objectStore(STORE);
        try{ s.createIndex("byDateTime","dateTime",{unique:false}); }catch(_){}
        try{ s.createIndex("byRemote","remote_id",{unique:false}); }catch(_){}
      }
      // config
      if(!db.objectStoreNames.contains(CONF)){
        db.createObjectStore(CONF,{ keyPath:"key" });
      }
    };

    req.onsuccess = (e)=>{
      db = e.target.result;
      db.onversionchange = ()=> db?.close?.();
      resolve();
    };
    req.onerror = ()=> reject(req.error || new Error("IndexedDB open failed"));
  });
}

/* --- IDB Helpers (global) --- */
function putConf(key, value){
  return new Promise((res,rej)=>{
    const tx = db.transaction(CONF,"readwrite");
    tx.objectStore(CONF).put({key, value});
    tx.oncomplete = ()=>res();
    tx.onerror = (e)=>rej(e);
  });
}
function getConf(key){
  return new Promise((res,rej)=>{
    const tx = db.transaction(CONF,"readonly");
    const rq = tx.objectStore(CONF).get(key);
    rq.onsuccess = ()=> res(rq.result?.value ?? null);
    rq.onerror   = (e)=> rej(e);
  });
}
function addEntry(obj){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    const rq = tx.objectStore(STORE).add(obj);
    rq.onsuccess = ()=> res(rq.result);
    rq.onerror   = (e)=> rej(e);
  });
}
function updateEntry(id, patch){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    const store = tx.objectStore(STORE);
    const get = store.get(id);
    get.onsuccess = ()=>{
      const cur = get.result; if(!cur){ res(false); return; }
      store.put(Object.assign({}, cur, patch));
    };
    tx.oncomplete = ()=> res(true);
    tx.onerror    = (e)=> rej(e);
  });
}
function getAllEntries(){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readonly");
    const rq = tx.objectStore(STORE).getAll();
    rq.onsuccess = ()=> res(rq.result || []);
    rq.onerror   = (e)=> rej(e);
  });
}
function getEntryByRemoteId(remoteId){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readonly");
    const idx = tx.objectStore(STORE).index("byRemote");
    const rq  = idx.getAll(remoteId);
    rq.onsuccess = ()=> res(rq.result?.[0] ?? null);
    rq.onerror   = (e)=> rej(e);
  });
}
function deleteEntryLocal(id){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    tx.objectStore(STORE).delete(id);
    tx.oncomplete = ()=> res();
    tx.onerror    = (e)=> rej(e);
  });
}

/* ===== Remote (Supabase REST) ===== */
async function getHeaders(){
  const key = await getConf("webhookKey");
  if (!key) { try{ diag.add?.('Headers: kein Key (webhookKey)'); }catch(_){} return null; }
  if (isServiceRoleKey(key)) { try{ diag.add?.('Headers: service_role Key blockiert'); }catch(_){} return null; }
  const anonKey = key.replace(/^Bearer\s+/i, "");

  const supa = await ensureSupabaseClient();
  if (!supa) { try{ diag.add?.('Headers: Supabase-Client fehlt'); }catch(_){} return null; }

  const { data: { session } } = await supa.auth.getSession();
  const jwt = session?.access_token;
  if (!anonKey || !jwt) { try{ diag.add?.('Headers: fehlende Session/JWT'); }catch(_){} return null; }

  return {
    "Content-Type": "application/json",
    "apikey": anonKey,
    "Authorization": `Bearer ${jwt}`,
    "Prefer": "return=representation"
  };
}

async function deleteRemote(remote_id){
const url = await getConf("webhookUrl");
const headers = await getHeaders();
if(!url || !headers || !remote_id) return {ok:false};
const q = `${url}?id=eq.${encodeURIComponent(remote_id)}`;
try{
const res = await withRetry(()=> fetch(q, { method:"DELETE", headers }));
return {ok: res.ok, status: res.status};
}catch(e){
return {ok:false, status:0};
}
}
  
/* === Lifestyle Intake REST Helpers === */
async function loadIntakeToday({ user_id, dayIso }){
  const from = `${dayIso}T00:00:00Z`;
  const toNext = new Date(from); toNext.setUTCDate(toNext.getUTCDate()+1);
  const toIso = toNext.toISOString().slice(0,10);
  const rows = await sbSelect({
    table: 'health_events',
    select: 'id,day,ts,payload',
    filters: [
      ['user_id', `eq.${user_id}`],
      ['type', 'eq.intake'],
      ['ts', `gte.${from}`],
      ['ts', `lt.${toIso}T00:00:00Z`]
    ],
    order: 'ts.desc',
    limit: 1
  });
  const r = Array.isArray(rows) && rows.length ? rows[0] : null;
  const p = r?.payload || {};
  return {
    id: r?.id ?? null,
    water_ml: Number(p.water_ml || 0),
    salt_g: Number(p.salt_g || 0),
    protein_g: Number(p.protein_g || 0)
  };
}

async function saveIntakeTotals({ dayIso, totals }){
  const url = await getConf('webhookUrl');
  const headers = await getHeaders();
  const uid = await getUserId();
  if (!url || !headers || !uid) throw new Error('saveIntakeTotals: missing config/auth');
  const nowIso = new Date().toISOString();
  const payload = [{ ts: nowIso, type: 'intake', payload: totals, user_id: uid }];
  const res = await withRetry(async ()=>{
    const r = await fetch(url, { method:'POST', headers, body: JSON.stringify(payload) });
    if (!r.ok && r.status === 404) {
      const body = await r.text();
      diag.add?.(`Lifestyle POST 404 body: ${body}`);
    }
    return r;
  });
  if (res.ok) return await res.json();

  // Conflict  PATCH (Upsert)
  let details = '';
  try { const e = await res.json(); details = e?.message || e?.details || ''; } catch{}
  if (res.status === 409 || /duplicate|unique/i.test(details)){
    const toNext = new Date(`${dayIso}T00:00:00Z`); toNext.setUTCDate(toNext.getUTCDate()+1);
    const toIso = toNext.toISOString().slice(0,10);
    const q = `${url}?user_id=eq.${encodeURIComponent(uid)}&type=eq.intake`+
              `&ts=gte.${encodeURIComponent(dayIso)}T00:00:00Z&ts=lt.${encodeURIComponent(toIso)}T00:00:00Z`;
    const res2 = await withRetry(()=> fetch(q, { method:'PATCH', headers, body: JSON.stringify({ payload: totals }) }));
    if (!res2.ok){
      let d2='';
      try{ const e2 = await res2.json(); d2 = e2?.message || e2?.details || ''; }catch{}
      throw new Error(`intake-patch-failed ${res2.status} ${d2}`);
    }
    return await res2.json();
  }
  throw new Error(`intake-post-failed ${res.status}`);
}

async function cleanupOldIntake(){
  try{
    const url = await getConf('webhookUrl');
    const headers = await getHeaders();
    const uid = await getUserId();
    if (!url || !headers || !uid) return;
    const today = todayStr();
    const q = `${url}?user_id=eq.${encodeURIComponent(uid)}&type=eq.intake`+
              `&ts=lt.${encodeURIComponent(today)}T00:00:00Z`;
    await withRetry(()=> fetch(q, { method:'DELETE', headers }));
  }catch(_){ /* non-blocking */ }
}

/* === Remote-Fetch Arzt-Ansicht (Views) === */
async function loadBpFromView({ user_id, from, to }) {
  const filters = [['user_id', `eq.${user_id}`]];
  if (from) filters.push(['day', `gte.${from}`]);
  if (to)   filters.push(['day', `lte.${to}`]);
  return await sbSelect({
    table: 'v_events_bp',
    select: 'day,ctx,sys,dia,pulse',
    filters,
    order: 'day.asc'
  });
}

async function loadBodyFromView({ user_id, from, to }) {
  const filters = [['user_id', `eq.${user_id}`]];
  if (from) filters.push(['day', `gte.${from}`]);
  if (to)   filters.push(['day', `lte.${to}`]);
  return await sbSelect({
    table: 'v_events_body',
    select: 'day,kg,cm',
    filters,
    order: 'day.asc'
  });
}

async function loadFlagsFromView({ user_id, from, to }) {
  const filters = [['user_id', `eq.${user_id}`]];
  if (from) filters.push(['day', `gte.${from}`]);
  if (to)   filters.push(['day', `lte.${to}`]);
  return await sbSelect({
    table: 'v_events_day_flags',
    select: 'day,training,sick,low_intake,salt_high,protein_high90,valsartan_missed,forxiga_missed,nsar_taken',
    filters,
    order: 'day.asc'
  });
}

// Sync capture toggles with existing day flags from the cloud for the selected date
async function syncCaptureFlagTogglesForCurrentDate(){
  try{
    if (!(await isLoggedIn())) return;
    const dateEl = document.getElementById('date');
    const dayIso = dateEl?.value;
    if (!dayIso) return;
    const user_id = await getUserId();
    if (!user_id) return;
    const rows = await loadFlagsFromView({ user_id, from: dayIso, to: dayIso });
    const r = Array.isArray(rows) && rows.length ? rows[0] : null;
    // Apply or clear
    const f = r || { training:false, sick:false, low_intake:false, salt_high:false, protein_high90:false, valsartan_missed:false, forxiga_missed:false, nsar_taken:false };
    setTraining(!!f.training);
    setSick(!!f.sick);
    setLowIntake(!!f.low_intake);
    setSaltHigh(!!f.salt_high);
    setProteinHigh(!!f.protein_high90);
    setValsartanMiss(!!f.valsartan_missed);
    setForxigaMiss(!!f.forxiga_missed);
    setNsar(!!f.nsar_taken);
    const commentM = document.getElementById("bpCommentM");
    if (commentM) commentM.value = "";
    const commentA = document.getElementById("bpCommentA");
    if (commentA) commentA.value = "";
    const flagsCommentEl = document.getElementById("flagsComment");
    if (flagsCommentEl) flagsCommentEl.value = "";
  }catch(_){ /* non-blocking */ }
}

/* Optional: Notes (aus health_events, falls keine View v_events_note existiert) */
async function loadNotesLastPerDay({ user_id, from, to }) {
  const filters = [['user_id', `eq.${user_id}`], ['type', 'eq.note']];
  if (from) filters.push(['day', `gte.${from}`]);
  if (to)   filters.push(['day', `lte.${to}`]);
  const rows = await sbSelect({
    table: 'health_events',
    select: 'day,ts,payload',
    filters,
    order: 'ts.asc',
  });
  const grouped = new Map();
  for (const r of rows) {
    const text = (r?.payload?.text || '').trim();
    if (!text) continue;
    if (!grouped.has(r.day)) grouped.set(r.day, []);
    grouped.get(r.day).push({ ts: r.ts, text });
  }
  const out = [];
  for (const [day, entries] of grouped.entries()) {
    entries.sort((a,b)=> (a.ts||0) - (b.ts||0));
    const lastTs = entries.length ? entries[entries.length-1].ts : null;
    out.push({ day, ts: lastTs, text: entries.map(e=>e.text).join(' ') });
  }
  return out;
}

/* View-Zeilen  Tagesobjekte (kompatibel zu renderDoctor/chartPanel) */
function joinViewsToDaily({ bp, body, flags, notes = [] }) {
  const days = new Map();
  const ensure = (day) => {
    let d = days.get(day);
    if (!d) {
      d = {
        date: day,
        morning: { sys:null, dia:null, pulse:null, map:null },
        evening: { sys:null, dia:null, pulse:null, map:null },
        weight: null,
        waist_cm: null,
        notes: "",
        flags: { water_lt2:false, salt_gt5:false, protein_ge90:false, sick:false, meds:false, training:false },
        remoteIds: [],
        hasCloud: true
      };
      days.set(day, d);
    }
    return d;
  };

  // body (1x/Tag)
  for (const r of body) {
    const d = ensure(r.day);
    if (r.kg != null) d.weight   = Number(r.kg);
    if (r.cm != null) d.waist_cm = Number(r.cm);
  }

  // bp (max 2x/Tag - Morgen/Abend)
  for (const r of bp) {
    const d = ensure(r.day);
    const blk = r.ctx === 'Morgen' ? d.morning : (r.ctx === 'Abend' ? d.evening : null);
    if (blk) {
      if (r.sys   != null) blk.sys   = Number(r.sys);
      if (r.dia   != null) blk.dia   = Number(r.dia);
      if (r.pulse != null) blk.pulse = Number(r.pulse);
      if (blk.sys != null && blk.dia != null) blk.map = calcMAP(blk.sys, blk.dia);
    }
  }

  // flags (1x/Tag)
  for (const r of flags) {
    const d = ensure(r.day);
    d.flags.training   = !!r.training;
    d.flags.sick       = !!r.sick;
    d.flags.water_lt2  = !!r.low_intake;
    d.flags.salt_gt5   = !!r.salt_high;
    d.flags.protein_ge90 = !!r.protein_high90;
    d.flags.meds       = !!(r.valsartan_missed || r.forxiga_missed || r.nsar_taken);
    // Detail-Medikamentenflags (fuer Tooltip)
    d.flags.valsartan_missed = !!r.valsartan_missed;
    d.flags.forxiga_missed   = !!r.forxiga_missed;
    d.flags.nsar_taken       = !!r.nsar_taken;
  }

  // notes: alle Texte eines Tages zusammenfassen
  for (const n of notes) {
    const d = ensure(n.day);
    d.notes = n.text || "";
  }

  return Array.from(days.values()).sort((a,b)=> a.date.localeCompare(b.date));
}

/* Neues fetchDailyOverview: liest direkt aus den Views */
async function fetchDailyOverview(fromIso, toIso){
  const user_id = await getUserId();
  if (!user_id) return [];

  const [bp, body, flags, notes] = await Promise.all([
    loadBpFromView({ user_id, from: fromIso, to: toIso }),
    loadBodyFromView({ user_id, from: fromIso, to: toIso }),
    loadFlagsFromView({ user_id, from: fromIso, to: toIso }),
    loadNotesLastPerDay({ user_id, from: fromIso, to: toIso }) // optional
  ]);

  return joinViewsToDaily({ bp, body, flags, notes });
}

/* Server: alle Events eines Tages loeschen (RLS: nur eigene Records) */
async function deleteRemoteDay(dateIso /*YYYY-MM-DD*/){
  const url = await getConf("webhookUrl");
  const headers = await getHeaders();
  if (!url || !headers) return { ok:false, status:0 };

  const from = `${dateIso}T00:00:00Z`;
  const toNext = new Date(from); toNext.setUTCDate(toNext.getUTCDate()+1);
  const toIso = toNext.toISOString().slice(0,10);

  const q = `${url}?ts=gte.${encodeURIComponent(dateIso)}T00:00:00Z&ts=lt.${encodeURIComponent(toIso)}T00:00:00Z`;
  try{
    const res = await withRetry(() => fetch(q, { method:"DELETE", headers }));
    return { ok: res.ok, status: res.status };
  }catch{
    return { ok:false, status:0 };
  }
}

/* ===== Lifestyle (Heute) ===== */
const LS_WATER_GOAL = 2000;
const LS_SALT_MAX = 6;
const LS_PROTEIN_GOAL = 90;

let __lsTotals = { water_ml: 0, salt_g: 0, protein_g: 0 };

function setProgState(el, state){
  if (!el) return;
  el.classList.remove('ok','warn','bad');
  if (state) el.classList.add(state);
}

function fmtDE(n, digits){
  if (!Number.isFinite(n)) return '0';
  return n.toFixed(digits).replace('.', ',');
}

function updateLifestyleBars(){
  const wBar = document.getElementById('ls-water-bar');
  const wProg = document.getElementById('ls-water-prog');
  const wLbl = document.getElementById('ls-water-label');
  const sBar = document.getElementById('ls-salt-bar');
  const sProg = document.getElementById('ls-salt-prog');
  const sLbl = document.getElementById('ls-salt-label');
  const pBar = document.getElementById('ls-protein-bar');
  const pProg = document.getElementById('ls-protein-prog');
  const pLbl = document.getElementById('ls-protein-label');

  const w = Math.max(0, Math.min(__lsTotals.water_ml || 0, 6000));
  const s = Math.max(0, Math.min(__lsTotals.salt_g || 0, 30));
  const p = Math.max(0, Math.min(__lsTotals.protein_g || 0, 300));

  const wPct = Math.min(1, w / LS_WATER_GOAL) * 100;
  const sPct = Math.min(1, s / LS_SALT_MAX) * 100;
  const pPct = Math.min(1, p / LS_PROTEIN_GOAL) * 100;

  if (wBar) wBar.style.width = `${wPct.toFixed(1)}%`;
  if (sBar) sBar.style.width = `${sPct.toFixed(1)}%`;
  if (pBar) pBar.style.width = `${pPct.toFixed(1)}%`;

  if (wLbl) {
    let status = '';
    if (w >= LS_WATER_GOAL * 1.1) status = ' * Ziel erreicht';
    else if (w >= LS_WATER_GOAL * 0.9) status = ' * Zielbereich';
    else if (w >= LS_WATER_GOAL * 0.5) status = ' * moderate Aufnahme';
    else status = ' * niedrig';
    wLbl.textContent = `${w|0} / ${LS_WATER_GOAL} ml${status}`;
  }

  if (sLbl) {
    let status = ' * Zielbereich';
    if (s > LS_SALT_MAX) status = ' * ueber Ziel';
    else if (s >= 5) status = ' * Warnung';
    sLbl.textContent = `${fmtDE(s,1)} / ${fmtDE(LS_SALT_MAX,1)} g${status}`;
  }

  if (pLbl) {
    let status = ' * noch offen';
    if (p >= 78 && p <= 90) status = ' * Zielbereich';
    else if (p > 90) status = ' * ueber Ziel';
    pLbl.textContent = `${fmtDE(p,1)} / ${fmtDE(LS_PROTEIN_GOAL,1)} g${status}`;
  }

  // Wasser: <50% rot, 50-89% gelb, 90% gruen
  let wState = 'bad';
  if (w >= LS_WATER_GOAL * 0.9) wState = 'ok';
  else if (w >= LS_WATER_GOAL * 0.5) wState = 'warn';
  setProgState(wProg, wState);

  // Salz: 0-4.9 g gruen, 5-6 gelb, >6 rot
  let sState = 'ok';
  if (s > LS_SALT_MAX) sState = 'bad';
  else if (s >= 5) sState = 'warn';
  setProgState(sProg, sState);

  // Protein: <78 neutral, 78-90 gruen, >90 rot
  let pState = 'neutral';
  if (p >= 78 && p <= 90) pState = 'ok';
  else if (p > 90) pState = 'bad';
  setProgState(pProg, pState);
}

async function renderLifestyle(){
  const logged = await isLoggedIn();
  if (!logged){
    // Nichts anzeigen, Tab ist ohnehin gesperrt
    return;
  }
  try{
    const uid = await getUserId();
    const dayIso = todayStr();
    const cur = await loadIntakeToday({ user_id: uid, dayIso });
    __lsTotals = { water_ml: cur.water_ml||0, salt_g: cur.salt_g||0, protein_g: cur.protein_g||0 };
    updateLifestyleBars();
  }catch(_){ /* ignore */ }
}

function bindLifestyle(){
  const addWaterBtn = document.getElementById('ls-water-add-btn');
  const addSaltBtn = document.getElementById('ls-salt-add-btn');
  const addProtBtn = document.getElementById('ls-protein-add-btn');

  const addWater = async ()=>{
    const el = document.getElementById('ls-water-add');
    const v = Number(el?.value || 0);
    if (!(v>0)) { uiError('Bitte gueltige Wassermenge eingeben.'); return; }
    const dayIso = todayStr();
    let total = Math.min(6000, Math.max(0, (__lsTotals.water_ml||0) + v));
    if (total > 6000) total = 6000;
    try{
      await saveIntakeTotals({ dayIso, totals: { water_ml: total, salt_g: __lsTotals.salt_g||0, protein_g: __lsTotals.protein_g||0 } });
      __lsTotals.water_ml = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Wasser aktualisiert.');
    }catch(e){ uiError('Update fehlgeschlagen: ' + (e?.message||e)); try{ diag.add?.('Lifestyle update error (water): ' + (e?.message||e)); }catch(_){} }
  };

  const addSalt = async ()=>{
    const el = document.getElementById('ls-salt-add');
    const v = toNumDE(el?.value);
    if (!(v>0)) { uiError('Bitte gueltige Salzmenge eingeben.'); return; }
    const dayIso = todayStr();
    let total = (__lsTotals.salt_g||0) + v;
    if (total > 30) total = 30;
    try{
      await saveIntakeTotals({ dayIso, totals: { water_ml: __lsTotals.water_ml||0, salt_g: total, protein_g: __lsTotals.protein_g||0 } });
      __lsTotals.salt_g = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Salz aktualisiert.');
    }catch(e){ uiError('Update fehlgeschlagen: ' + (e?.message||e)); try{ diag.add?.('Lifestyle update error (salt): ' + (e?.message||e)); }catch(_){} }
  };

  const addProtein = async ()=>{
    const el = document.getElementById('ls-protein-add');
    const v = toNumDE(el?.value);
    if (!(v>0)) { uiError('Bitte gueltige Proteinmenge eingeben.'); return; }
    const dayIso = todayStr();
    let total = (__lsTotals.protein_g||0) + v;
    if (total > 300) total = 300;
    try{
      await saveIntakeTotals({ dayIso, totals: { water_ml: __lsTotals.water_ml||0, salt_g: __lsTotals.salt_g||0, protein_g: total } });
      __lsTotals.protein_g = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Protein aktualisiert.');
    }catch(e){ uiError('Update fehlgeschlagen: ' + (e?.message||e)); try{ diag.add?.('Lifestyle update error (protein): ' + (e?.message||e)); }catch(_){} }
  };

  if (addWaterBtn) addWaterBtn.addEventListener('click', addWater);
  if (addSaltBtn) addSaltBtn.addEventListener('click', addSalt);
  if (addProtBtn) addProtBtn.addEventListener('click', addProtein);
}

// PATCH: bestehende day_flags eines Tages aktualisieren (RLS: nur eigene Records)
async function patchDayFlags({ user_id, dayIso, flags }){
  const url = await getConf("webhookUrl");
  const headers = await getHeaders();
  if (!url || !headers || !user_id || !dayIso) throw new Error('patchDayFlags: missing params');

  const from = `${dayIso}T00:00:00Z`;
  const toNext = new Date(from); toNext.setUTCDate(toNext.getUTCDate()+1);
  const toIso = toNext.toISOString().slice(0,10);

  const q = `${url}?user_id=eq.${encodeURIComponent(user_id)}&type=eq.day_flags`+
            `&ts=gte.${encodeURIComponent(dayIso)}T00:00:00Z&ts=lt.${encodeURIComponent(toIso)}T00:00:00Z`;
  const res = await withRetry(() => fetch(q, { method: 'PATCH', headers, body: JSON.stringify({ payload: flags }) }));
  if (!res.ok) {
    let details = '';
    try { const e = await res.json(); details = e?.message || e?.details || ''; } catch {}
    throw new Error(`patch day_flags failed ${res.status} - ${details}`);
  }
  return await res.json();
}

async function pushPendingToRemote(){
  const url = await getConf("webhookUrl");
  const headers = await getHeaders();
  if(!url || !headers) return { pushed:0, failed:0 };

  const all = await getAllEntries();
  const pending = all.filter(e => !e.remote_id);

  let pushed = 0, failed = 0;

  for (const e of pending){
    try{
      const uid = await getUserId();

      // 1) Legacy-Entry  0..N Events
      const events = toHealthEvents(e);
      if (!events.length) { 
        // nichts sendbar: als "abgearbeitet" markieren, damit wir nicht haengen bleiben
        await updateEntry(e.id, { remote_id: -1 });
        continue;
      }

      // 2) user_id anhaengen (RLS)
      const payload = uid ? events.map(ev => ({...ev, user_id: uid})) : events;

      // 3) Batch-POST (Array)
      const res = await withRetry(() => fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }));
      if (!res.ok) { failed++; continue; }

      const json = await res.json();
      const firstId = json?.[0]?.id ?? null;

      // 4) Lokal markieren: irgendein Remote-Event existiert  Cloud-Icon ok
      if (firstId != null) {
        await updateEntry(e.id, { remote_id: firstId });
        pushed++;
      } else {
        failed++;
      }

      await sleep(50);
    } catch(_){
      failed++;
    }
  }

  return { pushed, failed };
}

function showLoginOverlay(show){
  const ov = document.getElementById('loginOverlay');
  if (ov) ov.style.display = show ? 'flex' : 'none';
}
function setUserUi(email){
  const who = document.getElementById('whoAmI');
  if (who) who.textContent = email ? `Angemeldet als: ${email}` : '';
}

// Buttons binden (einmalig, z. B. in main())
function bindAuthButtons(){
const gbtn = document.getElementById('googleLoginBtn');

if (gbtn) gbtn.addEventListener('click', async ()=>{
const supa = await ensureSupabaseClient();
if (!supa) { 
alert('Konfiguration fehlt (REST-URL und ANON-Key). Standardwerte sind gesetzt - falls entfernt, bitte App neu laden oder Konfiguration in IndexedDB hinterlegen.');
return;
}
const { error } = await supa.auth.signInWithOAuth({
provider: 'google',
options: { redirectTo: `${window.location.origin}${window.location.pathname}` }
});
if (error) alert('Google-Login fehlgeschlagen: ' + error.message);
});
}

// Beim Start Session pruefen
async function requireSession(){
if(!sbClient){
setUserUi('');
showLoginOverlay(true);
setAuthGuard(false);
return false;
}
const { data: { session } } = await sbClient.auth.getSession();
const email = session?.user?.email || '';
setUserUi(email);
showLoginOverlay(!session);
setAuthGuard(!!session);
setDoctorAccess(!!session);
return !!session;
}

// Reagiert auch auf spaetere Logins (z. B. nach Redirect)
function watchAuthState(){
  sbClient.auth.onAuthStateChange(async (_event, session)=>{
    const email = session?.user?.email || '';
    setUserUi(email);
    showLoginOverlay(!session);
    setAuthGuard(!!session);
    setDoctorAccess(!!session);

    if (session) {
      await afterLoginBoot();
      // Doctor-Unlock: nur bei Arzt-Ansicht (kein globaler App-Lock)
      await setupRealtime();     //  NEU: Realtime aktivieren nach Login
      await requestUiRefresh();  // initialer Refresh
    } else {
      teardownRealtime();        //  NEU: Channels sauber schliessen
      // UI in "abgemeldet" lassen - renderDoctor() zeigt Info ohnehin
    }
  });
}

// Alles, was NACH Login laufen soll (deine bestehende Logik)
let __booted = false; // ganz oben im Script oder vor afterLoginBoot definieren

async function afterLoginBoot(){
  if (__booted) return;
  __booted = true;
  // Keine Auto-Sync/Realtime bis Arzt-Ansicht umgestellt ist
  await renderDoctor(); // laesst "Bitte anmelden" o. "Keine Eintraege" stehen
}

/* ===== CSV/JSON export (Daily) ===== */
function dl(filename, content, mime){
const a = document.createElement("a");
a.href = URL.createObjectURL(new Blob([content], {type:mime}));
a.download = filename;
a.click();
URL.revokeObjectURL(a.href);
}

/* ===== Doctor view ===== */
function setDocBadges({ training, bad, visible } = {}) {
  const t = document.getElementById('docTrainCnt');
  const b = document.getElementById('docBadCnt');
  if (!t || !b) return;

  if (training !== undefined) t.querySelector('.val').textContent = String(training);
  if (bad !== undefined)      b.querySelector('.val').textContent = String(bad);

  if (visible !== undefined) {
    t.classList.toggle('hidden', !visible);
    b.classList.toggle('hidden', !visible);
  }
}

const __t0 = performance.now();
async function renderDoctor(){
  const host = $("#doctorView");
  if (!host) return;

  if (!(await isLoggedIn())){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte anmelden, um die Arzt-Ansicht zu sehen.</div>`;
    setDocBadges({ visible: false });
    return;
  }
  // Nur sperren, wenn die Arzt-Ansicht wirklich aktiv angezeigt wird
  const doctorSection = document.getElementById('doctor');
  const isActive = !!doctorSection && doctorSection.classList.contains('active');
  if (!__doctorUnlocked){
    if (isActive){
      host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte Arzt-Ansicht kurz entsperren.</div>`;
      setDocBadges({ visible: false });
      try { await requireDoctorUnlock(); } catch(_) {}
      if (!__doctorUnlocked) return;
    } else {
      return;
    }
  }
  host.innerHTML = "";

  // Anzeige-Helper
  const dash = v => (v === null || v === undefined || v === "" ? "-" : String(v));
  const onClass = b => (b ? "on" : "");
  const fmtDateDE = (iso) => {
    const d = new Date(iso + "T00:00:00Z");
    return d.toLocaleDateString("de-AT", { weekday:"short", day:"2-digit", month:"2-digit", year:"numeric" });
  };

  // Zeitraum lesen
  const from = $("#from").value;
  const to   = $("#to").value;
  if (!from || !to){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte Zeitraum waehlen.</div>`;
    setDocBadges({ visible: false });
    return;
  }

  //  Server lesen  Tagesobjekte
  let daysArr = [];
  try{
    daysArr = await fetchDailyOverview(from, to);
  }catch(_){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Fehler beim Laden aus der Cloud.</div>`;
    setDocBadges({ visible: false });
    return;
  }

  // KPIs
  const trainingDays = daysArr.filter(d => !!d.flags.training).length;
  const badDays = daysArr.filter(d => {
    const f = d.flags;
    return !!(f.water_lt2 || f.salt_gt5 || f.protein_ge90 || f.sick || f.meds);
  }).length;
  setDocBadges({ training: trainingDays, bad: badDays, visible: true });

  // Renderer je Tag
  const renderDoctorDay = (day) => `
<section class="doctor-day" data-date="${day.date}">
  <div class="col-date">
    <div class="date-top">
      <span class="date-label">${fmtDateDE(day.date)}</span>
      <span class="date-cloud" title="In Cloud gespeichert?">${day.hasCloud ? "&#9729;&#65039;" : ""}</span>
    </div>
    <div class="date-actions">
      <button class="btn ghost btn-xs" data-del-day="${day.date}">Loeschen</button>
    </div>
  </div>

  <div class="col-measure">
    <div class="measure-head">
      <div></div>
      <div>Sys</div><div>Dia</div><div>Puls</div><div>MAP</div>
    </div>
    <div class="measure-grid">
      <div class="measure-row">
        <div class="label">morgens</div>
        <div class="num ${ (day.morning.sys!=null && day.morning.sys>130) ? 'alert' : '' }">${dash(day.morning.sys)}</div>
        <div class="num ${ (day.morning.dia!=null && day.morning.dia>90)  ? 'alert' : '' }">${dash(day.morning.dia)}</div>
        <div class="num">${dash(day.morning.pulse)}</div>
        <div class="num ${ (day.morning.map!=null && day.morning.map>100) ? 'alert' : '' }">${dash(fmtNum(day.morning.map))}</div>
      </div>
      <div class="measure-row">
        <div class="label">abends</div>
        <div class="num ${ (day.evening.sys!=null && day.evening.sys>130) ? 'alert' : '' }">${dash(day.evening.sys)}</div>
        <div class="num ${ (day.evening.dia!=null && day.evening.dia>90)  ? 'alert' : '' }">${dash(day.evening.dia)}</div>
        <div class="num">${dash(day.evening.pulse)}</div>
        <div class="num ${ (day.evening.map!=null && day.evening.map>100) ? 'alert' : '' }">${dash(fmtNum(day.evening.map))}</div>
      </div>
    </div>
  </div>

  <div class="col-special">
    <div class="weight-line">
      <div>Gewicht</div>
      <div class="num">${dash(fmtNum(day.weight))}</div>
    </div>

    <div class="waist-line">
      <div>Bauchumfang (cm)</div>
      <div class="num">${dash(fmtNum(day.waist_cm))}</div>
    </div>

    <div class="flags">
      <div class="flag"><span class="flag-box ${onClass(day.flags.water_lt2)}"></span><span>&lt;2L Wasser</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.salt_gt5)}"></span><span>Salz &gt;5g</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.protein_ge90)}"></span><span>Protein &ge; 90 g</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.sick)}"></span><span>Krank</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.meds)}"></span><span>Medikamente</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.training)}"></span><span>Training</span></div>
    </div>

    <div class="notes">${nl2br((day.notes || "").trim() || "-")}</div>
  </div>
</section>
`;

  // Rendern / Leerzustand
  if (!daysArr.length){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Keine Eintraege im Zeitraum</div>`;
  } else {
    host.innerHTML = daysArr.map(renderDoctorDay).join("");

    //  Loeschen: alle Server-Events des Tages entfernen
    host.querySelectorAll('[data-del-day]').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const date = btn.getAttribute('data-del-day');
        if (!date) return;
        if (!confirm(`Alle Eintraege in der Cloud fuer ${date} loeschen?`)) return;

        btn.disabled = true;
        const old = btn.textContent;
        btn.textContent = 'Loesche...';
        try{
          const r = await deleteRemoteDay(date);
          if (!r.ok){
            alert(`Server-Loeschung fehlgeschlagen (${r.status||"?"}).`);
          }
          await renderDoctor();           // neu laden
          if (chartPanel.open) chartPanel.draw();
        } finally {
          btn.disabled = false; btn.textContent = old;
        }
      });
    });
  }
}

/* ===== Simple SVG Chart (Daily) - final, ohne Doppel-Helper & mit WHO-Ampel ===== */

/* Fallbacks nur, wenn extern nicht verfuegbar */
const safeEnsureSupabaseClient = async () => {
  try { if (typeof ensureSupabaseClient === "function") return await ensureSupabaseClient(); } catch(_) {}
  return null;
};
const safeGetConf = async (k) => {
  try { if (typeof getConf === "function") return await getConf(k); } catch(_) {}
  return null;
};

const chartPanel = {
  el: null,
  svg: null,
  legend: null,
  open: false,
  tip: null,
  tipSticky: false,

  init() {
    this.el = $("#chart");
    this.svg = $("#chartSvg");
    this.legend = $("#chartLegend");

    // Panel initial nicht anzeigen
    if (this.el) this.el.style.display = "none";

    // Close + Metric-Select
    const closeBtn = $("#chartClose");
    if (closeBtn) closeBtn.addEventListener("click", () => this.hide());
    const metricSel = $("#metricSel");
    if (metricSel) metricSel.addEventListener("change", () => this.draw());

    // Tooltip (hover/click)
    const contentHost = this.el?.querySelector(".content") || this.el || document.body;
    const tip = document.createElement("div");
    Object.assign(tip.style, {
      position: "absolute",
      inset: "auto auto auto auto",
      transform: "translate(8px,8px)",
      display: "none",
      pointerEvents: "none",
      zIndex: 2,
      background: "#10131a",
      border: "1px solid #2b2f3a",
      borderRadius: "8px",
      padding: "8px 10px",
      fontSize: "12px",
      lineHeight: "1.35",
      maxWidth: "280px",
      boxShadow: "0 6px 18px rgba(0,0,0,.35)",
      color: "var(--fg)",
    });
    tip.id = "chartTip";
    contentHost.style.position = "relative";
    contentHost.appendChild(tip);
    this.tip = tip;

    // ARIA Live-Region (nur Text, fuer Screenreader)
    const live = document.createElement("div");
    live.id = "chartAria";
    live.setAttribute("aria-live", "polite");
    live.setAttribute("role", "status");
    Object.assign(live.style, {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: 0,
      border: 0,
      margin: "-1px",
      clip: "rect(0 0 0 0)",
      overflow: "hidden",
      whiteSpace: "nowrap",
    });
    contentHost.appendChild(live);
    this.live = live;

    // Interaktivitaet
    if (this.svg) {
      this.svg.addEventListener("pointermove", (e) => {
        if (this.tipSticky) return;
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("flag-hit"));
        if (!(isPt || isHit)) { this.hideTip(); return; }
        const date = tgt.getAttribute("data-date") || "";
        const hasNote = !!(tgt.getAttribute("data-note"));
        const hasFlags = this.hasFlagsForDate?.(date);
        if (!(hasNote || hasFlags)) { this.hideTip(); return; }
        this.fillTipFromTarget(tgt);
        this.positionTip(e);
      });

      this.svg.addEventListener("pointerleave", () => {
        if (this.tipSticky) return;
        this.hideTip();
      });

      // Click/Tap: Tooltip toggeln (mobil-freundlich)
      this.svg.addEventListener("click", (e) => {
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("flag-hit"));
        if (!(isPt || isHit)) { if (this.tipSticky) { this.tipSticky = false; this.hideTip(); } return; }
        const date = tgt.getAttribute("data-date") || "";
        const hasNote = !!(tgt.getAttribute("data-note"));
        const hasFlags = this.hasFlagsForDate?.(date);
        if (!(hasNote || hasFlags)) { if (this.tipSticky) { this.tipSticky = false; this.hideTip(); } return; }
        this.fillTipFromTarget(tgt);
        this.tipSticky = !this.tipSticky;
        this.positionTip(e);
      });

      // Keyboard: Enter/Space toggelt Tooltip, ESC schliesst
      this.svg.addEventListener("keydown", (e) => {
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("flag-hit"));
        if (!(isPt || isHit)) return;
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          const date = tgt.getAttribute("data-date") || "";
          const hasNote = !!(tgt.getAttribute("data-note"));
          const hasFlags = this.hasFlagsForDate?.(date);
          if (!(hasNote || hasFlags)) return;
          this.fillTipFromTarget(tgt);
          this.tipSticky = !this.tipSticky;
        } else if (e.key === "Escape") {
          this.tipSticky = false; this.hideTip();
        }
      });
    }

    // Redraw bei Resize/Orientation
    if (this.el) {
      const ro = new ResizeObserver(() => { if (this.open) this.draw(); });
      ro.observe(this.el);
      this._ro = ro;
    }
    window.addEventListener("orientationchange", () => {
      setTimeout(() => { if (this.open) this.draw(); }, 150);
    });

    // KPI-Box: Felder sicherstellen
    this.ensureKpiFields();
  },

  toggle() {
    this.open = !this.open;
    if (this.el) this.el.style.display = this.open ? "block" : "none";
  },

  hide() {
    this.open = false;
    if (this.el) this.el.style.display = "none";
    this.tipSticky = false;
    this.hideTip();
  },

  // ----- Helpers -----
async getFiltered() {
  const from = $("#from")?.value;
  const to   = $("#to")?.value;

  // Wenn eingeloggt: Cloud nehmen (Events -> Daily), sonst fallback: lokale Entries
  if (await isLoggedIn()) {
    // gleiche Aggregation wie Arzt-Ansicht
    const days = await fetchDailyOverview(from, to);
    // Fuer die Chart-Logik bauen wir flache "entry"-aehnliche Objekte
    const flat = [];
    for (const d of days) {
      // Morgen
      if (d.morning.sys != null || d.morning.dia != null || d.morning.pulse != null) {
        const ts = Date.parse(d.date + "T07:00:00Z"); // Fix-Zeit am Tag
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Morgen",
          sys: d.morning.sys,
          dia: d.morning.dia,
          pulse: d.morning.pulse,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90
        });
      }
      // Abend
      if (d.evening.sys != null || d.evening.dia != null || d.evening.pulse != null) {
        const ts = Date.parse(d.date + "T19:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Abend",
          sys: d.evening.sys,
          dia: d.evening.dia,
          pulse: d.evening.pulse,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90
        });
      }
      // Body (Gewicht/Bauch)
      if (d.weight != null || d.waist_cm != null) {
        const ts = Date.parse(d.date + "T12:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Tag",
          sys: null, dia: null, pulse: null,
          weight: d.weight,
          waist_cm: d.waist_cm,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90
        });
      }
    }
    // Ergaenze Tage mit ausschliesslich Flags (ohne BP/Body), damit Flags-Overlay immer angezeigt wird
    for (const d of days) {
      const hasFlags = !!(d?.flags?.training || d?.flags?.sick || d?.flags?.water_lt2 || d?.flags?.salt_gt5 || d?.flags?.protein_ge90 || d?.flags?.meds);
      if (!hasFlags) continue;
      const already = flat.some(e => e?.date === d.date);
      if (!already) {
        const ts = Date.parse(d.date + "T12:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Tag",
          sys: null, dia: null, pulse: null,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90
        });
      }
    }
    return flat.sort((a,b) => (a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime)));
  }

  // Fallback: lokal (wenn nicht eingeloggt)
  const entries = typeof getAllEntries === "function" ? await getAllEntries() : [];
  return entries
    .filter(e => {
      if (from && e.date < from) return false;
      if (to   && e.date > to)   return false;
      return true;
    })
    .sort((a,b) => (a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime)));
},

  // Hoehe laden (Konfig oder Fallback 183 cm)
  async getHeightCm() {
    // 1) Supabase-Profil
    const supa = await safeEnsureSupabaseClient();
    if (supa) {
      try {
        const { data, error } = await supa.from("user_profile").select("height_cm").single();
        if (!error && data?.height_cm) return Number(data.height_cm);
      } catch(_) {}
    }
    // 2) lokale Konfig
    const v = await safeGetConf("height_cm");
    const n = Number(v);
    if (Number.isFinite(n) && n > 0) return n;
    return 183;
  },

  // Tooltip
  hideTip() {
    if (this.tip) {
      this.tip.style.display = "none";
      this.tip.textContent = "";
    }
  },
  positionTip(e) {
    if (!this.tip || !this.el) return;
    const hostRect = (this.el.querySelector(".content") || this.el).getBoundingClientRect();
    const x = e.clientX - hostRect.left;
    const y = e.clientY - hostRect.top;
    this.tip.style.left = `${x + 10}px`;
    this.tip.style.top  = `${y + 10}px`;
    if (this.tip.style.display !== "block") this.tip.style.display = "block";
  },
  fillTipFromTarget(tgt) {
    if (!this.tip) return;
    const note = tgt.getAttribute("data-note") || "";
    const date = tgt.getAttribute("data-date") || "";
    const ctx  = tgt.getAttribute("data-ctx")  || "";
    const flags = (typeof this.flagsByDate?.get === 'function') ? this.flagsByDate.get(date) : null;
    const items = [];
    if (flags) {
      if (flags.training)         items.push("Training");
      if (flags.sick)             items.push("Krank");
      if (flags.low_intake)       items.push("< 2 L Wasser");
      if (flags.salt_high)        items.push("> 5 g Salz");
      if (flags.protein_high90)   items.push("Protein  90 g");
      if (flags.valsartan_missed) items.push("Valsartan vergessen");
      if (flags.forxiga_missed)   items.push("Forxiga vergessen");
      if (flags.nsar_taken)       items.push("NSAR genommen");
      if (!flags.valsartan_missed && !flags.forxiga_missed && !flags.nsar_taken && flags.meds) items.push("Medikamente");
    }

    const parts = [];
    const hdr = (date || ctx) ? `<div style="opacity:.85;margin-bottom:4px">${esc([date, ctx].filter(Boolean).join(" . "))}</div>` : "";
    if (hdr) parts.push(hdr);
    if (note) parts.push(`<div style="white-space:pre-wrap;margin-bottom:${items.length? '6' : '0'}px">${esc(note)}</div>`);
    if (items.length) {
      const lis = items.map(esc).map(t => `<li>${t}</li>`).join("");
      parts.push(`<div style="margin-top:${note? '0' : '2'}px"><strong>Flags:</strong><ul style="margin:4px 0 0 16px; padding:0">${lis}</ul></div>`);
    }
    if (!parts.length) { this.hideTip(); return; }
    this.tip.innerHTML = parts.join("");
    if (this.live) this.live.textContent = `${date || ''} ${ctx || ''} ${note ? 'Notiz vorhanden. ' : ''}${items.length ? 'Flags: ' + items.join(', ') : ''}`.trim();
  },

  /* ---------- KPI-Felder + WHO-Ampellogik ---------- */
  ensureKpiFields() {
    const box = $("#chartAverages");
    if (!box) return;
    const need = [
      { k: "sys",  label: "Durchschnitt Sys: -" },
      { k: "dia",  label: "Durchschnitt Dia: -" },
      { k: "map",  label: "Durchschnitt MAP: -" },
      { k: "bmi",  label: "BMI (letzter): -" },
      { k: "whtr", label: "WHtR (letzter): -" },
    ];
    need.forEach((n) => {
      if (!box.querySelector(`[data-k="${n.k}"]`)) {
        const span = document.createElement("span");
        span.setAttribute("data-k", n.k);
        span.textContent = n.label;
        box.appendChild(span);
      }
    });
  },

  // WHO-Farben
  kpiColorBMI(v) {
    if (v == null) return "#9aa3af";        // unknown
    if (v < 18.5) return "#60a5fa";         // untergew.
    if (v < 25)   return "#10b981";         // normal
    if (v < 30)   return "#f59e0b";         // uebergew.
    return "#ef4444";                        // adipoes
  },
  kpiColorWHtR(v) {
    if (v == null) return "#9aa3af";
    if (v < 0.5)   return "#10b981";        // ok
    if (v <= 0.6)  return "#f59e0b";        // erhoeht
    return "#ef4444";                        // hoch
  },

  // Ein Punkt pro KPI, korrekt eingefaerbt; saubere Separatoren
  layoutKpis() {
    const box = $("#chartAverages");
    if (!box) return;

    // 1) Alle alten Deko-Elemente entfernen (auch statische .sep aus dem HTML!)
    [...box.querySelectorAll(".kpi-dot, .kpi-sep, .sep")].forEach(n => n.remove());

    // 2) Sichtbare KPI-Spans ermitteln (display != "none")
    const items = [...box.querySelectorAll('[data-k]')].filter(el => el.style.display !== "none");

    // 3) Pro Item farbigen Punkt einsetzen + exakt einen Separator zwischen Items
    const makeDot = (color) => {
      const d = document.createElement("span");
      d.className = "kpi-dot";
      Object.assign(d.style, {
        display: "inline-block",
        width: "8px", height: "8px",
        borderRadius: "50%",
        margin: "0 8px 0 12px",
        background: color,
        verticalAlign: "middle"
      });
      return d;
    };
    const makeSep = () => {
      const s = document.createElement("span");
      s.className = "kpi-sep";
      s.textContent = "*";
      Object.assign(s.style, {
        color: "#6b7280",
        margin: "0 10px",
        userSelect: "none"
      });
      return s;
    };

    items.forEach((el, idx) => {
      let color = "#9aa3af";
      const k = el.getAttribute("data-k");

      // Wert aus Text extrahieren (erste Zahl im Text)
      const m = el.textContent.match(/([\d.]+)/);
      const v = m ? parseFloat(m[1]) : null;

      if (k === "bmi") {
        color = this.kpiColorBMI(Number.isFinite(v) ? v : null);
      } else if (k === "whtr") {
        color = this.kpiColorWHtR(Number.isFinite(v) ? v : null);
      } else {
        // BP-KPIs neutral blau
        color = "#60a5fa";
      }

      el.before(makeDot(color));
      if (idx < items.length - 1) el.after(makeSep());
    });

    box.style.display = items.length ? "inline-flex" : "none";
    box.style.alignItems = "center";
  },

  // ----- Zeichnen -----
  async draw() {
    const t0 = performance.now?.() ?? Date.now();
if (!(await isLoggedIn())) {
  if (this.svg) this.svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Bitte anmelden</text>';
  if (this.legend) this.legend.innerHTML = "";
  return;
}
const metric = $("#metricSel")?.value || "bp";

    const data   = await this.getFiltered();

    // X-Basis
    const xsAll = data.map(e => e.ts ?? Date.parse(e.dateTime));
    let series = [];
    let X = xsAll;

    // KPI-Box
    const avgBox = $("#chartAverages");

    // Schwellen (nur BP)
    const TH_SYS = 130;
    const TH_DIA = 90;

    // Tagesstempel (UTC, 00:00)
    const toDayTs = (isoDate /* "YYYY-MM-DD" */) => {
      if (!isoDate) return NaN;
      const [y, m, d] = isoDate.split("-").map(Number);
      return Date.UTC(y, (m || 1) - 1, d || 1);
    };

    // Tageskommentare (erste Zeile)
    const notesByDate = new Map();
    for (const e of data) {
      const hasDayLike = e?.context === "Tag" || isWeightOnly(e);
      const txt = (e?.notes || "").trim();
      if (hasDayLike && txt) {
        const firstLine = txt.split(/\r?\n/)[0].trim();
        if (firstLine) notesByDate.set(e.date, firstLine);
      }
    }

    // Fuer BP benoetigen wir Meta je Punkt
    let meta = null;

    if (metric === "bp") {
      // Nur echte Messungen
      const mData = data.filter(
        e => (e.context === "Morgen" || e.context === "Abend") && (e.sys != null || e.dia != null)
      );

      // Meta
      meta = mData.map(e => ({
        date: e.date,
        ctx:  e.context,
        sys:  e.sys != null ? Number(e.sys) : null,
        dia:  e.dia != null ? Number(e.dia) : null,
        note: notesByDate.get(e.date) || "",
      }));

      // X auf Tage normalisieren
      const xsBP = mData.map(e => toDayTs(e.date));

      // Werte-Reihen (Index passend zu meta)
      const sysM = mData.map(e => (e.context === "Morgen" && e.sys != null) ? Number(e.sys) : null);
      const sysA = mData.map(e => (e.context === "Abend"  && e.sys != null) ? Number(e.sys) : null);
      const diaM = mData.map(e => (e.context === "Morgen" && e.dia != null) ? Number(e.dia) : null);
      const diaA = mData.map(e => (e.context === "Abend"  && e.dia != null) ? Number(e.dia) : null);

      // KPIs ( ueber alle Messungen)
      const avg = (arr) => {
        const v = arr.filter(x => x != null);
        return v.length ? v.reduce((p,c) => p + c, 0) / v.length : null;
      };
      const mapArr = mData.map(e =>
        e.sys != null && e.dia != null
          ? Number(e.dia) + (Number(e.sys) - Number(e.dia)) / 3
          : null
      );

      if (avgBox) {
        const avgSys = avg(mData.map(e => (e.sys != null ? Number(e.sys) : null)));
        const avgDia = avg(mData.map(e => (e.dia != null ? Number(e.dia) : null)));
        const avgMap = avg(mapArr);

        const f0 = (v) => (v == null ? "-" : Math.round(v).toString());

        // Zeige BP-KPIs, blende BMI/WHtR aus
        const sEl  = avgBox.querySelector('[data-k="sys"]');
        const dEl  = avgBox.querySelector('[data-k="dia"]');
        const mEl  = avgBox.querySelector('[data-k="map"]');
        const bmiEl  = avgBox.querySelector('[data-k="bmi"]');
        const whtrEl = avgBox.querySelector('[data-k="whtr"]');
        if (sEl)  { sEl.style.display  = ""; sEl.textContent  = "Durchschnitt Sys: " + f0(avgSys); }
        if (dEl)  { dEl.style.display  = ""; dEl.textContent  = "Durchschnitt Dia: " + f0(avgDia); }
        if (mEl)  { mEl.style.display  = ""; mEl.textContent  = "Durchschnitt MAP: " + f0(avgMap); }
        if (bmiEl)  bmiEl.style.display  = "none";
        if (whtrEl) whtrEl.style.display = "none";

        avgBox.style.display = (avgSys != null || avgDia != null || avgMap != null) ? "inline-flex" : "none";
        this.layoutKpis();
      }

      // Serien definieren
      series = [
        { name: "Sys Morgens", values: sysM, color: "#93c5fd", type: "sys" },
        { name: "Sys Abends",  values: sysA, color: "#2563eb", type: "sys" },
        { name: "Dia Morgens", values: diaM, color: "#f9a8d4", type: "dia" },
        { name: "Dia Abends",  values: diaA, color: "#db2777", type: "dia" },
      ];

      X = xsBP; // wichtig
} else if (metric === "weight") {
  // Serien: Gewicht + Bauchumfang
  series = [
    {
      name: "Gewicht (kg)",
      values: data.map(e => e.weight != null ? Number(e.weight) : null),
      color: "#f59e0b", // Amber
      type: "misc",
    },
    {
      name: "Bauchumfang (cm)",
      values: data.map(e => e.waist_cm != null ? Number(e.waist_cm) : null),
      color: "#10b981", // Gruen
      type: "misc",
    }
  ];

  // KPI-Leiste: BMI & WHtR aus dem LETZTEN verfuegbaren Wert
  if (avgBox) {
    // BP-KPIs ausblenden
    ["sys","dia","map"].forEach(k => {
      const el = avgBox.querySelector(`[data-k="${k}"]`);
      if (el) el.style.display = "none";
    });

    // letzten Weight/Bauchumfang finden (data ist aufsteigend sortiert)
    let lastWeight = null, lastWaist = null;
    for (let i = data.length - 1; i >= 0; i--) {
      if (lastWeight == null && data[i].weight   != null) lastWeight = Number(data[i].weight);
      if (lastWaist  == null && data[i].waist_cm != null) lastWaist  = Number(data[i].waist_cm);
      if (lastWeight != null && lastWaist != null) break;
    }

    const heightCm = await this.getHeightCm();
    const hM = heightCm > 0 ? heightCm / 100 : null;

    const bmi  = (lastWeight != null && hM)         ? lastWeight / (hM * hM) : null;
    const whtr = (lastWaist  != null && heightCm>0) ? lastWaist  / heightCm  : null;

    const bmiEl  = avgBox.querySelector('[data-k="bmi"]');
    const whtrEl = avgBox.querySelector('[data-k="whtr"]');

    if (bmiEl)  { bmiEl.textContent  = `BMI (letzter): ${bmi  == null ? "-" : bmi.toFixed(1)}`;  bmiEl.style.display  = ""; }
    if (whtrEl) { whtrEl.textContent = `WHtR (letzter): ${whtr == null ? "-" : whtr.toFixed(2)}`; whtrEl.style.display = ""; }

    avgBox.style.display = "inline-flex";
    this.layoutKpis();
  }
}

  // --- Render-Prep ---
    if (this.svg) this.svg.innerHTML = "";
    if (this.legend) this.legend.innerHTML = "";
    if (!this.tipSticky) this.hideTip();

    // Wenn es Flags gibt, soll das Chart nicht fruehzeitig abbrechen
    const hasAnyFlagsData = (Array.isArray(data) && data.some(e => !!(e?.training || e?.low_intake || e?.sick || e?.salt_high || e?.protein_high90 || e?.valsartan_missed || e?.forxiga_missed || e?.nsar_taken)));
    const hasAny = series.some(s => s.values.some(v => v != null)) || hasAnyFlagsData;
    if (!hasAny) {
      if (this.svg) this.svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Keine darstellbaren Werte</text>';
      return;
    }

    // Dynamische Groesse
    const bbox = this.svg?.getBoundingClientRect?.() || { width: 640, height: 280 };
    const W = Math.max(300, Math.floor(bbox.width  || 640));
    const H = Math.max(200, Math.floor(bbox.height || 280));
    if (this.svg) this.svg.setAttribute("viewBox", `0 0 ${W} ${H}`);

    const PL = 48, PR = 16, PT = 12, PB = 28;
    const innerW = W - PL - PR, innerH = H - PT - PB;

    // === Flags -> X-Bereich erweitern (immer) + Lookup fuer Tooltip ===
    let flagTs = [];
    {
      const dayFlagsTmp = new Map(); // date -> { training:bool, bad:int, seen:{} }
      const flagsByDate = new Map(); // date -> detailed flags for tooltip
      for (const e of data) {
        if (!e?.date) continue;
        let rec = dayFlagsTmp.get(e.date);
        if (!rec) {
          rec = {
            training: false,
            bad: 0,
            seen: { water: false, salt: false, protein: false, sick: false, meds: false },
          };
          dayFlagsTmp.set(e.date, rec);
        }
        if (e.training) rec.training = true;
        const meds = !!(e.valsartan_missed || e.forxiga_missed || e.nsar_taken);
        const flags = {
          water: !!e.low_intake,
          salt:  !!e.salt_high,
          protein: !!e.protein_high90,
          sick:  !!e.sick,
          meds,
        };
        for (const k of Object.keys(flags)) {
          if (flags[k] && !rec.seen[k]) { rec.seen[k] = true; rec.bad++; }
        }

        // Tooltip-Detailflags sammeln
        let f = flagsByDate.get(e.date);
        if (!f) f = { training:false, sick:false, low_intake:false, salt_high:false, protein_high90:false, valsartan_missed:false, forxiga_missed:false, nsar_taken:false, meds:false };
        f.training = f.training || !!e.training;
        f.sick = f.sick || !!e.sick;
        f.low_intake = f.low_intake || !!e.low_intake;
        f.salt_high = f.salt_high || !!e.salt_high;
        f.protein_high90 = f.protein_high90 || !!e.protein_high90;
        f.valsartan_missed = f.valsartan_missed || !!e.valsartan_missed;
        f.forxiga_missed   = f.forxiga_missed   || !!e.forxiga_missed;
        f.nsar_taken       = f.nsar_taken       || !!e.nsar_taken;
        f.meds = f.meds || meds;
        flagsByDate.set(e.date, f);
      }
      flagTs = [...dayFlagsTmp.keys()].map(d => Date.parse(d + "T00:00:00Z"));
      this.flagsByDate = flagsByDate;
      this.hasFlagsForDate = (dayIso) => {
        if (!dayIso || !this.flagsByDate) return false;
        const f = this.flagsByDate.get(dayIso);
        if (!f) return false;
        return !!(f.training || f.sick || f.low_intake || f.salt_high || f.protein_high90 || f.valsartan_missed || f.forxiga_missed || f.nsar_taken || f.meds);
      };
    }

    // Skalen
    const xVals = X.filter(t => Number.isFinite(t));
    let xmin = Math.min(...xVals);
    let xmax = Math.max(...xVals);

    if (!Number.isFinite(xmin) || !Number.isFinite(xmax)) {
      // Fallback
      xmin = Date.now() - 7 * 864e5;
      xmax = Date.now();
    }

    // Union mit Flag-Tagen (immer)
    if (flagTs.length) {
      xmin = Math.min(xmin, Math.min(...flagTs));
      xmax = Math.max(xmax, Math.max(...flagTs));
    }

    // Padding (2%)
    const pad = xmax > xmin ? (xmax - xmin) * 0.02 : 0;
    xmin -= pad; xmax += pad;

    const allY   = series.flatMap(s => s.values.filter(v => v != null));
    const yminRaw = Math.min(...allY);
    const ymaxRaw = Math.max(...allY);
    const range   = Math.max(1, ymaxRaw - yminRaw);
    const ypad    = Math.max(range * 0.08, 1);
    const y0 = yminRaw - ypad;
    const y1 = ymaxRaw + ypad;

    const x = (t) => PL + ((t - xmin) / Math.max(1, xmax - xmin)) * innerW;
    const y = (v) => PT + (1 - (v - y0) / Math.max(1, y1 - y0)) * innerH;

    const line = (x1,y1_,x2,y2,stroke,dash="") =>
      `<line x1="${x1}" y1="${y1_}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="1" ${dash ? `stroke-dasharray="${dash}"` : ""} />`;
    const text = (tx,ty,str,anchor="end") =>
      `<text x="${tx}" y="${ty}" fill="#9aa3af" font-size="11" text-anchor="${anchor}">${esc(str)}</text>`;

    // Grid + Labels
    let grid = "";
    const ticks = 9;
    for (let i=0; i<=ticks; i++) {
      const vv = y0 + (i * (y1 - y0)) / ticks;
      const yy = y(vv);
      grid += line(PL, yy, W-PR, yy, "#2a3140");
      grid += text(PL - 6, yy + 4, Math.round(vv).toString());
    }
    // vertikale Wochenlinien + Datum
    const week = 7 * 24 * 3600 * 1000;
    let start = xmin - (xmin % week) + week;
    for (let t = start; t < xmax; t += week) {
      const xx = x(t);
      grid += line(xx, PT, xx, H - PB, "#1b1f28", "3 3");
      const d = new Date(t);
      const lbl = `${String(d.getDate()).padStart(2,"0")}.${String(d.getMonth()+1).padStart(2,"0")}.`;
      grid += text(xx, H - 8, lbl, "middle");
    }
    // Achsen
    grid += line(PL, PT, PL, H - PB, "#2b2f3a");
    grid += line(PL, H - PB, W - PR, H - PB, "#2b2f3a");

    // Schwellenlinien (BP)
    if (metric === "bp") {
      const ySys = y(TH_SYS);
      const yDia = y(TH_DIA);
      grid += line(PL, ySys, W - PR, ySys, "#ef4444", "6 4");
      grid += line(PL, yDia, W - PR, yDia, "#ef4444", "6 4");
grid += text(W - PR - 2, ySys + 4, "Sys 130", "end");
grid += text(W - PR - 2, yDia  + 4, "Dia 90",  "end");
    }

    if (this.svg) this.svg.insertAdjacentHTML("beforeend", grid);

    // === Flags Overlay (immer) ===
    if (this.svg) {
      const dayFlags = new Map(); // date -> { training:bool, badCount:int, seen:{} }
      for (const e of data) {
        if (!e?.date) continue;
        let rec = dayFlags.get(e.date);
        if (!rec) {
          rec = { training:false, badCount:0, seen:{ water:false, salt:false, protein:false, sick:false, meds:false } };
          dayFlags.set(e.date, rec);
        }
        if (e.training) rec.training = true;
        const meds = !!(e.valsartan_missed || e.forxiga_missed || e.nsar_taken);
        const flags = {
          water: !!e.low_intake, salt: !!e.salt_high, protein: !!e.protein_high90, sick: !!e.sick, meds
        };
        for (const k of Object.keys(flags)) {
          if (flags[k] && !rec.seen[k]) { rec.seen[k] = true; rec.badCount++; }
        }
      }

      const toDayTsLocal = (iso) => Date.parse(iso + "T00:00:00Z");
      const flaggedDays = [...dayFlags.keys()]
        .filter(d => {
          const r = dayFlags.get(d);
          return r && (r.training || r.badCount > 0);
        })
        .sort();

      if (flaggedDays.length) {
        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.setAttribute("class","flags");
        g.setAttribute("pointer-events","auto");
        g.setAttribute("aria-hidden","true");

        const uniqDays = [...new Set([...flaggedDays.map(d => toDayTsLocal(d)), ...X.filter(Boolean)])].sort((a,b)=>a-b);
        const dayXs = uniqDays.map(t => x(t));
        const minStep = dayXs.length > 1 ? Math.min(...dayXs.slice(1).map((v,i)=>v - dayXs[i])) : innerW;
        const bandW   = Math.max(10, Math.floor(minStep * 0.45));
        const yBottom = PT + innerH;
        const slotH   = innerH / 6; // 1 Training + bis zu 5 Bad

        for (const d of flaggedDays) {
          const t = toDayTsLocal(d);
          const cx = x(t), xLeft = Math.round(cx - bandW/2);
          const rec = dayFlags.get(d);
          let used = 0;

          // Training (gruen)
          if (rec.training) {
            const yTop = Math.round(yBottom - (used + 1) * slotH);
            const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
            r.setAttribute("x", xLeft); r.setAttribute("y", yTop);
            r.setAttribute("width", bandW); r.setAttribute("height", Math.ceil(slotH));
            r.setAttribute("fill", "#10b981"); r.setAttribute("fill-opacity","0.22");
            r.setAttribute("stroke", "#fff");  r.setAttribute("stroke-opacity","0.06");
            r.setAttribute("shape-rendering","crispEdges");
            g.appendChild(r);
            used++;
          }
          // Bad-Flags (rot gestapelt)
          for (let i=0; i<rec.badCount; i++) {
            const yTop = Math.round(yBottom - (used + 1) * slotH);
            const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
            r.setAttribute("x", xLeft); r.setAttribute("y", yTop);
            r.setAttribute("width", bandW); r.setAttribute("height", Math.ceil(slotH));
            r.setAttribute("fill", "#ef4444"); r.setAttribute("fill-opacity","0.18");
            r.setAttribute("stroke", "#fff");  r.setAttribute("stroke-opacity","0.06");
            r.setAttribute("shape-rendering","crispEdges");
            g.appendChild(r);
            used++;
          }

          // Interaktiver Hit-Bereich pro Tag ueber alle Slots
          const totalSlots = used;
          if (totalSlots > 0) {
            const yTopAll = Math.round(yBottom - totalSlots * slotH);
            const hit = document.createElementNS("http://www.w3.org/2000/svg","rect");
            hit.setAttribute("x", xLeft); hit.setAttribute("y", yTopAll);
            hit.setAttribute("width", bandW); hit.setAttribute("height", Math.ceil(totalSlots * slotH));
            hit.setAttribute("fill", "transparent");
            hit.setAttribute("pointer-events", "all");
            hit.setAttribute("class", "flag-hit");
            hit.setAttribute("data-date", d);
            hit.setAttribute("role", "button");
            hit.setAttribute("tabindex", "0");
            // ARIA-Label aus Flags ableiten
            try {
              const f = this.flagsByDate?.get?.(d);
              if (f) {
                const items = [];
                if (f.training) items.push("Training");
                if (f.sick) items.push("Krank");
                if (f.low_intake) items.push("< 2 L Wasser");
                if (f.salt_high) items.push("> 5 g Salz");
                if (f.protein_high90) items.push("Protein  90 g");
                if (f.valsartan_missed) items.push("Valsartan vergessen");
                if (f.forxiga_missed) items.push("Forxiga vergessen");
                if (f.nsar_taken) items.push("NSAR genommen");
                if (!f.valsartan_missed && !f.forxiga_missed && !f.nsar_taken && f.meds) items.push("Medikamente");
                if (items.length) hit.setAttribute("aria-label", `Flags: ${items.join(", ")}`);
              }
            } catch(_){}
            g.appendChild(hit);
          }
        }
        this.svg.appendChild(g); // hinter den Linien/Punkten
      }
    }

    // Linien + Punkte
const isFiniteTs = (t) => Number.isFinite(t);

const mkPath = (values, color) => {
  let d = "";
  values.forEach((v,i) => {
    if (v == null || !isFiniteTs(X[i])) return; // statt !X[i]
    d += (d === "" ? "M" : "L") + `${x(X[i]).toFixed(1)},${y(v).toFixed(1)} `;
  });
  return `<path d="${d}" fill="none" stroke="${color}" stroke-width="2.2" pointer-events="none" />`;
};

const mkDots = (values, color, kind) => {
  let out = "";
  values.forEach((v, i) => {
    if (v == null || !Number.isFinite(X[i])) return;
    const cx = x(X[i]).toFixed(1);
    const cy = y(v).toFixed(1);

    // Tooltip-Infos (nur bei BP vorhanden)
    const m = (kind === "sys" || kind === "dia") ? (meta?.[i] || {}) : {};
    const date = (m.date || (data?.[i]?.date || ""));
    const ctx  = (m.ctx  || (kind === "misc" ? "Tag" : ""));
    const note = (m.note || "");
    const labelBase = (kind === "sys" || kind === "dia") ? `${kind.toUpperCase()} ${v}` : `${v}`;
    const aria = `${date} ${ctx} ${labelBase}`.trim();

    out += `<circle class="pt" cx="${cx}" cy="${cy}" r="2.6" fill="${color}"
                data-kind="${esc(kind)}" data-val="${v}"
                data-date="${esc(date)}" data-ctx="${esc(ctx)}"
               data-note="${esc(note)}" tabindex="0" role="button" aria-label="${esc(aria)}" title="${esc(aria)}"
               stroke="rgba(0,0,0,0)" stroke-width="12" pointer-events="stroke" />`;
  });
  return out;
};

const mkAlertDots = (seriesItem) => {
  if (metric !== "bp") return "";
  const isSys = seriesItem.type === "sys";
  const thr   = isSys ? TH_SYS : TH_DIA;
  const kind  = isSys ? "sys" : "dia";
  let out = "";
  seriesItem.values.forEach((v, i) => {
    if (v == null || !isFiniteTs(X[i])) return;
    if (v > thr) {
      const cx = x(X[i]).toFixed(1), cy = y(v).toFixed(1);
      const m = meta?.[i] || {};
      out += `<circle class="pt" cx="${cx}" cy="${cy}" r="5.2" fill="#ef4444" stroke="#000" stroke-width="0.8"
               data-kind="${kind}" data-val="${v}"
               data-date="${esc(m.date || "")}" data-ctx="${esc(m.ctx || "")}"
               data-note="${esc(m.note || "")}" />`;
    }
  });
  return out;
};

    // Zeichnen
    series.forEach((s) => {
      if (!this.svg) return;
      this.svg.insertAdjacentHTML("beforeend", mkPath(s.values, s.color));
      this.svg.insertAdjacentHTML(
        "beforeend",
        mkDots(s.values, s.color, (s.type === "sys" || s.type === "dia") ? s.type : "misc")
      );
      if (metric === "bp") {
        this.svg.insertAdjacentHTML("beforeend", mkAlertDots(s));
      }
      // Legende
      if (this.legend) {
        const wrap = document.createElement("span");
        wrap.style.display = "inline-flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        const dot = Object.assign(document.createElement("span"), { className: "dot" });
        dot.style.background = s.color;
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        const label = document.createElement("span");
        label.textContent = s.name;
        wrap.append(dot, label);
        this.legend.appendChild(wrap);
      }
    });

    if (this.tipSticky) { this.tipSticky = false; this.hideTip(); }

    const sPerf = (perfStats.add?.("drawChart", (performance.now?.() ?? Date.now()) - t0), perfStats.snap?.("drawChart")) || {p50:0,p95:0,p99:0,count:0};
    diag.add?.(`[perf] drawChart p50=${sPerf.p50|0}ms p95=${sPerf.p95|0}ms p99=${sPerf.p99|0}ms (n=${sPerf.count})`);
  },
};

/* --- Button-Flash (nur Platzhalter, wie gehabt) --- */
let saveFlashTimer = null;
function flashSaveOk(){
  const btn = document.getElementById('saveAllBtn');
  if(!btn) return;
  if (saveFlashTimer) { clearTimeout(saveFlashTimer); saveFlashTimer = null; }
  btn.disabled = true; btn.classList.add('flash'); btn.innerHTML = ' Events gespeichert';
  saveFlashTimer = setTimeout(()=>{ btn.classList.remove('flash'); btn.innerHTML = ' Speichern'; btn.disabled = false; saveFlashTimer = null; }, 1000);
}

/* ===== Tabs / Segments ===== */
async function setTab(name){
  if (name !== "doctor" && document.body.classList.contains('app-locked')){
    __pendingAfterUnlock = null;
    lockUi(false);
  }
  if (name === "doctor"){
    if (!(await isLoggedIn())){
      showLoginOverlay(true);
      return;
    }
    if (!__doctorUnlocked){
      __pendingAfterUnlock = 'doctor';
      const ok = await requireDoctorUnlock();
      if (!ok) return;
      __pendingAfterUnlock = null;
    }
  }
  if (name === "lifestyle"){
    if (!(await isLoggedIn())){
      showLoginOverlay(true);
      name = "capture";
    }
  }
  $$(".view").forEach(v => v.classList.remove("active"));
  $("#"+name).classList.add("active");
  $$(".tabs .btn").forEach(b =>
    b.classList.toggle("primary", b.dataset.tab === name)
  );
  if (name === "doctor") { renderDoctor(); }
  if (name === "capture") { try { await syncCaptureFlagTogglesForCurrentDate(); } catch(_){} }
  if (name === "lifestyle") { try { await cleanupOldIntake(); await renderLifestyle(); } catch(_){} }
}

function bindTabs(){
  $$(".tabs .btn").forEach(b =>
    b.addEventListener("click", async (e) => {
      const tab = e.currentTarget.dataset.tab;
      if (tab === "doctor" && !(await isLoggedIn())){
        showLoginOverlay(true);
        return;
      }
      setTab(tab);
    })
  );
}

/* ===== Save flows ===== */
// Replace sugar toggle with protein (runtime migration)
(function migrateSugarToProtein(){
  const legacy = document.getElementById('sugarHighToggle');
  if (legacy) {
    legacy.id = 'proteinHighToggle';
    legacy.setAttribute('title','Protein >= 90 g');
    legacy.innerHTML = '&#x1F969; Protein >= 90 g';
  }
})();
function setProteinHigh(on){
  proteinHigh = !!on;
  setToggle($("#proteinHighToggle"), proteinHigh, "&#x1F969; Protein >= 90 g (aktiv)", "&#x1F969; Protein >= 90 g");
}
let trainingActive=false, lowIntakeActive=false, sickActive=false, valsartanMissed=false, forxigaMissed=false, nsarTaken=false,
saltHigh=false, proteinHigh=false;
function setToggle(el, on, activeText, baseText){
el = el || null;
if (!el) return;
el.classList.toggle("active", !!on);
el.setAttribute("aria-pressed", on ? "true" : "false");
el.innerHTML = on ? activeText : baseText;
}
function setTraining(on){ trainingActive=!!on; setToggle($("#trainingToggle"), trainingActive, "&#x1F3CB;&#xFE0F; Training heute (aktiv)", "&#x1F3CB;&#xFE0F; Training heute"); }
function setLowIntake(on){ lowIntakeActive=!!on; setToggle($("#lowIntakeToggle"), lowIntakeActive, "&#x1F4A7; < 2 L (aktiv)", "&#x1F4A7; < 2 L getrunken"); }
function setSaltHigh(on){ saltHigh = !!on; setToggle($("#saltHighToggle"), saltHigh, "&#x1F9C2; > 5 g Salz (aktiv)", "&#x1F9C2; > 5 g Salz"); }
function setSugarHigh(on){ sugarHigh = !!on; setToggle($("#sugarHighToggle"), sugarHigh, "&#x1F36C; > 10 g Zucker (aktiv)", "&#x1F36C; > 10 g Zucker"); }

function setSick(on){
sickActive=!!on; setToggle($("#sickToggle"), sickActive, "&#x1F912; Krank (Forxiga pausiert) (aktiv)", "&#x1F912; Krank (Forxiga pausiert)");
if(sickActive){ setForxigaMiss(true); $("#forxigaMissToggle").disabled=true; $("#forxigaMissToggle").style.opacity=0.6; }
else { $("#forxigaMissToggle").disabled=false; $("#forxigaMissToggle").style.opacity=1; }
}
function setValsartanMiss(on){ valsartanMissed=!!on; setToggle($("#valsartanMissToggle"), valsartanMissed, "&#x1F48A; Valsartan vergessen (aktiv)", "&#x1F48A; Valsartan vergessen"); }
function setForxigaMiss(on){ forxigaMissed=!!on; setToggle($("#forxigaMissToggle"), forxigaMissed, "&#x23F0; Forxiga vergessen (aktiv)", "&#x23F0; Forxiga vergessen"); }
function setNsar(on){ nsarTaken=!!on; setToggle($("#nsarToggle"), nsarTaken, "&#x1F489; NSAR genommen (aktiv)", "&#x1F489; NSAR genommen"); }
function blockHasData(which){
  const getVal = (sel) => document.querySelector(sel)?.value?.trim();
  const sys = getVal(`#sys${which}`);
  const dia = getVal(`#dia${which}`);
  const pulse = getVal(`#pulse${which}`);
  const commentEl = document.getElementById(which === "M" ? "bpCommentM" : "bpCommentA");
  const comment = (commentEl?.value || "").trim();
  return !!(sys || dia || pulse || comment);
}
async function saveAll(){
const __t0 = performance.now();
if(!(await isLoggedIn())){ alert("Bitte zuerst mit Google anmelden."); return; }

// 1) Erkennen, was heute eingegeben wurde
const hasM = blockHasData("M"); 
const hasA = blockHasData("A"); 
const weightVal = $("#weightDay")?.value?.trim();
const waistValRaw = $("#input-waist-cm")?.value?.trim();
const notes = ($("#notesDay").value || "").trim();
const flagsComment = ($("#flagsComment")?.value || "").trim();
const hasAnyFlag = !!(trainingActive || lowIntakeActive || sickActive ||
  valsartanMissed || forxigaMissed || nsarTaken ||
  saltHigh || proteinHigh);
const hasDaySummary = !!(weightVal || waistValRaw || hasAnyFlag || notes || flagsComment);

//  NEU: Kommentarpflicht bei Grenzwertueberschreitung
const sysM = Number($("#sysM").value);
const diaM = Number($("#diaM").value);
const sysA = Number($("#sysA").value);
const diaA = Number($("#diaA").value);

const needsComment = 
  (sysM > 130) || (diaM > 90) ||
  (sysA > 130) || (diaA > 90);

const notesEl = $("#notesDay");
notesEl.style.outline = ""; // Reset

if (needsComment && !notes) {
  alert("Bitte Kommentar eingeben bei Grenzwertueberschreitung (Sys>130 oder Dia>90).");
  notesEl.focus();
  notesEl.style.outline = "2px solid var(--danger)";
  return;
}

// 2) Speichern in drei klaren Pfaden
let saved = false;
if (hasM) saved = (await saveBlock("Morgen","M", /*includeWeight=*/false, /*force=*/false)) || saved;
if (hasA) saved = (await saveBlock("Abend","A", /*includeWeight=*/false, /*force=*/false)) || saved;
if (hasDaySummary) saved = (await saveDaySummary()) || saved;

if (!saved) { alert("Keine Daten eingegeben - nichts zu speichern."); return; }

// 3) UI aktualisieren
await renderDoctor();
if(chartPanel.open) await chartPanel.draw();

{ const s = (perfStats.add('saveEntry', performance.now()-__t0), perfStats.snap('saveEntry'));
diag.add(`[perf] saveEntry p50=${s.p50|0}ms p95=${s.p95|0}ms p99=${s.p99|0}ms (n=${s.count})`); }
flashSaveOk();
}

async function saveBlock(contextLabel, which, includeWeight=false, force=false){
const date = $("#date").value || todayStr();
const time = which === 'M' ? '07:00' : '22:00';

const sys   = $(`#sys${which}`).value   ? toNumDE($(`#sys${which}`).value)   : null;
const dia   = $(`#dia${which}`).value   ? toNumDE($(`#dia${which}`).value)   : null;
const pulse = $(`#pulse${which}`).value ? toNumDE($(`#pulse${which}`).value) : null;

const commentEl = document.getElementById(which === 'M' ? 'bpCommentM' : 'bpCommentA');
const comment = (commentEl?.value || '').trim();

const hasAny = (sys != null) || (dia != null) || (pulse != null);
const hasComment = comment.length > 0;

if (!force && !hasAny && !hasComment) return false;

if (hasAny){
  if ((sys != null && dia == null) || (dia != null && sys == null)){
    uiError('Bitte beide Blutdruck-Werte (Sys und Dia) eingeben.');
    return false;
  }
  if (pulse != null && (sys == null || dia == null)){
    uiError('Puls kann nur mit Sys und Dia zusammen gespeichert werden.');
    return false;
  }

  const currentISO = new Date(date + "T" + time).toISOString();
  const ts = new Date(date + "T" + time).getTime();

  const entry = {
    date, time, dateTime: currentISO, ts,
    context: contextLabel,
    sys, dia, pulse,
    weight: null,
    map: (sys!=null && dia!=null) ? calcMAP(sys, dia) : null,
    notes: '',
    training: false,
    low_intake: false,
    sick: false,
    valsartan_missed: false,
    forxiga_missed: false,
    nsar_taken: false,
    salt_high: false,
    protein_high90: false
  };

  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
}

if (hasComment){
  try {
    await appendNote(date, which === 'M' ? '[Morgens] ' : '[Abends] ', comment);
    if (commentEl) commentEl.value = '';
  } catch(_) { /* non blocking */ }
}

return hasAny || hasComment;
}

function baseEntry(date, time, contextLabel){
const iso = new Date(date + "T" + time).toISOString();
const ts = new Date(date + "T" + time).getTime();
return {
date, time, dateTime: iso, ts,
context: contextLabel, 
sys: null, dia: null, pulse: null, weight: null, map: null,
notes: ($("#notesDay").value || "").trim(),
training: trainingActive,
low_intake: lowIntakeActive,
sick: sickActive,
valsartan_missed: valsartanMissed,
forxiga_missed: forxigaMissed,
nsar_taken: nsarTaken,
salt_high: saltHigh,
protein_high90: proteinHigh
};
}

function allocateNoteTimestamp(date){
  const base = new Date(date + "T22:30:00");
  const now = Date.now();
  const minuteOffset = now % 60;
  const secondOffset = Math.floor(now / 1000) % 60;
  base.setMinutes(base.getMinutes() + minuteOffset);
  base.setSeconds(base.getSeconds() + secondOffset);
  const iso = base.toISOString();
  return { iso, ts: base.getTime(), time: iso.slice(11,16) };
}

async function appendNote(date, prefix, text){
  const trimmed = (text || "").trim();
  if (!trimmed) return;
  const stamp = allocateNoteTimestamp(date);
  const entry = baseEntry(date, stamp.time, "Tag");
  entry.dateTime = stamp.iso;
  entry.ts = stamp.ts;
  entry.notes = prefix + trimmed;
  entry.training = false;
  entry.low_intake = false;
  entry.sick = false;
  entry.valsartan_missed = false;
  entry.forxiga_missed = false;
  entry.nsar_taken = false;
  entry.salt_high = false;
  entry.protein_high90 = false;
  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
}

async function saveFlagsCommentNote(date, text){
  const trimmed = (text || '').trim();
  if (!trimmed) return false;
  const stamp = allocateNoteTimestamp(date);
  const entry = {
    date,
    time: stamp.time,
    dateTime: stamp.iso,
    ts: stamp.ts,
    context: "Tag",
    sys: null,
    dia: null,
    pulse: null,
    weight: null,
    map: null,
    notes: `[Flags] ${trimmed}`,
    training: false,
    low_intake: false,
    sick: false,
    valsartan_missed: false,
    forxiga_missed: false,
    nsar_taken: false,
    salt_high: false,
    protein_high90: false
  };
  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);

  const commentEl = document.getElementById(which === "M" ? "bpCommentM" : "bpCommentA");
  const comment = (commentEl?.value || "").trim();
  if (comment) {
    try {
      await appendNote(date, which === "M" ? "[Morgens] " : "[Abends] ", comment);
      if (commentEl) commentEl.value = "";
    } catch(_) { /* non blocking */ }
  }
  return true;
}

async function saveDaySummary(){
const date = $("#date")?.value || todayStr();
const time = "12:00";

const entry = baseEntry(date, time, "Tag");

// Gewicht (kg)
const w = $("#weightDay")?.value?.trim();
entry.weight = w ? Number((w||"").replace(',', '.')) : null;

// Bauchumfang (cm)
const waistRaw = $("#input-waist-cm")?.value?.trim();
entry.waist_cm = waistRaw ? toNumDE(waistRaw) : null;

const flagsComment = ($("#flagsComment")?.value || "").trim();
let saved = false;

const hasContent =
(entry.weight != null) ||
(entry.waist_cm != null) ||
!!entry.notes ||
entry.training || entry.low_intake || entry.sick ||
entry.valsartan_missed || entry.forxiga_missed ||
entry.nsar_taken || entry.salt_high || entry.protein_high90;

if (hasContent){
  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
  saved = true;
}

if (flagsComment){
  const savedNote = await saveFlagsCommentNote(date, flagsComment);
  if (savedNote){
    const el = document.getElementById('flagsComment');
    if (el) el.value = '';
    diag.add('Flags-Kommentar gespeichert');
    saved = true;
  }
}

return saved;
}

async function withRetry(fn, {tries=3, base=300}={}) {
let lastErr;
for (let i=0;i<tries;i++){
try { return await fn(); }
catch (e) {
const code = e?.status ?? e?.response?.status ?? 0;
if (!(code >= 500 && code < 600)) throw e;
await new Promise(r => setTimeout(r, base * Math.pow(2,i)));
lastErr = e;
}
}
throw lastErr;
}
  
async function syncWebhook(entry, localId){
  const url = await getConf("webhookUrl");
  const headers = await getHeaders();
  if(!url || !headers){
    uiError("Nicht angemeldet - bitte Google-Login ausfuehren.");
    showLoginOverlay(true);
    return;
  }

  try{
    const uid = await getUserId();
    const events = toHealthEvents(entry);
    if (!events.length){
      diag.add("Webhook: keine Events zu senden");
      return;
    }

    const payload = events.map(ev => (uid ? { ...ev, user_id: uid } : ev));
    const res = await withRetry(()=> fetch(url, { method:"POST", headers, body: JSON.stringify(payload) }));

    if(!res.ok){
      // Details ziehen (falls PostgREST JSON liefert)
      let details = "";
      try {
        const e = await res.json();
        details = (e?.message || e?.details || "");
      } catch { /* plain text? */ }

      // v1.2.1: Fallback for duplicate day_flags (upsert via PATCH)
      if (res.status === 409 || /duplicate|unique/i.test(details)) {
        const flagsEv = events.find(ev => ev.type === 'day_flags');
        try {
          if (flagsEv && uid) {
            const dayIso = entry.date;
            await patchDayFlags({ user_id: uid, dayIso, flags: flagsEv.payload });
            const others = events.filter(ev => ev.type !== 'day_flags');
            if (others.length) {
              const res2 = await withRetry(() => fetch(url, { method: "POST", headers, body: JSON.stringify(others.map(ev => ({ ...ev, user_id: uid }))) }));
              if (!res2.ok) throw new Error(`rest-post-failed-${res2.status}`);
            }
            uiInfo("Flags aktualisiert.");
            diag.add("Fallback: day_flags via PATCH");
            return;
          }
        } catch (_) { /* fallback failed: proceed to generic handling */ }
        }

        if (res.status === 409 || /duplicate|unique/i.test(details)) {
        uiError("Es gibt bereits einen Eintrag fuer diesen Tag/Kontext.");
      } else if (res.status === 422 || /invalid|range|pflicht|check constraint/i.test(details)) {
        uiError("Eingaben ungueltig - bitte Wertebereiche/Pflichtfelder pruefen.");
      } else if (res.status === 401 || res.status === 403) {
        uiError("Zugriff verweigert - bitte erneut anmelden.");
      } else {
        uiError(`Speichern fehlgeschlagen (HTTP ${res.status}).`);
      }

      diag.add(`Webhook-Fehler ${res.status}: ${details || "-"}`);
      throw new Error(`save-failed-${res.status}`);
    }

    const json = await res.json();
    const firstId = json?.[0]?.id ?? null;
    if(firstId != null){
      await updateEntry(localId, { remote_id: firstId });
      uiInfo("Gespeichert.");
      diag.add(`Webhook: OK (${events.length} Event(s))`);
    } else {
      uiError("Unerwartete Antwort vom Server - kein Datensatz zurueckgegeben.");
    }
  }catch(e){
    // Netzwerkfehler, 5xx nach Exhaust, etc.
    uiError("Netzwerkfehler beim Speichern. Bitte spaeter erneut versuchen.");
    diag.add("Webhook: Netzwerkfehler");
    throw e;
  }
}

/* ===== Realtime / Auto-Sync ===== */
let sbClient = null;

let __channels = [];
function trackChannel(ch){ __channels.push(ch); return ch; }
function teardownRealtime(){
try{
__channels.forEach(ch => ch.unsubscribe?.());
diag.add(`Realtime: ${__channels.length} Channel(s) unsubscribed`);
}catch(e){ diag.add("Realtime: unsubscribe error"); }
__channels = [];
}

window.addEventListener('beforeunload', teardownRealtime);


function baseUrlFromRest(restUrl){
if(!restUrl) return null;
const i = restUrl.indexOf("/rest/");
return i>0 ? restUrl.slice(0, i) : null;
}

async function getUserId(){
try{
const supa = await ensureSupabaseClient();
if(!supa) return null;
const { data: { user } } = await supa.auth.getUser();
return user?.id ?? null;
}catch{ return null; }
}

async function ensureSupabaseClient(){
if (sbClient) return sbClient;

const rest = await getConf("webhookUrl");
const keyConf = await getConf("webhookKey"); // ANON key (nicht service_role)
if (!rest || !keyConf) { diag.add("Supabase Auth: fehlende Konfiguration"); return null; }

// NEU: niemals mit service_role starten
if (isServiceRoleKey(keyConf)) {
diag.add("Sicherheitsblock: service_role Key erkannt - Abbruch");
return null;
}

const supabaseUrl = baseUrlFromRest(rest);
const anonKey = keyConf.replace(/^Bearer\s+/i,"");
if (!supabaseUrl || !anonKey) { diag.add("Supabase Auth: ungueltige URL/Key"); return null; }

sbClient = window.supabase.createClient(supabaseUrl, anonKey, {
auth: { persistSession:false, autoRefreshToken:true, detectSessionInUrl:true } // Session nur im RAM
});
diag.add("Supabase: Client (Auth) initialisiert");
return sbClient;
}

async function setupRealtime(){
  try{
    const supa = await ensureSupabaseClient();
    if (!supa) return;

    // Bestehende Channels schliessen, um Doppelbindungen zu vermeiden
    teardownRealtime();

    // Channel auf health_events - RLS begrenzt automatisch auf auth.uid()
    const ch = trackChannel(
      supa.channel('rt-health-events')
        .on('postgres_changes',
            { event: '*', schema: 'public', table: 'health_events' },
            (payload) => {
              // Optional: Zeitraum grob pruefen? (einfach halten: immer refreshen)
              livePulse();
              requestUiRefresh('realtime');
            })
        .subscribe((status) => {
          if (status === 'SUBSCRIBED') { diag.add?.('Realtime: subscribed'); }
        })
    );
  }catch(e){
    diag.add?.('Realtime: setup failed');
  }
}

/* ===== App-Lock (Passkey + PIN) ===== */
/* Doctor-only Unlock (no global lock) */
let __doctorUnlocked = false;
let __pendingAfterUnlock = null;
async function isWebAuthnAvailable(){
  if (!window?.PublicKeyCredential) return false;
  try{
    return await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
  }catch(_){
    return false;
  }
}

function configureLockOverlay({ hasPasskey = false, webAuthnAvailable = false, message = '', highlightSetup = false } = {}){
  const passBtn = document.getElementById('unlockPasskeyBtn');
  if (passBtn){
    const enable = webAuthnAvailable && hasPasskey;
    passBtn.disabled = !enable;
    passBtn.title = enable ? '' : (webAuthnAvailable ? 'Bitte zuerst Passkey einrichten.' : 'Passkey/WebAuthn nicht verfgbar.');
  }
  const setupBtn = document.getElementById('setupPasskeyBtn');
  if (setupBtn){
    setupBtn.disabled = !webAuthnAvailable;
    setupBtn.style.display = webAuthnAvailable ? 'block' : 'none';
    setupBtn.classList.toggle('flash', !!highlightSetup && webAuthnAvailable);
  }
  setLockMsg(message);
}

async function requireDoctorUnlock(){
  if (!(await isLoggedIn())) { showLoginOverlay(true); return false; }
  if (__doctorUnlocked) return true;

  let credId = null;
  try { credId = await getConf(LOCK_CRED_ID_KEY); } catch(_){ credId = null; }
  const hasPasskey = !!credId;
  const webAuthnAvailable = await isWebAuthnAvailable();

  if (hasPasskey && webAuthnAvailable){
    const ok = await unlockWithPasskey();
    if (ok) return true;

    configureLockOverlay({
      hasPasskey: true,
      webAuthnAvailable: true,
      message: 'Entsperren abgebrochen  du kannst Passkey erneut versuchen oder PIN nutzen.'
    });
    lockUi(true);
    return false;
  }

  if (!hasPasskey && webAuthnAvailable){
    configureLockOverlay({
      hasPasskey: false,
      webAuthnAvailable: true,
      message: 'Kein Passkey eingerichtet. Bitte Passkey einrichten oder PIN nutzen.',
      highlightSetup: true
    });
    lockUi(true);
    return false;
  }

  configureLockOverlay({
    hasPasskey,
    webAuthnAvailable: false,
    message: 'Passkey / Windows Hello ist auf diesem Gert nicht verfgbar. Bitte PIN verwenden.'
  });
  lockUi(true);
  return false;
}
async function resumeAfterUnlock(intent){
  const target = intent || __pendingAfterUnlock || 'doctor';
  __pendingAfterUnlock = null;
  if (target === 'chart'){
    await setTab('doctor');
    setDocBadges({ visible: true });
    chartPanel.open = true;
    if (chartPanel.el) chartPanel.el.style.display = 'block';
    await chartPanel.draw();
    return;
  }
  if (target === 'export'){
    await setTab('doctor');
    const all = await getAllEntries();
    dl('gesundheitslog.json', JSON.stringify(all,null,2), 'application/json');
    return;
  }
  await setTab('doctor');
}

/* Kleine Utils */
const u8 = (len)=>{ const a=new Uint8Array(len); crypto.getRandomValues(a); return a; };
const b64u = {
  enc: (buf)=> btoa(String.fromCharCode(...new Uint8Array(buf)))
                .replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''),
  dec: (str)=> Uint8Array.from(atob(str.replace(/-/g,'+').replace(/_/g,'/')), c=>c.charCodeAt(0))
};
async function sha256(text){
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return b64u.enc(buf);
}

/* Config-Keys in IndexedDB.CONF */
const LOCK_ENABLED_KEY   = "app_lock_enabled";     // bool
const LOCK_CRED_ID_KEY   = "lock_cred_id";         // base64url
const LOCK_PIN_HASH_KEY  = "lock_pin_hash";        // SHA-256 b64url
const LOCK_LAST_OK_KEY   = "lock_last_ok";         // timestamp

/* UI Helpers */
function lockUi(on){
  document.body.classList.toggle('app-locked', !!on);
  const ov = document.getElementById('appLock');
  if (ov){
    ov.style.display = on ? 'flex' : 'none';
    if (on){
      requestAnimationFrame(()=>{
        const pin = document.getElementById('pinInput');
        const pass = document.getElementById('unlockPasskeyBtn');
        if (pin && typeof pin.focus === 'function'){
          pin.focus();
          pin.select?.();
          return;
        }
        if (pass && !pass.disabled && typeof pass.focus === 'function'){
          pass.focus();
        }
      });
    } else {
      const pin = document.getElementById('pinInput');
      if (pin && typeof pin.blur === 'function'){ pin.blur(); }
    }
  }
}
function setLockMsg(msg){
  const el = document.getElementById('lockMsg');
  if (el) el.textContent = msg || '';
}

/* Setup: Passkey registrieren (platform) */
async function registerPasskey(){
  try{
    const rpId = location.hostname;
    const userId = u8(16);
    const challenge = u8(32);
    const pubKeyOpts = {
      publicKey: {
        challenge,
        rp: { name: "Gesundheits-Logger", id: rpId },
        user: { id: userId, name: "local-user", displayName: "Local User" },
        pubKeyCredParams: [{ type:'public-key', alg:-7 }, { type:'public-key', alg:-257 }],
        timeout: 60000,
        authenticatorSelection: { authenticatorAttachment: 'platform', userVerification: 'preferred', residentKey: 'preferred' },
        attestation: 'none'
      }
    };
    const cred = await navigator.credentials.create(pubKeyOpts);
    if (!cred) throw new Error("Keine Antwort vom Authenticator.");
    const idB64 = b64u.enc(cred.rawId);
    await putConf(LOCK_CRED_ID_KEY, idB64);
    await putConf(LOCK_ENABLED_KEY, true);
    const waAvailable = await isWebAuthnAvailable();
    configureLockOverlay({ hasPasskey: true, webAuthnAvailable: waAvailable, message: 'Passkey eingerichtet - bitte kurz entsperren.' });
    setLockMsg('Passkey eingerichtet.');
    return true;
  }catch(e){
    setLockMsg("Passkey-Setup fehlgeschlagen: " + (e.message||e));
    return false;
  }
}

/* Entsperren per Passkey (nur Besitz+UV Check - lokal ausreichend fuer App-Lock) */
async function unlockWithPasskey(){
  try{
    const credId = await getConf(LOCK_CRED_ID_KEY);
    if (!credId){
      setLockMsg("Noch kein Passkey eingerichtet.");
      return false;
    }
    const allow = [{ type:'public-key', id: b64u.dec(credId) }];
    const challenge = u8(32);
    const opts = { publicKey: { challenge, rpId: location.hostname, timeout: 60000, allowCredentials: allow, userVerification:'preferred' } };
    const assertion = await navigator.credentials.get(opts);
    if (!assertion) throw new Error("Abgebrochen.");
    // Lokaler Gate: Erfolg der Challenge => entsperrt
    await putConf(LOCK_LAST_OK_KEY, Date.now());
    __doctorUnlocked = true;
    lockUi(false);
    try {
      await resumeAfterUnlock();
    } catch(_) {}
    return true;
  }catch(e){
    setLockMsg("Passkey fehlgeschlagen: " + (e.message||e));
    return false;
  }
}

/* PIN setzen/pruefen */
async function setPinInteractive(){
  const pin = prompt("Neue PIN (4-10 Ziffern):") || "";
  if (!/^\d{4,10}$/.test(pin)){ alert("Ungueltige PIN."); return false; }
  const hash = await sha256("pin:"+pin);
  await putConf(LOCK_PIN_HASH_KEY, hash);
  await putConf(LOCK_ENABLED_KEY, true);
  setLockMsg("PIN gesetzt ");
  return true;
}
async function unlockWithPin(){
  const input = document.getElementById('pinInput');
  const pin = (input?.value||"").trim();
  if (!pin){ setLockMsg("PIN eingeben."); return false; }
  const saved = await getConf(LOCK_PIN_HASH_KEY);
  if (!saved){ setLockMsg("Keine PIN hinterlegt."); return false; }
  const hash = await sha256("pin:"+pin);
  if (hash !== saved){ setLockMsg("PIN falsch."); return false; }
  await putConf(LOCK_LAST_OK_KEY, Date.now());
  input.value = "";
  __doctorUnlocked = true;
  lockUi(false);
  try { await resumeAfterUnlock(); } catch(_) {}
  return true;
}

/* Events binden (einmal in main()) */
function bindAppLockButtons(){
  const btnPass = document.getElementById('unlockPasskeyBtn');
  const btnPin  = document.getElementById('unlockPinBtn');
  const btnSetPass = document.getElementById('setupPasskeyBtn');
  const btnSetPin  = document.getElementById('setPinBtn');

  if (btnPass) btnPass.addEventListener('click', unlockWithPasskey);
  if (btnPin)  btnPin.addEventListener('click', unlockWithPin);
  if (btnSetPass) btnSetPass.addEventListener('click', registerPasskey);
  if (btnSetPin)  btnSetPin.addEventListener('click', setPinInteractive);
  const pinInput = document.getElementById('pinInput');
  if (pinInput) pinInput.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){ e.preventDefault(); unlockWithPin(); }
  });
  const overlay = document.getElementById('appLock');
  if (overlay) overlay.addEventListener('click', (e)=>{ if (e.target === overlay){ __pendingAfterUnlock = null; lockUi(false); } });
  const cancelBtn = document.getElementById('lockCancelBtn');
  if (cancelBtn) cancelBtn.addEventListener('click', ()=>{ __pendingAfterUnlock = null; lockUi(false); });
}

/* ===== Main ===== */
async function main(){
diag.init(); helpPanel.init(); await initDB();
try {
const haveUrl = await getConf("webhookUrl");
const haveKey = await getConf("webhookKey");
if (!haveUrl && SUPABASE_URL_DEFAULT) await putConf("webhookUrl", DEFAULT_WEBHOOK_ENTRIES);
if (!haveKey && SUPABASE_ANON_DEFAULT) await putConf("webhookKey", `Bearer ${SUPABASE_ANON_DEFAULT}`);
} catch (_) {}
chartPanel.init(); bindTabs();
$("#date").value = todayStr();
$("#from").value = new Date(Date.now()-90*24*3600*1000).toISOString().slice(0,10);
$("#to").value = todayStr();
setTab("capture");
await ensureSupabaseClient();
try{ await syncCaptureFlagTogglesForCurrentDate(); }catch(_){}
bindAuthButtons();
if (sbClient) watchAuthState()

// Wenn schon eingeloggt ? App starten, sonst Login-Leiste zeigen
const hasSession = await requireSession();
if (hasSession) {
  await afterLoginBoot(); // wichtig fuer Reload mit persistierter Session
      // Doctor-Unlock: nur bei Arzt-Ansicht (kein globaler App-Lock)  //  App-Lock direkt nach Boot pruefen/anzeigen
  await setupRealtime();  //  NEU: Realtime direkt aktivieren
  await requestUiRefresh();
}
bindAppLockButtons();     //  Buttons der Lock-Card binden

// Konfiguration laden
const savedUrl = await getConf("webhookUrl");
const savedKey = await getConf("webhookKey");
// Diagnose: aktive REST-URL und Key-Typ
try{
  diag.add?.('Config URL: ' + (savedUrl || '(none)'));
  diag.add?.('Config Key: ' + (savedKey ? (isServiceRoleKey(savedKey) ? 'service_role(BLOCKED)' : 'anon/ok') : '(none)'));
}catch(_){ }
if (!savedUrl || !savedKey) {
  setTab("capture"); // In Erfassung bleiben
}

// Sanfte Warnung
// === Live-Kommentar-Pflicht: sofort roter Rand bei Grenzwertueberschreitung ===
function needsCommentNow(){
  const sysM = Number($("#sysM").value);
  const diaM = Number($("#diaM").value);
  const sysA = Number($("#sysA").value);
  const diaA = Number($("#diaA").value);
  return (sysM > 130) || (diaM > 90) || (sysA > 130) || (diaA > 90);
}
function updateNotesRequirementUI(){
  const notesEl = $("#notesDay");
  if (!notesEl) return;
  const notes = (notesEl.value || "").trim();
  const need = needsCommentNow();
  const invalid = need && !notes;
  notesEl.style.outline = invalid ? "2px solid var(--danger)" : "";
  if (invalid) notesEl.setAttribute("aria-invalid","true"); else notesEl.removeAttribute("aria-invalid");
}
// bei jeder Eingabe der vier BP-Felder + Kommentar selbst neu bewerten
["#sysM","#diaM","#sysA","#diaA","#notesDay"].forEach(sel=>{
  const el = $(sel); if(!el) return;
  el.addEventListener("input", updateNotesRequirementUI);
});
// einmal initial pruefen (falls Werte schon stehen)
updateNotesRequirementUI();

// Toggle-Handler
const bindToggle = (id, setter, getVal)=>{
  const el = $(id);
  el.addEventListener("click", ()=>{
    setter(!getVal());
  });
};
bindToggle("#trainingToggle", setTraining, ()=>trainingActive);
bindToggle("#lowIntakeToggle", setLowIntake, ()=>lowIntakeActive);
bindToggle("#sickToggle", setSick, ()=>sickActive);
bindToggle("#valsartanMissToggle", setValsartanMiss, ()=>valsartanMissed);
bindToggle("#forxigaMissToggle", setForxigaMiss, ()=>forxigaMissed);
bindToggle("#nsarToggle", setNsar, ()=>nsarTaken);
bindToggle("#saltHighToggle", setSaltHigh, ()=>saltHigh);
bindToggle("#proteinHighToggle", setProteinHigh, ()=>proteinHigh);

document.getElementById("saveAllBtn").addEventListener("click", async (e)=>{
  const btn = e.currentTarget;
  withBusy(btn, true);
  try {
    await saveAll();
  } catch(_) {
    // Fehler werden in saveAll/syncWebhook via uiError gezeigt
  } finally {
    withBusy(btn, false);
  }
});
// Sync toggles when the date changes in capture view
const __dateEl = document.getElementById('date');
if (__dateEl) __dateEl.addEventListener('change', async ()=>{ try{ await syncCaptureFlagTogglesForCurrentDate(); }catch(_){}});
$("#applyRange").addEventListener("click", async ()=>{
  await renderDoctor();
setDocBadges({ visible: true });
  if(chartPanel.open) chartPanel.draw();
});

$("#doctorChartBtn").addEventListener("click", async ()=>{
  if (!(await isLoggedIn())){ showLoginOverlay(true); return; }
  if (!__doctorUnlocked){
    __pendingAfterUnlock = 'chart';
    const ok = await requireDoctorUnlock();
    if (!ok) return;
    __pendingAfterUnlock = null;
  }
  setDocBadges({ visible: true });
  chartPanel.open = true;
  if (chartPanel.el) chartPanel.el.style.display = 'block';
  await chartPanel.draw();
});

document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape' && document.body.classList.contains('app-locked')){
    __pendingAfterUnlock = null;
    lockUi(false);
  }
});

document.addEventListener('keydown', (e)=>{
const isSave = (e.key.toLowerCase()==='s') && (e.ctrlKey || e.metaKey);
if(isSave){ e.preventDefault(); saveAll(); }
});

document.addEventListener('visibilitychange', ()=>{
  if (document.visibilityState === 'visible'){
    const doctorActive = document.getElementById('doctor')?.classList.contains('active');
    if (!doctorActive){
      __pendingAfterUnlock = null;
      lockUi(false);
    }
  }
});

  $("#doctorExportJson").addEventListener("click", async ()=>{
  if (!(await isLoggedIn())){ showLoginOverlay(true); return; }
  if (!__doctorUnlocked){
    __pendingAfterUnlock = 'export';
    const ok = await requireDoctorUnlock();
    if (!ok) return;
    __pendingAfterUnlock = null;
  }
  const all = await getAllEntries();
  dl("gesundheitslog.json", JSON.stringify(all,null,2), "application/json");
});
  
// Lifestyle binden und initial (falls bereits angemeldet) laden
bindLifestyle();
try { if (await isLoggedIn()) { await cleanupOldIntake(); await renderLifestyle(); } } catch(_){ }

// Initial Render
await renderDoctor();
setDocBadges({ visible: true });

// --- Failsafe: nach Reload alles sicher freigeben (falls etwas "disabled" haengen blieb)
$$('main input, main select, main textarea, main button, nav.tabs button').forEach(el=>{
el.disabled = false;
});
document.body.classList.remove('auth-locked');

// Auto-Push Pending sobald online
window.addEventListener('online', async ()=>{
const resPush = await pushPendingToRemote();
if(resPush.pushed || resPush.failed){
diag.add(`Online-Push: OK=${resPush.pushed}, FAIL=${resPush.failed}`);
await reconcileFromRemote();
}
});
}

/* boot */
if (document.readyState === "loading") {
window.addEventListener("DOMContentLoaded", main);
} else {
main();
}

/* === Debug-Notizen
- V1.5: Realtime ueber supabase-js; Projekt-URL aus REST-URL abgeleitet.
- Auto-Sync: push pending ? reconcile (Entries) ohne Wipe.
- Realtime-Events: INSERT/UPDATE ? upsert, DELETE ? lokal entfernen.
- UI-Refresh: Arzt-Ansicht sofort; Charts nur, wenn Panel offen.
=== */
</script>
<!-- Login-Overlay (zentriert) -->
<div id="loginOverlay" style="display:none">
  <div class="login-card" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
    <h3 id="loginTitle">Willkommen</h3>
    <p class="small" style="margin:0 0 8px">Melde dich an, um Arzt-Ansicht & Diagramme zu nutzen.</p>
    <button class="btn primary" id="googleLoginBtn" type="button" style="width:100%;height:48px">Mit Google anmelden</button>
    <div id="whoAmI" class="small" style="text-align:center;margin-top:6px"></div>
  </div>
</div>

<!-- App-Lock Overlay (zentriert) -->
<div id="appLock" style="display:none">
  <div class="lock-card" role="dialog" aria-modal="true" aria-labelledby="lockTitle">
    <h3 id="lockTitle">App gesperrt</h3>
    <p class="small" style="margin:0 0 8px">
      Bitte entsperren: bevorzugt per Passkey (Finger/Face). Alternativ PIN.
    </p>

    <div class="row" style="gap:8px">
      <button class="btn primary" id="unlockPasskeyBtn" type="button" style="width:100%;height:48px">
        Per Passkey entsperren
      </button>
    </div>

    <div class="pin-wrap">
      <input id="pinInput" type="password" inputmode="numeric" autocomplete="off" placeholder="PIN (optional)" />
      <button class="btn ghost" id="unlockPinBtn" type="button">PIN</button>
    </div>

    <div class="small" style="margin-top:8px; opacity:.8">
      <button class="btn ghost" id="setupPasskeyBtn" type="button" style="width:100%;margin-top:6px">
        Passkey einrichten
      </button>
      <button class="btn ghost" id="setPinBtn" type="button" style="width:100%;margin-top:6px">
        PIN setzen/aendern
      </button>
    </div>

    <button class="btn ghost" id="lockCancelBtn" type="button" style="width:100%;margin-top:8px">
      Abbrechen
    </button>

    <div id="lockMsg" class="small" style="margin-top:6px;color:#6b7280"></div>
  </div>
</div>

</body>
</html>






































