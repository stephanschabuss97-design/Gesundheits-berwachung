<!DOCTYPE html>
<!-- MODULE: BOOTSTRAP & CONSTANTS
  intent: HTML-Grundgeruest, Meta-Bootstrap, Basis-Themetokens fuer den Monolithen
  contracts: definiert Head-Struktur, laedt globale Styles, bereitet Container fuer nachgelagerte Module vor
  notes: Kommentarpflege; Markup fuer W3C-Compliance unveraendert lassen
-->
<html lang="de">
<head>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://*.supabase.co wss://*.supabase.co; img-src 'self' data:; font-src 'self' data:; object-src 'none'; base-uri 'self';">
<title>Gesundheits-Logger (V1.7.6)</title>
<style>

/* ANKER: chart-controls styles (move to assets/app.css bei naechster Release) */
  /* Dropdown optisch kompakter */
  #chart .controls .compact { max-width: 240px; }

  /* KPI-Zeile: -Werte neben dem Dropdown */
  #chart .controls .kpis {
    display: inline-flex;
    gap: 16px;
    align-items: center;
    margin-left: 16px;
    color: var(--text, #e5e7eb);
    font-size: 0.95rem;
    white-space: nowrap;
  }
  #chart .controls .kpis .sep { opacity: .6; }
  
body.auth-locked main{ opacity:.6; }
:root {
  --bg:#121417;
  --card:#1c1e22;
  --card-layer2:#202225;
  --fg:#e8eaec;
  --muted:#b0b3b8;
  --disabled:#6c6e70;
  --accent:#3a3dff;
  --warn:#ff6b6b;
  --ok:#2ecc71;
  --danger:#ff6b6b;
  --border-subtle:rgba(255,255,255,0.06);
  --shadow-soft:0 8px 24px rgba(0,0,0,.25);
  --surface-elevated:rgba(255,255,255,0.03);
  --chart-line-primary:#3a3dff;
  --chart-line-primary-soft:#7d81ff;
  --chart-line-secondary:#b0b3ff;
  --chart-line-tertiary:#c6c9ff;
  --chart-line-dia:#ff87b5;
  --chart-line-weight:#7d81ff;
  --chart-line-waist:#a9afb7;
  --chart-bar-muscle:#3a3dff;
  --chart-bar-fat:#cfa24a;
  --chart-goal-sys:rgba(58,61,255,0.12);
  --chart-goal-dia:rgba(176,179,184,0.16);
  --chart-tooltip-bg:rgba(20,23,28,0.96);
  --header-h:56px;
  --tabs-h:48px;
}
*{box-sizing:border-box}
.sr-only{
  position:absolute;
  width:1px;
  height:1px;
  padding:0;
  margin:-1px;
  overflow:hidden;
  clip:rect(0,0,0,0);
  white-space:nowrap;
  border:0;
}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial;background:var(--bg);color:var(--fg);-webkit-tap-highlight-color:transparent;touch-action:manipulation;overscroll-behavior-y:none}
header{
  position:sticky;
  top:0;
  background:linear-gradient(180deg,rgba(18,20,23,.95),rgba(18,20,23,.75));
  backdrop-filter:blur(6px);
  z-index:10;
  padding:10px 12px;
  border-bottom:1px solid rgba(255,255,255,0.05);
  transition:box-shadow .25s ease, border-color .25s ease, background .25s ease;
}
header.is-elevated{
  box-shadow:0 12px 28px rgba(0,0,0,0.35);
  border-bottom:1px solid rgba(255,255,255,0.08);
  background:linear-gradient(180deg,rgba(18,20,23,1),rgba(18,20,23,0.85));
}
h1{margin:0;font-size:20px}
nav.tabs{
  display:flex;
  gap:8px;
  padding:8px 12px 14px;
  position:sticky;
  top:var(--header-h,56px);
  background:rgba(18,20,23,0.92);
  backdrop-filter:blur(6px);
  z-index:11;
  transition:box-shadow .25s ease, background .25s ease;
}
nav.tabs.is-elevated{
  box-shadow:0 10px 24px rgba(0,0,0,0.28);
  background:rgba(18,20,23,0.96);
}
nav.tabs button{flex:1;min-width:100px;touch-action:manipulation}
main{padding:12px;position:relative;z-index:1;padding-top:calc(var(--header-h,56px) + var(--tabs-h,48px) + 8px)}
.card{
  --panel-bg:var(--card);
  background:var(--panel-bg);
  border:1px solid var(--border-subtle);
  border-radius:8px;
  padding:24px 20px;
  margin-bottom:24px;
  box-shadow:var(--shadow-soft);
}
.row{display:flex;gap:8px;flex-wrap:wrap}
.grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
@media (max-width:640px){ .grid{grid-template-columns:1fr} }
label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px;letter-spacing:0.2px}
input, select, textarea {
  width:100%;
  padding:12px 14px;
  border-radius:8px;
  border:1px solid var(--border-subtle);
  background:var(--surface-elevated);
  color:var(--fg);
  font-size:1rem;
  transition:border-color .25s ease, box-shadow .25s ease, background .25s ease;
  scroll-margin-top:calc(var(--header-h,56px) + var(--tabs-h,48px) + 8px);
}
input::placeholder,
select::placeholder,
textarea::placeholder{
  color:var(--muted);
  opacity:.65;
}
input:focus-visible,
select:focus-visible,
textarea:focus-visible{
  outline:none;
  border-color:var(--accent);
  box-shadow:0 0 0 2px rgba(58,61,255,0.25);
}
textarea{min-height:64px;resize:vertical}

.small{font-size:12px;color:var(--muted)}
.btn{
  appearance:none;
  border:none;
  border-radius:8px;
  padding:0 18px;
  height:40px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:600;
  font-size:1rem;
  letter-spacing:0.2px;
  color:var(--fg);
  background:rgba(43,47,58,0.92);
  cursor:pointer;
  touch-action:manipulation;
  transition:background .2s ease, color .2s ease, transform .1s ease, box-shadow .2s ease;
}
.btn:disabled{
  opacity:.6;
  cursor:not-allowed;
}
.btn:focus-visible{
  outline:none;
  box-shadow:0 0 0 2px rgba(58,61,255,0.3);
}
.btn:not(:disabled):hover{
  filter:brightness(1.08);
}
.btn:not(:disabled):active{
  transform:scale(0.98);
}
.btn.primary{
  background:rgba(58,61,255,0.85);
  color:#fff;
  box-shadow:0 8px 20px rgba(58,61,255,0.18);
}
.btn.primary:focus-visible{
  box-shadow:0 0 0 3px rgba(58,61,255,0.3), 0 8px 20px rgba(58,61,255,0.18);
}
.btn.primary:not(:disabled):hover{
  filter:brightness(1.06);
}
.btn.ghost{
  background:rgba(43,47,58,0.35);
  border:1px solid var(--border-subtle);
  color:var(--fg);
}
.btn.ghost:not(:disabled):hover{
  background:rgba(255,255,255,0.05);
}
.btn.warn{
  background:var(--warn);
  color:#121417;
}
.btn.warn:not(:disabled):hover{
  filter:brightness(1.05);
}
.btn.toggle{
  border:1px solid var(--border-subtle);
  background:var(--surface-elevated);
  color:var(--fg);
}
.btn.toggle.active{
  background:var(--ok);
  border-color:rgba(46,204,113,0.4);
  color:#062615;
}
/* Tabs: aktiver Zustand = wie Primary */
nav.tabs .btn{
  height:40px;
  padding:0 16px;
  border-radius:8px;
  background:transparent;
  border:1px solid transparent;
  color:var(--muted);
  position:relative;
  transition:color .2s ease, border-color .2s ease, background .2s ease, box-shadow .2s ease;
}
nav.tabs .btn:not(.primary):hover{
  color:var(--fg);
  border-color:var(--border-subtle);
  background:var(--surface-elevated);
}
nav.tabs .btn:focus-visible{
  outline:none;
  box-shadow:0 0 0 2px rgba(58,61,255,0.25);
}
nav.tabs .btn.primary {
  color:#fff;
  background:rgba(58,61,255,0.2);
  border-color:rgba(58,61,255,0.35);
  box-shadow:0 10px 25px rgba(58,61,255,0.18);
}
nav.tabs .btn.primary::after{
  content:"";
  position:absolute;
  left:12px;
  right:12px;
  bottom:-6px;
  height:2px;
  border-radius:999px;
  background:var(--accent);
  box-shadow:0 4px 12px rgba(58,61,255,0.35);
}
.accordion{
  background:var(--card-layer2);
  border:1px solid var(--border-subtle);
  border-radius:8px;
  margin:24px 0;
  overflow:hidden;
  transition:border-color .2s ease, background .2s ease, box-shadow .2s ease;
  box-shadow:var(--shadow-soft);
}
.accordion summary{
  list-style:none;
  cursor:pointer;
  padding:18px 20px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  font-weight:600;
  color:var(--fg);
  letter-spacing:0.3px;
  transition:background .2s ease, color .2s ease;
  position:relative;
}
.accordion summary::after{
  content:"";
  position:absolute;
  left:20px;
  right:20px;
  bottom:0;
  height:1px;
  background:var(--border-subtle);
  transition:background .2s ease;
}
.accordion summary::-webkit-details-marker{display:none;}
.accordion .chevron{
  transition:transform .2s ease;
}
.accordion[open] .chevron{
  transform:rotate(90deg);
}
.accordion summary:hover{
  background:rgba(58,61,255,0.06);
}
.accordion[open]{
  border-color:rgba(58,61,255,0.3);
  box-shadow:0 12px 28px rgba(0,0,0,0.28);
}
.accordion[open] summary{
  background:rgba(58,61,255,0.08);
}
.accordion[open] summary::after{
  background:rgba(58,61,255,0.15);
}
.accordion summary:focus-visible{
  outline:none;
  box-shadow:inset 0 0 0 2px rgba(58,61,255,0.25);
}
.accordion .accordion-body{
  padding:0 20px 20px;
  display:flex;
  flex-direction:column;
  gap:24px;
}
.bp-pane{display:none;}
.bp-pane.active{display:block;}
.panel-actions{
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  justify-content:flex-start;
  align-items:center;
  margin:24px 0 0;
}
.panel-actions .btn{min-width:160px;}
.card.panel-flash,
.card-nested.panel-flash{
  animation:panelFlash 0.45s ease-in-out forwards;
}
@keyframes panelFlash{
  0%{
    box-shadow:var(--shadow-soft);
    background:var(--panel-bg);
  }
  40%{
    box-shadow:0 0 0 3px rgba(46,204,113,0.45), 0 14px 30px rgba(46,204,113,0.18);
    background:rgba(46,204,113,0.12);
  }
  100%{
    box-shadow:var(--shadow-soft);
    background:var(--panel-bg);
  }
}
.card-nested{
  --panel-bg:var(--card-layer2);
  background:var(--panel-bg);
  border:1px solid var(--border-subtle);
  border-radius:8px;
  padding:24px 20px;
  margin-top:24px;
  box-shadow:var(--shadow-soft);
}
.card-nested:first-of-type{margin-top:0;}
.card-nested h3.blockTitle{margin-top:0;}
@media (max-width:640px){
  .accordion summary{padding:14px 16px;}
  .accordion .accordion-body{padding:0 16px 18px;}
}


.btn.flash{
  background:linear-gradient(90deg,var(--accent) 0%,#7c3aed 50%,var(--accent) 100%)!important;
  background-size:200% 100%;
  color:#fff!important;
  animation:flashGradient 1s ease forwards,flashPop .2s ease;
  box-shadow:0 6px 24px rgba(79,70,229,.35);
  border-radius:8px;
  height:40px;
}
@keyframes flashGradient{0%{background-position:0% 50%}100%{background-position:100% 50%}}
@keyframes flashPop {
0% { transform: scale(1) }
50% { transform: scale(1.03) }
100% { transform: scale(1) }
}

/* Toolbar mit zentrierter Mitte + Badges rechts */
#doctorCard .toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: space-between; /* Titel links + Mitte + Badges rechts */
}

#doctorCard .toolbar .center-group {
  flex: 1;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center; /* Buttons + Datum + Anwenden mittig */
}

#doctorCard .toolbar .badge {
  margin-left: 8px;
}

.spacer{flex:1}
section.view{display:none}
section.view.active{display:block}

#doctorCard .toolbar{border-bottom:1px solid #242833;padding-bottom:8px;margin-bottom:8px}

#err{position:fixed;left:8px;right:8px;bottom:8px;background:#3d0d0d;color:#fecaca;padding:8px 10px;border-radius:10px;display:none;z-index:9999}

/* === Arzt-Ansicht (Daily): 3-Spalten-Layout je Tag === */
.doctor-view .doctor-day{
display:grid;
grid-template-columns: 1fr; /* Standard = gestapelt */
gap:12px;
align-items:start;
padding:12px 14px;
margin:8px 0;
border-radius:12px;
background:var(--card);
border:1px solid #242833;
box-shadow:0 6px 18px rgba(0,0,0,.25);
page-break-inside:avoid;
break-inside:avoid;
}

  /* --- Arzt-Toolbar Badges (Daily KPIs) --- */
.badge {
  display: inline-block;
  padding: 6px 12px;         /* etwas mehr Platz */
  border: 1.5px solid #2b2f3a;
  border-radius: 12px;       /* runder = moderner */
  font-size: 13px;           /* +1pt groesser */
  font-weight: 600;          /* kraeftiger */
  margin-left: 10px;
}
.badge.good{border-color:var(--ok); color:var(--ok)}
.badge.bad{ border-color:var(--danger); color:var(--danger)}
.badge.hidden{ display:none !important; }

/* Tablet/Desktop: nebeneinander */
@media (min-width: 900px){
.doctor-view .doctor-day{
grid-template-columns: 18% 46% 36%;
}
}

/* Zwischenbereich: 2 Spalten */
@media (min-width: 600px) and (max-width: 899px){
.doctor-view .doctor-day{
grid-template-columns: 40% 60%;
grid-template-areas:
"date measure"
"date special";
}
.doctor-view .col-date{ grid-area: date; }
.doctor-view .col-measure{ grid-area: measure; }
.doctor-view .col-special{ grid-area: special; }
}

/* Spalte A - Datum */
.doctor-view .col-date{
display:flex; align-items:center;
font-weight:800;
font-size:clamp(16px,1.6vw,20px);
letter-spacing:.2px;
}
  /* Datumsspalte mit Cloud + Delete untereinander */
.doctor-view .col-date{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.doctor-view .col-date .date-top{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}
.doctor-view .col-date .date-label{
  font-weight:800;
  font-size:clamp(16px,1.6vw,20px);
  letter-spacing:.2px;
}
.doctor-view .col-date .date-cloud{ font-size:16px; line-height:1; }
.doctor-view .col-date .date-actions{
  display:flex;
  justify-content:flex-start; /* oder center, wenn du's mittig magst */
}
.btn-xs{ padding:6px 10px; font-size:12px; border-radius:8px; }

/* Spalte B - Messungen */
.doctor-view .col-measure{ display:grid; grid-template-rows:auto 1fr; gap:6px; }
/* Kopf und Werte-Spalten: gleiche Breiten wie Zahlen, Label links fix */
.doctor-view .measure-head,
.doctor-view .measure-grid{
display:grid;
grid-template-columns: minmax(70px, auto) repeat(4, 1fr);
gap:4px;
}
.doctor-view .measure-head{ font-size:12px; opacity:.8; }


/* Head-Zellen als Flex: rechtsbuendig wie die Zahlen */
.doctor-view .measure-head > div{ display:flex; align-items:center; }
.doctor-view .measure-head > div:first-child{ justify-content:flex-start; }
.doctor-view .measure-head > div:not(:first-child){ justify-content:flex-end; }
.doctor-view .measure-row{ display:contents; }
.doctor-view .label{ display:flex; align-items:center; font-size:13px; opacity:.9; }

/* Zahlenbild */
.doctor-view .num{
font-variant-numeric: tabular-nums lining-nums;
-moz-font-feature-settings:"tnum","lnum";
-webkit-font-feature-settings:"tnum","lnum";
font-feature-settings:"tnum","lnum";
text-align:right;
display:flex; align-items:center; justify-content:flex-end;

min-width: 4ch; /* Basisschutz gegen Abschneiden */
white-space: nowrap;
}
  
  /* Grenzwert-Highlight fuer Arzt-Ansicht */
.doctor-view .num.alert{ color: var(--danger); }

.doctor-view .measure-grid .num,
.doctor-view .col-special .num{
text-align:right; justify-content:flex-end;
}

/* Spalte C - Spezialinfos */
/* Gewicht: Ueberschrift + Zahl darunter */
.doctor-view .weight-line,
.doctor-view .waist-line{
  display:flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  background: transparent;
  border: none;
  padding: 0;
  font-weight: 600;
}

.doctor-view .weight-line > :first-child,
.doctor-view .waist-line > :first-child{
  font-size: 12px;
  opacity:.8;
  font-weight:600;
  letter-spacing:.2px;
}

.doctor-view .weight-line .num,
.doctor-view .waist-line .num{
  font-size:clamp(16px,1.6vw,20px);
  font-weight:700;
  line-height:1.1;
  text-align:center;
}

/* Spalten C/D/E: Gewicht | Flags | Kommentar */
.doctor-view .col-special{
  display: grid;
  grid-template-columns: minmax(120px, max-content) 220px 1fr; /* C | D | E */
  column-gap: 16px;
  row-gap: 6px;
  align-items: start; /* <-- alles oben ausrichten */
}

/* Elemente gezielt in Spalten setzen */
.doctor-view .col-special > .weight-line,
.doctor-view .col-special > .waist-line { grid-column: 1; }
.doctor-view .col-special > .flags       { grid-column: 2; }
.doctor-view .col-special > .notes       { grid-column: 3; }

/* D: Flags - Desktop: eine Spalte untereinander */
.doctor-view .flags{
  display:grid;
  grid-template-columns: repeat(2, max-content); /* 2 Spalten */
  justify-content:start;
  align-items:start;
  gap: 6px 16px; /* vertikal 6px, horizontal 16px */
}

.doctor-view .weight-line .num,
.doctor-view .waist-line .num{ font-variant-numeric: tabular-nums; } /* Spalten wirken ruhiger */
.doctor-view .flag span:last-child{ white-space:nowrap; }
.doctor-view .flag{ display:grid; grid-template-columns:18px 1fr; align-items:center; gap:6px; font-size:12px; opacity:.95; }
.doctor-view .flag-box{
width:16px; height:16px; border:1.5px solid #2b2f3a; border-radius:3px; display:inline-block; position:relative;
}
.doctor-view .flag-box.on::after{
content:""; position:absolute; inset:2px; background:var(--accent); border-radius:2px;
}

/* Notizen: im Screen 3 Zeilen, im Druck voll */
/* Kommentar: Titel + Box */
/* Kommentar: Kopf + Wert, ohne Kasten */
.doctor-view .notes{
  font-size: 13px;
  line-height: 1.35;
  display: -webkit-box;
  -webkit-line-clamp: 3;      /* 3 Zeilen, bei Bedarf 2 setzen */
  -webkit-box-orient: vertical;
  overflow: hidden;
  word-break: break-word;
  padding: 0;                 /* kein Box-Feeling */
  background: transparent;
  border: none;
}
.doctor-view .notes::before{
  content: "Kommentar";
  display: block;
  font-size: 12px;
  opacity: .8;
  font-weight: 600;
  letter-spacing: .2px;
  margin-bottom: 4px;
}
/* NICHT ausblenden, auch wenn leer - der Renderer liefert "-" */

/* Mobile-Optimierung */
@media (max-width: 599px){

  /* Kopf & Werte: schmaelere Label-Spalte + garantierte Zahlbreite */
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(72px, 1fr) repeat(4, minmax(56px, 1fr));
  }
  .doctor-view .measure-head{ font-size: 11px; }

  /* Zahlen duerfen nicht schrumpfen  keine abgeschnittenen Dezimalstellen */
  .doctor-view .num{
    min-width: 4.5ch; /* ~ "96.7" passt sicher */
    white-space: nowrap;
    flex: 0 0 auto;
  }
.doctor-view .col-special .weight-line .num,
.doctor-view .col-special .waist-line .num{
  min-width: 5ch;
}

  /* Spalten: Gewicht | Flags nebeneinander, Kommentar darunter ueber volle Breite */
  .doctor-view .col-special{
    grid-template-columns: minmax(110px, max-content) 1fr; /* Flags bekommen flex Breite */
    column-gap: 12px;
  }
  .doctor-view .col-special > .notes{
    grid-column: 1 / -1; /* Kommentar ueber beide Spalten */
  }

  /* Kommentar: mobil 4 Zeilen anzeigen */
  .doctor-view .notes{
    -webkit-line-clamp: 4; /* bei Bedarf auf 5 erhoehen */
  }

  /* Flags: kompakt in 2 Spalten, keine abgeschnittenen Labels */
  .doctor-view .flags{
    display: grid;
    grid-template-columns: repeat(2, max-content);
    justify-content: start;
    align-items: center;
    column-gap: 14px;
    row-gap: 6px;
    margin-top: 6px;
  }
  .doctor-view .flag span:last-child{ white-space: nowrap; }
}

/* Extra-eng ( 390px Breite) */
@media (max-width: 390px){
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(66px, 1fr) repeat(4, minmax(50px, 1fr));
  }
  .doctor-view .flags{
    grid-template-columns: repeat(3, max-content);
  }
}

/* Panels */
.panel{position:fixed;right:8px;bottom:8px;max-height:80vh;overflow:auto;background:#0f1116;border:1px solid #2b2f3a;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.35);display:none;z-index:9998}
/* Panel (Charts) - Fullscreen */
.panel.chart{
  inset: 0;                 /* volle Flaeche (top/right/bottom/left = 0) */
  width: 100vw;
  height: 100dvh;           /* korrekt auf Mobile (sichtbare Hoehe) */
  max-width: 100vw;
  max-height: 100dvh;
  border-radius: 0;         /* keine abgerundeten Ecken im Vollbild */
}

/* Flex-Layout: Header fix oben, Inhalt fuellt Rest */
.panel.chart{
  /* Sichtbarkeit steuert JS; NICHT auf block setzen */
}
.panel.chart header{ 
  /* bleibt oben, keine Aenderung noetig - aber fixere Hoehe ist hilfreich */
  min-height: 44px;
}
.panel.chart .content{
  /* Inhalt fuellt den verfuegbaren Raum */
  height: calc(100dvh - 44px - 2px); /* 44px Header + 1px border oben/unten */
  display: flex;
  flex-direction: column;
  overflow: auto;
}
.panel header{display:flex;gap:6px;align-items:center;justify-content:space-between;padding:8px;border-bottom:1px solid #2b2f3a}
.panel h4{margin:0;font-size:14px}
.panel .content{
  padding: 12px;
  font-size: 13px;
  line-height: 1.45;
}
#diag pre{margin:0;padding:8px;font-size:12px;white-space:pre-wrap}

/* FABs */
.fab-wrap{position:fixed;right:8px;bottom:8px;display:flex;flex-direction:column;gap:8px;z-index:9999}
.fab{width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;border:1px solid #2b2f3a;background:#0f1116;cursor:pointer}
.fab:hover{box-shadow:0 8px 24px rgba(0,0,0,.35)}

/* Chart panel */
#chart .controls{
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  margin-bottom:6px;
}
#chart .controls select{
  appearance:none;
  background:var(--surface-elevated);
  border:1px solid var(--border-subtle);
  border-radius:8px;
  padding:0 14px;
  height:40px;
  color:var(--fg);
  box-shadow:0 6px 16px rgba(0,0,0,0.25);
}
#chart .controls select:focus-visible{
  outline:none;
  border-color:var(--accent);
  box-shadow:0 0 0 2px rgba(58,61,255,0.25);
}
#chart .controls .kpis{
  display:inline-flex;
  align-items:center;
  gap:10px;
  padding:8px 12px;
  border-radius:8px;
  background:var(--surface-elevated);
  border:1px solid var(--border-subtle);
  color:var(--fg);
  box-shadow:0 8px 22px rgba(0,0,0,0.2);
}
#chart .controls .kpis .sep{
  opacity:.6;
  color:var(--muted);
}
/* ANKER: flags-overlay CSS */
#chartSvg .flags { pointer-events: auto; }
#chart .controls > * {flex:1}
#chart .controls .half{flex:0 0 calc(50% - 4px)}
  
  /* SVG fuellt verbleibende Hoehe vollstaendig */
#chart svg{
  flex: 1 1 auto;
  width: 100%;
  height: 100%;     /* statt auto */
  min-height: 160px;
  display: block;
  background: radial-gradient(circle at top, rgba(255,255,255,0.045), transparent 55%);
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 10px;
}

#chartSvg{
  transform-origin:center;
}
#chartSvg.chart-refresh{
  animation:chartRescale .48s cubic-bezier(.25,.1,.25,1);
}
@keyframes chartRescale{
  0%{opacity:0.35; transform:translateY(8px);}
  100%{opacity:1; transform:translateY(0);}
}

#chart .legend{display:flex;gap:10px;font-size:12px;color:var(--muted);margin-top:6px;flex-wrap:wrap}

.dot{width:8px;height:8px;border-radius:50%;display:inline-block;margin-right:6px;border:1px solid rgba(0,0,0,0.3)}

#chartSvg path[data-series]{
  transition: opacity .2s ease, stroke-width .18s ease, filter .18s ease;
  stroke-linecap:round;
}
#chartSvg path[data-series].is-hover{ stroke-width:2.8; opacity:1; filter:brightness(1.12); }
#chartSvg path[data-series].is-dim{ opacity:.25; }

#chartSvg .pt{
  transform-box: fill-box;
  transform-origin: center;
  transition: transform .18s cubic-bezier(.16,1,.3,1), opacity .18s cubic-bezier(.16,1,.3,1), filter .18s ease;
}
#chartSvg .pt.is-hover{ transform:scale(1.4); opacity:1; filter:brightness(1.08); }
#chartSvg .pt.is-dim{ opacity:.35; }

#chartSvg .body-bar{
  transition: opacity .18s cubic-bezier(.16,1,.3,1), transform .18s cubic-bezier(.16,1,.3,1);
  transform-box: fill-box;
  transform-origin: center;
}
#chartSvg .body-bar.is-hover{ opacity:.9; transform:translateY(-1px); }
#chartSvg .body-bar.is-dim{ opacity:.35; }

#chart .legend [data-series]{
  transition: opacity .18s cubic-bezier(.16,1,.3,1), transform .18s cubic-bezier(.16,1,.3,1);
}
#chart .legend [data-series].is-hover{ opacity:1; transform:translateY(-1px); }
#chart .legend [data-series].is-dim{ opacity:.35; }

#chartSvg .goal-band{
  fill:var(--chart-goal-sys);
  stroke:none;
}
#chartSvg .goal-band.goal-dia{
  fill:var(--chart-goal-dia);
}
.chart-tip{
  position:absolute;
  inset:auto auto auto auto;
  transform:translate(8px,8px);
  background:var(--chart-tooltip-bg);
  border:1px solid rgba(60,68,90,.65);
  border-radius:8px;
  padding:8px 10px;
  font-size:12px;
  line-height:1.35;
  max-width:280px;
  box-shadow:0 12px 28px rgba(0,0,0,.42);
  color:var(--fg);
  text-shadow:0 1px 1px rgba(0,0,0,.35);
  pointer-events:none;
  opacity:0;
  transition:opacity .15s ease;
  display:block;
  z-index:2;
}

#chartSvg .chart-hit{ cursor:pointer; }
#chartSvg .chart-hit:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

/* Busy overlay */
#busy{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);z-index:99998}
#busy .box{background:#10131a;border:1px solid #2b2f3a;border-radius:12px;padding:12px 16px;font-weight:600}

.seg{display:flex;gap:8px;margin:8px 0 12px}
.seg .seg-btn.active{background:var(--accent);color:#fff}
.hidden{display:none!important}
:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

/* App-Lock Overlay */
#appLock{
  position: fixed; inset: 0; z-index: 10001;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.45); backdrop-filter: blur(2px);
}
#appLock .lock-card{
  width: min(420px, 92vw);
  background: #fff; color: #111;
  border-radius: 16px; padding: 18px;
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
  border: 1px solid #e5e7eb;
}
#appLock .lock-card h3{ margin: 0 0 6px; }
#appLock .btn.primary{ background: var(--accent); color: #fff; }
#appLock .pin-wrap{ display:flex; gap:8px; margin-top:8px; }
#appLock .pin-wrap input{
  flex:1; background:#f8fafc; color:#111; border:1px solid #e5e7eb;
}

/* Body-State: solange gelockt ist, Interaktion sperren (Overlay deckt ohnehin ab) */
body.app-locked main, body.app-locked nav, body.app-locked header{
  filter: blur(0); /* bewusst ohne Blur, nur visuelles Dimmen optional */
}
body.app-locked { pointer-events: auto; } /* Overlay nimmt Events ab */

/* Login-Overlay */
#loginOverlay{

  position: fixed; inset: 0; z-index: 10000;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.35); backdrop-filter: blur(2px);
}
#loginOverlay .login-card{
  width: min(420px, 92vw);
  background: #fff; color: #111;
  border-radius: 16px; padding: 18px;
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
  border: 1px solid #e5e7eb;
}
#loginOverlay .login-card h3{ margin: 0 0 6px; }
  #loginOverlay .btn.primary{ background: var(--accent); color: #fff; }
  
/* Lifestyle progress: modern look */
#lifestyle .progress, #cap-intake-wrap .progress { position: relative; width:100%; height:18px; background:#0f1116; border:1px solid #2b2f3a; border-radius:999px; overflow:hidden; margin-top:8px; }
#lifestyle .progress .bar, #cap-intake-wrap .progress .bar { height:100%; width:0%; background:linear-gradient(90deg,var(--accent),#7c3aed); transition: width .35s ease, filter .2s ease; box-shadow: inset 0 0 0 1px rgba(79,70,229,.25); }
#lifestyle .progress .label, #cap-intake-wrap .progress .label { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:600; color:rgba(255,255,255,.9); text-shadow:0 1px 2px rgba(0,0,0,.6); pointer-events:none; }
#lifestyle .progress.ok   .bar, #cap-intake-wrap .progress.ok   .bar { background:linear-gradient(90deg,#10b981,#34d399); box-shadow: inset 0 0 0 1px rgba(16,185,129,.25), 0 8px 20px rgba(16,185,129,.18); }
#lifestyle .progress.warn .bar, #cap-intake-wrap .progress.warn .bar { background:linear-gradient(90deg,#f59e0b,#fbbf24); box-shadow: inset 0 0 0 1px rgba(245,158,11,.25), 0 8px 20px rgba(245,158,11,.18); }
#lifestyle .progress.bad  .bar, #cap-intake-wrap .progress.bad  .bar { background:linear-gradient(90deg,#ef4444,#f87171); box-shadow: inset 0 0 0 1px rgba(239,68,68,.25), 0 8px 20px rgba(239,68,68,.18); }
#lifestyle .progress.neutral .bar, #cap-intake-wrap .progress.neutral .bar { background:linear-gradient(90deg,#6b7280,#9ca3af); box-shadow: inset 0 0 0 1px rgba(107,114,128,.25); }
@media (hover:hover){
  #lifestyle .progress:hover .bar, #cap-intake-wrap .progress:hover .bar { filter:brightness(1.05); }
}

#cap-intake-wrap{
  display:flex;
  flex-direction:column;
  gap:24px;
  background:var(--card-layer2);
  border:1px solid var(--border-subtle);
  border-radius:8px;
  padding:24px 20px;
  box-shadow:var(--shadow-soft);
}
#cap-intake-wrap .blockTitle{
  margin:0;
  padding-bottom:12px;
  font-size:1.1rem;
  font-weight:600;
  color:var(--fg);
  letter-spacing:0.3px;
  position:relative;
}
#cap-intake-wrap .blockTitle::after{
  content:"";
  position:absolute;
  left:0;
  right:0;
  bottom:0;
  height:1px;
  background:var(--border-subtle);
}
#cap-intake-status{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin:0 !important;
  opacity:.85;
}
#cap-intake-wrap .row{
  align-items:flex-end;
  gap:16px;
  flex-wrap:wrap;
  margin:0;
}
#cap-intake-wrap .row + .row{margin-top:24px;}
#cap-intake-wrap .row > div:last-child{
  width:160px;
  min-width:140px;
  display:flex;
  justify-content:flex-end;
}
#cap-intake-wrap .row > div:last-child .btn{
  width:100%;
}
#cap-intake-wrap > .small:last-of-type{
  margin-top:0 !important;
  text-align:right;
  color:var(--muted);
}
#cap-intake-wrap input{
  background:var(--surface-elevated);
  border:1px solid var(--border-subtle);
  border-radius:8px;
  color:var(--fg);
  transition:border-color .25s ease, box-shadow .25s ease, background .25s ease;
}
#cap-intake-wrap input:focus-visible{
  outline:none;
  border-color:var(--accent);
  box-shadow:0 0 0 2px rgba(58,61,255,0.25);
}
#cap-intake-wrap input::placeholder{
  color:var(--muted);
  opacity:.65;
}
#cap-intake-wrap .blockTitle,
#bodyAccordion .blockTitle{
  display:none;
}

/* Intake status pills (Capture) */
#cap-intake-status { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
.pill { display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:600; background:var(--surface-elevated); border:1px solid var(--border-subtle); color:var(--fg); }
.pill .dot { width:8px; height:8px; border-radius:50%; background:#6b7280; box-shadow:0 0 0 1px rgba(0,0,0,.4); }
.pill.ok .dot { background:var(--ok); }
.pill.warn .dot { background:var(--warn); }
.pill.bad .dot { background:var(--danger); }
.pill.neutral .dot { background:var(--accent); }
.body-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;}
.capture-header{ display:flex; flex-direction:column; gap:8px; }
.capture-header .capture-date{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
.capture-header .capture-pills{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.capture-header .capture-pills .pill{ margin:0; }


/* Arzttermine Skeleton */
#appointmentsWrap {
  display:flex;
  flex-direction:column;
  gap:16px;
}
.appointment-card {
  background:var(--card-layer2);
  border:1px solid var(--border-subtle);
  border-radius:8px;
  padding:20px;
  display:flex;
  flex-direction:column;
  gap:16px;
  box-shadow:var(--shadow-soft);
}
.appointment-card h3 {
  margin:0;
}
.appointment-inputs {
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(180px,1fr));
  gap:12px;
  align-items:end;
}
.appointment-inputs > div {
  min-width:160px;
}
.appointment-inputs .btn-wrap {
  grid-column:span 2;
  align-self:end;
}
.appointment-inputs .btn-wrap button {
  width:100%;
  height:40px;
}
.appointment-meta{
  display:flex;
  flex-direction:column;
  gap:12px;
}
.appointment-line {
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:8px;
  font-size:13px;
  color:var(--muted);
}
.appointment-line .label {
  order:1;
}
.appointment-line .value {
  order:2;
  font-size:13px;
  color:var(--fg);
  font-weight:500;
}
.appointment-line button {
  order:3;
  min-width:110px;
  height:36px;
  margin:0 0 0 8px;
  padding-inline:14px;
}
@media (max-width: 640px) {
  .appointment-inputs > div {
    flex: 1 1 100%;
  }
  .appointment-inputs .btn-wrap button {
    width: 100%;
  }
  .appointment-line {
    gap: 6px;
  }
  .appointment-line .value {
    flex-basis:100%;
  }
}

/* --- SAFETY: versteckte Dinge fangen keine Klicks --- */
[hidden] {
  display: none !important;
  pointer-events: none !important;
}

/* Versteckte Overlays fangen niemals Pointer-Events */
#loginOverlay[hidden],
#appLock[hidden],
#loginOverlay.is-hidden,
#appLock.is-hidden {
  display: none !important;
  pointer-events: none !important;
}

/* --- SAFETY: summary darf nie full-screen 'oben' liegen --- */
summary {
  position: static !important;
  z-index: auto !important;
  pointer-events: auto !important;
}
details[open] > summary {
  position: static !important;
}

/* Falls Details per hidden versteckt werden */
details[hidden] {
  display: none !important;
  pointer-events: none !important;
}

/* Optional: Config-Accordion im Login-Overlay explizit entschaerfen */
#configAdv > summary { position: static !important; }

</style>
<!-- END MODULE -->
</head>
<body>
<!-- ANKER: touch-log-fallback -->
<pre id="touchLog" style="display:none;position:fixed;bottom:0;left:0;right:0;max-height:40vh;overflow:auto;background:#111;color:#eee;font-size:12px;padding:4px;z-index:10000"></pre>

<header>
<div style="display:flex;align-items:center;gap:10px">
<h1>Gesundheits-Logger</h1><span class="small">V1.7.6</span>
<div class="spacer"></div>
<button class="btn ghost" id="helpToggle" type="button">Hilfe</button>
<button class="btn ghost" id="diagToggle" type="button">Log</button>
</div>
</header>

<nav class="tabs">
<button class="btn ghost" data-tab="capture" id="tab-capture" type="button">Erfassen</button>
<button class="btn ghost" data-tab="doctor" id="tab-doctor" type="button">Arzt-Ansicht</button>
</nav>

<!-- Hilfe-Panel -->
<div id="help" class="panel" role="dialog" aria-modal="false" aria-labelledby="helpTitle">
<header>
<h4 id="helpTitle">Hilfe * Was soll ich ankreuzen?</h4>
<button class="btn ghost" id="helpClose" type="button">x</button>
</header>
<div class="content">
<strong>&#x1F489; NSAR genommen</strong> ankreuzen, wenn du ein Schmerz-/Entzuendungsmedikament der Klasse NSAR genommen hast.
<ul>
<li><em>Beispiele (AT, frei):</em> Ibuprofen, Diclofenac, Naproxen.</li>
<li><em>Kombo-Achtung:</em> Viele "Erkaeltungs-/Kopfweh"-Mittel enthalten NSAR.</li>
<li><em>Bei Nierenkrankheit:</em>NSAR moeglichst vermeiden, Alternativen mit Arzt besprechen.</li>
</ul>
</div>
</div>

<!-- Diagnose-Panel -->
<div id="diag" class="panel" role="dialog" aria-modal="false" aria-labelledby="diagTitle">
<header>
<h4 id="diagTitle">Touch-Log</h4>
<button class="btn ghost" id="diagClose" type="button">x</button>
</header>
<pre id="diagLog" class="content" style="margin:0"></pre>
</div>

<!-- Diagramm-Panel (Daily) -->
<div id="chart" class="panel chart" role="dialog" aria-modal="false" aria-labelledby="chartTitle">
<header>
<h4 id="chartTitle">Diagramm (Daily)</h4>
<button class="btn ghost" id="chartClose" type="button">x</button>
</header>
<div class="content">
<div class="controls">
<select id="metricSel" class="half compact" aria-label="Messgroesse auswaehlen">
    <option value="bp">Blutdruck (Sys/Dia)</option>
    <option value="weight">Koerper</option>
</select>

  <!-- ANKER: chart-averages (Daily) -->
  <div id="chartAverages" class="kpis" aria-live="polite">
    <span data-k="sys">Durchschnitt Sys: -</span>
    <span class="sep" aria-hidden="true">*</span>
    <span data-k="dia">Durchschnitt Dia: -</span>
    <span class="sep" aria-hidden="true">*</span>
    <span data-k="map">Durchschnitt MAP: -</span>
  </div>
</div>

<svg id="chartSvg" viewBox="0 0 640 280" preserveAspectRatio="none" role="img" aria-label="Werteverlauf"></svg>
<div class="legend" id="chartLegend"></div>
<div class="small" style="opacity:.7;margin-top:6px">Zeitraum: nutzt die <em>Arzt-Ansicht</em> (von/bis).</div>
</div>
</div>

<div id="err" role="status" aria-live="polite"></div>
<div id="busy"><div class="box"> Bitte warten...</div></div>

<main id="appMain">
<!-- END MODULE -->
<!-- MODULE: CAPTURE (Intake)
  intent: Tageserfassung (UI) inkl. Intake/BP/Body/Flags/Termine, verbindet Benutzeraktionen mit Save-Flows
  contracts: nutzt DATA ACCESS.saveIntakeTotals*, AUTH.isLoggedIn, UI.requestUiRefresh
  todo: @extract-candidate bindIntakeCapture, refreshCaptureIntake spaeter extrahieren
-->
<!-- Capture -->
<section class="view active" id="capture" aria-labelledby="captureHeading">
 
  <h2 class="sr-only" id="captureHeading">Tageserfassung</h2>
  <!-- Daily-Capture -->
  <!-- SUBMODULE: capture-entry shell @internal - wraps accordions and intake status pills -->
  <section class="card" id="entry">
    <div class="capture-header">
      <div class="capture-date">
        <div style="flex:0 0 220px">
          <label>Datum</label>
          <input class="compact" type="date" id="date">
        </div>
      </div>
      <div class="capture-pills" id="capturePillsRow">
        <div id="cap-intake-status-top" class="small" style="opacity:.8; display:flex; gap:8px; flex-wrap:wrap"></div>
        <span id="nextApptBadge" class="pill neutral" title="Kein Termin geplant" aria-live="polite">Kein Termin geplant</span>
      </div>
    </div>

    <!-- SUBMODULE: bp-capture accordion @internal - logs morning/abends Werte & Kommentare -->
    <details class="accordion" id="bodyAccordion">
      <summary><span>&#x1F4C8; Blutdruck</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
      <div class="accordion-body">
        <div class="card-nested">
          <div class="row" style="align-items:flex-end; gap:12px; flex-wrap:wrap">
            <div style="min-width:180px">
              <label for="bpContextSel">Messzeitpunkt</label>
              <select id="bpContextSel">
                <option value="M">Morgens</option>
                <option value="A">Abends</option>
              </select>
            </div>
          </div>
        </div>
        <div class="card-nested bp-pane active" data-context="M">
          <h3 class="blockTitle">Morgens</h3>
          <div class="grid">
            <div><label>Systolisch (mmHg)</label><input type="number" id="captureAmount" inputmode="numeric" placeholder="z. B. 128"></div>
            <div><label>Diastolisch (mmHg)</label><input type="number" id="diaM" inputmode="numeric" placeholder="z. B. 82"></div>
            <div><label>Puls (bpm)</label><input type="number" id="pulseM" inputmode="numeric" placeholder="z. B. 66"></div>
          </div>
          <div class="row" style="margin-top:6px">
            <textarea id="bpCommentM" class="small" placeholder="Kommentar Morgens (optional)"></textarea>
          </div>
        </div>
        <div class="card-nested bp-pane" data-context="A">
          <h3 class="blockTitle">Abends</h3>
          <div class="grid">
            <div><label>Systolisch (mmHg)</label><input type="number" id="sysA" inputmode="numeric" placeholder="z. B. 128"></div>
            <div><label>Diastolisch (mmHg)</label><input type="number" id="diaA" inputmode="numeric" placeholder="z. B. 82"></div>
            <div><label>Puls (bpm)</label><input type="number" id="pulseA" inputmode="numeric" placeholder="z. B. 66"></div>
          </div>
          <div class="row" style="margin-top:6px">
            <textarea id="bpCommentA" class="small" placeholder="Kommentar Abends (optional)"></textarea>
          </div>
        </div>
        <div class="panel-actions">
          <button class="btn primary" id="saveBpPanelBtn" type="button">&#x1F4BE; Blutdruck speichern</button>
        </div>
      </div>
    </details>

    <!-- SUBMODULE: body-capture accordion @internal - captures weight + Umfang Werte -->
    <details class="accordion">
      <summary><span>&#x2696;&#xFE0F; Koerper</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
      <div class="accordion-body">
          <div class="card-nested">
            <div class="body-grid">
              <div>
                <label>Gewicht (kg)</label>
                <input type="number" step="0.1" id="weightDay" inputmode="decimal" placeholder="z. B. 84.2">
              </div>
              <div>
                <label>Bauchumfang (cm)</label>
                <input id="input-waist-cm" type="text" inputmode="decimal" autocomplete="off" placeholder="z. B. 104,5">
              </div>
              <div>
                <label>Fett (%)</label>
                <input id="fatPctDay" type="text" inputmode="decimal" autocomplete="off" placeholder="z. B. 22,5">
              </div>
              <div>
                <label>Muskel (%)</label>
                <input id="musclePctDay" type="text" inputmode="decimal" autocomplete="off" placeholder="z. B. 38,0">
              </div>
            </div>
          </div>
        
        <div class="panel-actions">
          <button class="btn primary" id="saveBodyPanelBtn" type="button">&#x1F4BE; Koerper speichern</button>
        </div>
      </div>
    </details>

    <!-- SUBMODULE: intake-capture accordion @internal - updates water/salt/protein totals -->
    <details class="accordion" id="captureIntake">
      <summary><span>&#x1F964; Fluessigkeit & Intake</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
      <div class="accordion-body">
        <div class="card-nested" id="cap-intake-wrap">
          <h3 class="blockTitle">Intake pro Tag</h3>
          <div class="small" id="cap-intake-status" style="margin-bottom:10px;opacity:.8"></div>

          <div class="row" style="align-items:flex-end; gap:8px; flex-wrap:wrap">
            <div style="flex:1;min-width:180px">
              <label>Wasser hinzufuegen (ml)</label>
              <input type="number" id="cap-water-add" min="0" step="50" inputmode="numeric" placeholder="z. B. 250">
            </div>
            <div style="width:140px">
              <button class="btn primary" id="cap-water-add-btn" type="button">+ Menge</button>
            </div>
          </div>

          <div class="row" style="align-items:flex-end; gap:8px; flex-wrap:wrap; margin-top:12px">
            <div style="flex:1;min-width:180px">
              <label>Salz hinzufuegen (g)</label>
              <input type="text" id="cap-salt-add" inputmode="decimal" autocomplete="off" placeholder="z. B. 0,5">
            </div>
            <div style="width:140px">
              <button class="btn primary" id="cap-salt-add-btn" type="button">+ Menge</button>
            </div>
          </div>

          <div class="row" style="align-items:flex-end; gap:8px; flex-wrap:wrap; margin-top:12px">
            <div style="flex:1;min-width:180px">
              <label>Protein hinzufuegen (g)</label>
              <input type="text" id="cap-protein-add" inputmode="decimal" autocomplete="off" placeholder="z. B. 20,0">
            </div>
            <div style="width:140px">
              <button class="btn primary" id="cap-protein-add-btn" type="button">+ Menge</button>
            </div>
          </div>

          <div class="small" style="margin-top:10px;opacity:.75">
            Hinweis: Werte werden fuer das gewaehlte Datum gespeichert und synchronisiert.
          </div>
        </div>
      </div>
    </details>

    <!-- SUBMODULE: day-flags accordion @internal - toggles training/sick/salt states -->
    <details class="accordion">
      <summary><span>&#x1F6A9; Flags</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
      <div class="accordion-body">
        <div class="card-nested">
          <div class="row" style="align-items:center; gap:8px; flex-wrap:wrap; margin-top:0">
            <button class="btn toggle" id="trainingToggle" type="button" aria-pressed="false">&#x1F3CB;&#xFE0F; Training heute</button>
            <button class="btn toggle" id="sickToggle" type="button" aria-pressed="false">&#x1F912; Krank (Forxiga pausiert)</button>
            <button class="btn toggle" id="valsartanMissToggle" type="button" aria-pressed="false">&#x1F48A; Valsartan vergessen</button>
            <button class="btn toggle" id="forxigaMissToggle" type="button" aria-pressed="false">&#x23F0; Forxiga vergessen</button>
            <button class="btn toggle" id="lowIntakeToggle" type="button" aria-pressed="false">&#x1F4A7; &lt; 2 L getrunken</button>
            <button class="btn toggle" id="saltHighToggle" type="button" aria-pressed="false" title="> 5 g Salz">&#x1F9C2; &gt; 5 g Salz</button>
            <button class="btn toggle" id="proteinHighToggle" type="button" aria-pressed="false" title="Protein >= 90 g">&#x1F969; Protein >= 90 g</button>
            <button class="btn toggle" id="nsarToggle" type="button" aria-pressed="false" title="Nicht-steroidale Antirheumatika">&#x1F489; NSAR genommen</button>
          </div>
        </div>
        <div class="card-nested">
          <label for="flagsComment" class="small" style="display:block;margin-bottom:6px">Kommentar zu Flags</label>
          <textarea id="flagsComment" placeholder="Kommentar zu Flags (optional)" rows="2"></textarea>
        </div>
        <div class="panel-actions">
          <button class="btn primary" id="saveFlagsPanelBtn" type="button">&#x1F4BE; Flags speichern</button>
        </div>
      </div>

</details>

<!-- SUBMODULE: appointments accordion @internal - manages per-role appointment cards -->
<details class="accordion" id="appointments">
  <summary><span>&#x1F4C5; Arzttermine</span><span class="chevron" aria-hidden="true">&#9654;</span></summary>
  <div class="accordion-body">
    <div class="card-nested" id="appointmentsWrap">
      <div class="small" style="margin-bottom:12px;opacity:.8">Pro Rolle gibt es genau einen geplanten Termin.</div>

      <div class="appointment-card" data-role="nephro">
        <h3 class="blockTitle">Nephrologe</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-nephro-date">Datum</label>
            <input type="date" id="appt-nephro-date">
          </div>
          <div>
            <label for="appt-nephro-time">Zeit</label>
            <input type="time" id="appt-nephro-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-nephro-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-meta">
          <div class="appointment-line">
            <span class="label">Naechster Termin:</span>
            <span class="value" id="appt-nephro-next">&mdash;</span>
            <button class="btn ghost" id="appt-nephro-done" type="button" disabled>Done</button>
          </div>
          <div class="appointment-line">
            <span class="label">Letzter Termin:</span>
            <span class="value" id="appt-nephro-last">&mdash;</span>
          </div>
        </div>
      </div>

      <div class="appointment-card" data-role="internal">
        <h3 class="blockTitle">Internist</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-internal-date">Datum</label>
            <input type="date" id="appt-internal-date">
          </div>
          <div>
            <label for="appt-internal-time">Zeit</label>
            <input type="time" id="appt-internal-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-internal-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-meta">
          <div class="appointment-line">
            <span class="label">Naechster Termin:</span>
            <span class="value" id="appt-internal-next">&mdash;</span>
            <button class="btn ghost" id="appt-internal-done" type="button" disabled>Done</button>
          </div>
          <div class="appointment-line">
            <span class="label">Letzter Termin:</span>
            <span class="value" id="appt-internal-last">&mdash;</span>
          </div>
        </div>
      </div>

      <div class="appointment-card" data-role="urology">
        <h3 class="blockTitle">Urologe</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-urology-date">Datum</label>
            <input type="date" id="appt-urology-date">
          </div>
          <div>
            <label for="appt-urology-time">Zeit</label>
            <input type="time" id="appt-urology-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-urology-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-meta">
          <div class="appointment-line">
            <span class="label">Naechster Termin:</span>
            <span class="value" id="appt-urology-next">&mdash;</span>
            <button class="btn ghost" id="appt-urology-done" type="button" disabled>Done</button>
          </div>
          <div class="appointment-line">
            <span class="label">Letzter Termin:</span>
            <span class="value" id="appt-urology-last">&mdash;</span>
          </div>
        </div>
      </div>

      <div class="appointment-card" data-role="dentist">
        <h3 class="blockTitle">Zahnarzt</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-dentist-date">Datum</label>
            <input type="date" id="appt-dentist-date">
          </div>
          <div>
            <label for="appt-dentist-time">Zeit</label>
            <input type="time" id="appt-dentist-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-dentist-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-meta">
          <div class="appointment-line">
            <span class="label">Naechster Termin:</span>
            <span class="value" id="appt-dentist-next">&mdash;</span>
            <button class="btn ghost" id="appt-dentist-done" type="button" disabled>Done</button>
          </div>
          <div class="appointment-line">
            <span class="label">Letzter Termin:</span>
            <span class="value" id="appt-dentist-last">&mdash;</span>
          </div>
        </div>
      </div>

      <div class="appointment-card" data-role="ophtha">
        <h3 class="blockTitle">Augenarzt</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-ophtha-date">Datum</label>
            <input type="date" id="appt-ophtha-date">
          </div>
          <div>
            <label for="appt-ophtha-time">Zeit</label>
            <input type="time" id="appt-ophtha-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-ophtha-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-meta">
          <div class="appointment-line">
            <span class="label">Naechster Termin:</span>
            <span class="value" id="appt-ophtha-next">&mdash;</span>
            <button class="btn ghost" id="appt-ophtha-done" type="button" disabled>Done</button>
          </div>
          <div class="appointment-line">
            <span class="label">Letzter Termin:</span>
            <span class="value" id="appt-ophtha-last">&mdash;</span>
          </div>
        </div>
      </div>

      <div class="appointment-card" data-role="physio">
        <h3 class="blockTitle">Physiotherapie</h3>
        <div class="appointment-inputs">
          <div>
            <label for="appt-physio-date">Datum</label>
            <input type="date" id="appt-physio-date">
          </div>
          <div>
            <label for="appt-physio-time">Zeit</label>
            <input type="time" id="appt-physio-time">
          </div>
          <div class="btn-wrap">
            <button class="btn primary" id="appt-physio-save" type="button">Speichern</button>
          </div>
        </div>
        <div class="appointment-meta">
          <div class="appointment-line">
            <span class="label">Naechster Termin:</span>
            <span class="value" id="appt-physio-next">&mdash;</span>
            <button class="btn ghost" id="appt-physio-done" type="button" disabled>Done</button>
          </div>
          <div class="appointment-line">
            <span class="label">Letzter Termin:</span>
            <span class="value" id="appt-physio-last">&mdash;</span>
          </div>
        </div>
      </div>

      <div class="small" style="opacity:.7">Hinweis: Logik folgt in den naechsten Phasen - aktuell nur UI-Skelett.</div>
    </div>
  </div>
</details>

  </section>
</section>
<!-- END MODULE -->

<!-- Lifestyle (Heute) -->


<!-- MODULE: DOCTOR VIEW
  intent: Aggregations-UI fuer Aerzt:innen, steuert Zeitraum-Filter, Export und Chart-Pivot
  contracts: nutzt DATA ACCESS.fetchDailyOverview, CHARTS.renderDailyChart, AUTH.setDoctorAccess @public
  todo: @extract-candidate buildDoctorSummaryJson @public spaeter bereitstellen
-->
<!-- Doctor -->
<section class="view" id="doctor" aria-labelledby="doctorHeading">
  <h2 class="sr-only" id="doctorHeading">Arzt-Ansicht</h2>
  <div class="card" id="doctorCard">
    <div class="toolbar">
      <strong id="doctorTitle">Arzt-Ansicht</strong>

      <div class="center-group">
        <label class="small">Von <input type="date" id="from" style="width:auto"></label>
        <label class="small">Bis <input type="date" id="to" style="width:auto"></label>
        <button class="btn ghost" id="applyRange" type="button">Anwenden</button>
        <button class="btn ghost" id="doctorChartBtn" type="button" title="Werte als Grafik">Werte anzeigen</button>
        <button class="btn ghost" id="doctorExportJson" type="button">Export JSON</button>
      </div>

      <span id="docTrainCnt" class="badge good" title="Anzahl Tage mit Training im Zeitraum"> Trainingstage: <span class="val">0</span></span>
      <span id="docBadCnt" class="badge bad" title="Anzahl Tage mit mind. einem Bad-Flag"> Tage mit Bad-Flag: <span class="val">0</span></span>
    </div> <!--  Toolbar sauber schliessen -->

    <div style="overflow:auto" id="doctorDailyWrap">
      <div class="doctor-view" id="doctorView"></div>
    </div>

        <div class="small" style="margin-top:6px">
      Tipp: "Werte anzeigen" oeffnet die passende Grafik zum aktuellen Tab (Daily).
    </div>
  </div>
</section>

<!-- END MODULE -->

</main>

<!-- Supabase (UMD, v2) -->
<script
  src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"
  integrity="sha384-0w2KAL2YHP6wKOkUDzkCDGgVvfmHnj02DHeQ6XcHOgTfFsGyonKOpShMH1x6nk9o"
  crossorigin="anonymous"
></script>


<script src="assets/js/diagnostics.js"></script>
<!-- @refactor: moved to assets/js/ui.js -->
<script src="assets/js/ui.js"></script>
<!-- @refactor: moved to assets/js/ui-layout.js -->
<script src="assets/js/ui-layout.js"></script>
<!-- @refactor: moved to assets/js/ui-errors.js -->
<script src="assets/js/ui-errors.js"></script>
<!-- @refactor: moved to assets/js/utils.js -->
<script src="assets/js/utils.js"></script>
<!-- @refactor: moved to assets/js/format.js -->
<script src="assets/js/format.js"></script>
<!-- @refactor: moved to assets/js/config.js -->
<script src="assets/js/config.js"></script>
<!-- @refactor: moved to assets/js/capture/globals.js -->
<script src="assets/js/capture/globals.js"></script>
<!-- @refactor: moved to assets/js/data-local.js -->
<script src="assets/js/data-local.js"></script>
<!-- @refactor: moved to assets/js/supabase/index.js -->
<script type="module" src="assets/js/supabase/index.js"></script>

<script type="module">
  import { SupabaseAPI } from "./assets/js/supabase/index.js";

  const bootAuth = () => {
    SupabaseAPI.initAuth?.({
      onStatus: (status) => console.info("Auth status:", status),
      onLoginOverlay: (visible) => {
        if (visible) {
          SupabaseAPI.showLoginOverlay?.(true);
        } else {
          SupabaseAPI.hideLoginOverlay?.();
        }
      },
      onUserUi: (email) => {
        SupabaseAPI.setUserUi?.(email || "");
      },
      onDoctorAccess: (enabled) => {
        SupabaseAPI.setDoctorAccess?.(enabled);
      }
    });
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", bootAuth, { once: true });
  } else {
    bootAuth();
  }
</script>
<!-- @refactor: moved to assets/js/ui-tabs.js -->
<script src="assets/js/ui-tabs.js"></script>

<script>
let supabaseMissingLogged = false;
const getSupabaseApi = () => {
  const api = window.SupabaseAPI;
  if (!api) {
    if (!supabaseMissingLogged) {
      console.error('[BOOT] SupabaseAPI nicht geladen  prfe assets/js/supabase/index.js / Script-Reihenfolge.');
      supabaseMissingLogged = true;
    }
    return null;
  }
  supabaseMissingLogged = false;
  return api;
};
const SUPABASE_READY_EVENT = 'supabase:ready';
const hasSupabaseFn = (name) => typeof getSupabaseApi()?.[name] === 'function';
const createSupabaseFn = (name, { optional = false } = {}) => (...args) => {
  const fn = getSupabaseApi()?.[name];
  if (typeof fn !== 'function') {
    if (optional) return undefined;
    throw new Error(`SupabaseAPI.${name} fehlt`);
  }
  return fn(...args);
};

const fetchWithAuth = createSupabaseFn('fetchWithAuth');
const ensureSupabaseClient = createSupabaseFn('ensureSupabaseClient');
const getUserId = createSupabaseFn('getUserId');
const isLoggedInFast = createSupabaseFn('isLoggedInFast');
const syncWebhook = createSupabaseFn('syncWebhook');
const loadIntakeToday = createSupabaseFn('loadIntakeToday');
const saveIntakeTotalsRpc = createSupabaseFn('saveIntakeTotalsRpc');
const cleanupOldIntake = createSupabaseFn('cleanupOldIntake');
const fetchDailyOverview = createSupabaseFn('fetchDailyOverview');
const deleteRemoteDay = createSupabaseFn('deleteRemoteDay');
const syncCaptureToggles = createSupabaseFn('syncCaptureToggles');
const setupRealtime = createSupabaseFn('setupRealtime');
const setConfigStatus = createSupabaseFn('setConfigStatus');
const showLoginOverlay = createSupabaseFn('showLoginOverlay');
const requireSession = createSupabaseFn('requireSession');
const watchAuthState = createSupabaseFn('watchAuthState');
const bindAuthButtons = createSupabaseFn('bindAuthButtons');
const afterLoginBoot = createSupabaseFn('afterLoginBoot');
const baseUrlFromRest = createSupabaseFn('baseUrlFromRest');
const requireDoctorUnlock = createSupabaseFn('requireDoctorUnlock');
const bindAppLockButtons = createSupabaseFn('bindAppLockButtons');
const resumeFromBackground = createSupabaseFn('resumeFromBackground');

const getLockUi = () => {
  const fn = getSupabaseApi()?.lockUi;
  return typeof fn === 'function' ? fn : null;
};
const getAuthGuardState = () => {
  const state = getSupabaseApi()?.authGuardState;
  return state && typeof state === 'object' ? state : null;
};
const isDoctorUnlocked = () => !!getAuthGuardState()?.doctorUnlocked;
const setAuthPendingAfterUnlock = (value) => {
  const state = getAuthGuardState();
  if (state) {
    state.pendingAfterUnlock = value ?? null;
  }
};

const waitForSupabaseApi = (() => {
  let pendingPromise = null;
  return ({ timeout = 6000, pollInterval = 25 } = {}) => {
    const ready = getSupabaseApi();
    if (ready) return Promise.resolve(ready);
    if (pendingPromise) return pendingPromise;

    pendingPromise = new Promise((resolve, reject) => {
      let settled = false;
      const cleanup = () => {
        if (settled) return;
        settled = true;
        document.removeEventListener(SUPABASE_READY_EVENT, onReady);
        clearInterval(pollId);
        if (timeoutId) clearTimeout(timeoutId);
        pendingPromise = null;
      };
      const onReady = () => {
        const api = getSupabaseApi();
        if (!api) return;
        cleanup();
        resolve(api);
      };
      const pollId = setInterval(onReady, pollInterval);
      document.addEventListener(SUPABASE_READY_EVENT, onReady, { once: false });
      let timeoutId = null;
      if (timeout > 0) {
        timeoutId = setTimeout(() => {
          cleanup();
          reject(new Error('SupabaseAPI not ready within timeout'));
        }, timeout);
      }
      // immediate check in case API became ready between Promise creation and listener setup
      onReady();
    });
    return pendingPromise;
  };
})();

/** MODULE: LOGGING & DIAGNOSTICS
 * intent: sammelt UI-/Runtime-Diagnosen, zeigt Fehler an, speist das Touch-Log
 * contracts: stellt diag-Logger, perfStats-Snapshots, uiError/uiInfo fuer UI-Module bereit
 * exports: diag, recordPerfStat, uiError, uiInfo
 * notes: rein beobachtend; Verhalten bleibt unveraendert
 */


/** MODULE: UI / ROUTING / VIEWS - Core (Refresh/Help)
 * intent: steuert Hilfspanel, UI Refresh Loop, Tabs & Fokusreparatur
 * contracts: stellt requestUiRefresh @public, maybeRefreshForTodayChange, setUnderlayInert fuer andere Module bereit
 * exports: requestUiRefresh, runUiRefresh, maybeRefreshForTodayChange, setUnderlayInert
 * notes: Fortsetzung des Kern-UI-Routings (Refresh/Help); DOM-Struktur unveraendert belassen
 */
// @refactor: moved to assets/js/ui.js (helpPanel)

/* ===== Helpers ===== */
const UI_REFRESH_TIMEOUT_MS = 8000;
const GET_USER_TIMEOUT_MS = 2000;
const uiRefreshState = {
  timer: null,
  running: false,
  docNeeded: false,
  chartNeeded: false,
  lifestyleNeeded: false,
  appointmentsNeeded: false,
  resolvers: [],
  lastReason: '',
  reasons: new Set()
};

const uiRefreshTimeoutSymbol = Symbol('ui-refresh-timeout');
const uiNow = () => (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();

// SUBMODULE: requestUiRefresh @public - debounces multi-surface refresh (doctor/chart/capture); mutex via uiRefreshState
function requestUiRefresh(opts = {}) {
  if (typeof opts === "string") {
    opts = { reason: opts };
  }
  const reason = opts.reason || '';
  const doctor = opts.doctor !== undefined ? !!opts.doctor : true;

  let chartDefault = false;
  try { chartDefault = !!(chartPanel?.open); } catch(_) {}
  const chart = opts.chart !== undefined ? !!opts.chart : chartDefault;

  let lifestyleDefault = false;
  try {
    const lifestyleEl = document.getElementById('lifestyle');
    lifestyleDefault = !!(lifestyleEl?.classList?.contains('active'));
  } catch(_) {}
  const lifestyle = opts.lifestyle !== undefined ? !!opts.lifestyle : lifestyleDefault;

  const appointments = opts.appointments !== undefined ? !!opts.appointments : false;

  uiRefreshState.docNeeded = uiRefreshState.docNeeded || doctor;
  uiRefreshState.chartNeeded = uiRefreshState.chartNeeded || chart;
  uiRefreshState.lifestyleNeeded = uiRefreshState.lifestyleNeeded || lifestyle;
  uiRefreshState.appointmentsNeeded = uiRefreshState.appointmentsNeeded || appointments;
  uiRefreshState.lastReason = reason || uiRefreshState.lastReason;
  if (reason) uiRefreshState.reasons.add(reason);

  const promise = new Promise(resolve => uiRefreshState.resolvers.push(resolve));

  if (!uiRefreshState.running && !uiRefreshState.timer) {
    uiRefreshState.timer = setTimeout(() => {
      uiRefreshState.timer = null;
      runUiRefresh().catch(err => {
        diag.add?.('[ui] refresh fatal: ' + (err?.message || err));
      });
    }, 0);
  }
  return promise;
}

// SUBMODULE: runUiSubStep @internal - executes gated refresh tasks with perf tracking
async function runUiSubStep(label, enabled, fn) {
  if (!enabled) return;
  const start = uiNow();
  diag.add?.(`[ui] step start ${label}`);
  let timeoutId;
  let timedOut = false;
  const timeoutPromise = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      timedOut = true;
      reject(uiRefreshTimeoutSymbol);
    }, UI_REFRESH_TIMEOUT_MS);
  });
  try {
    await Promise.race([
      (async () => {
        try {
          await fn();
        } catch (err) {
          if (!timedOut) throw err;
          diag.add?.(`[ui] step late error ${label}: ${err?.message || err}`);
        }
      })(),
      timeoutPromise
    ]);
    const duration = Math.round(uiNow() - start);
    diag.add?.(`[ui] step end ${label} (${duration} ms)`);
  } catch (err) {
    const duration = Math.round(uiNow() - start);
    if (err === uiRefreshTimeoutSymbol) {
      diag.add?.(`[ui] step timeout ${label} (${duration} ms)`);
    } else {
      diag.add?.(`[ui] step error ${label}: ${err?.message || err} (${duration} ms)`);
    }
  } finally {
    clearTimeout(timeoutId);
  }
}

// SUBMODULE: runUiRefresh @internal - orchestrates capture/doctor/chart refresh pipeline
async function runUiRefresh(){
  const state = uiRefreshState;
  if (state.timer){
    clearTimeout(state.timer);
    state.timer = null;
  }
  if (state.running) return;
  state.running = true;
  const refreshStart = uiNow();
  const reasons = state.reasons.size ? Array.from(state.reasons) : (state.lastReason ? [state.lastReason] : []);
  state.reasons.clear();
  const reasonLabel = reasons.length ? reasons.join(',') : 'unspecified';
  diag.add?.(`[ui] refresh start reason=${reasonLabel}`);
  try {
    while (state.docNeeded || state.chartNeeded || state.lifestyleNeeded || state.appointmentsNeeded) {
      const doc = state.docNeeded;
      const chart = state.chartNeeded;
      const lifestyle = state.lifestyleNeeded;
      const appointments = state.appointmentsNeeded;
      state.docNeeded = false;
      state.chartNeeded = false;
      state.lifestyleNeeded = false;
      state.appointmentsNeeded = false;

      await runUiSubStep('doctor', doc, async () => { await renderDoctor(); });
      await runUiSubStep('appointments', appointments, async () => { await refreshAppointments(); });
      await runUiSubStep('lifestyle', lifestyle && typeof renderLifestyle === 'function', async () => { await renderLifestyle(); });
      await runUiSubStep('chart', chart && !!chartPanel?.draw, async () => { await chartPanel.draw?.(); });
    }
  } finally {
    state.running = false;
    const duration = Math.round(uiNow() - refreshStart);
    diag.add?.(`[ui] refresh end reason=${reasonLabel} (${duration} ms)`);
    const resolvers = state.resolvers;
    state.resolvers = [];
    resolvers.forEach(resolve => { try { resolve(); } catch(_){} });
    if ((state.docNeeded || state.chartNeeded || state.lifestyleNeeded || state.appointmentsNeeded) && !state.timer){
      state.timer = setTimeout(() => {
        uiRefreshState.timer = null;
        runUiRefresh().catch(err => diag.add?.('[ui] refresh fatal: ' + (err?.message || err)));
      }, 0);
    }
  }
}
// kleines visuelles Ping bei Realtime
// SUBMODULE: livePulse @internal - flashes heartbeat indicator for realtime events
function livePulse(){
  const el = document.getElementById('doctorLive');
  if (!el) return;
  el.classList.add('pulse');
  setTimeout(() => el.classList.remove('pulse'), 900);
}

/** END MODULE */

// --- Service-Role-Schutz (NIEMALS im Browser) ---
// SUBMODULE: isServiceRoleKey @internal - blocks service_role keys in browser context
function isServiceRoleKey(raw){
  const tok = String(raw||"").trim().replace(/^Bearer\s+/i,'');
  try{
    const payload = JSON.parse(atob(tok.split('.')[1].replace(/-/g,'+').replace(/_/g,'/')));
    return payload?.role === 'service_role';
  }catch{
    return false; // Fallback: lieber konservativ sein
  }
}

// ANCHOR: num-helper-de
function toNumDE(s) {
  if (s == null) return null;
  let v = String(s).trim();
  if (!v) return null;
  // strip trailing units/symbols
  v = v.replace(/\s*(?:%|\u2030|[A-Za-z]+|\u20AC|\$|\u00A3)\s*$/u, '');
  // normalize minus and spaces
  v = v.replace(/[\u2212\u2013\u2014]/g, '-').replace(/[\u00A0\u2009\u202F]/g, ' ').replace(/\s+/g, '');
  // decide decimal separator
  const lastComma = v.lastIndexOf(',');
  const lastDot   = v.lastIndexOf('.');
  let dec = null;
  if (lastComma !== -1 && lastDot !== -1) dec = (lastComma > lastDot) ? ',' : '.';
  else if (lastComma !== -1) dec = (v.length - lastComma - 1) <= 2 ? ',' : null;
  else if (lastDot   !== -1) dec = (v.length - lastDot   - 1) <= 2 ? '.' : null;
  if (dec) {
    // protect the chosen decimal (replace its last occurrence with placeholder)
    v = v.replace(new RegExp('\\' + dec + '(?=[^' + (dec === '.' ? '\\.' : ',') + ']*$)'), '#');
  }
  // remove remaining group separators (.,', and spaces)
  v = v.replace(/[.,'\s]/g, '');
  if (dec) v = v.replace('#', '.');
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

// @refactor: moved to assets/js/diagnostics.js (uiError, uiInfo)

// @refactor: moved to assets/js/ui.js (debounce)

// @refactor: moved to assets/js/ui.js (setUnderlayInert)

// @refactor: moved to assets/js/ui-layout.js (updateStickyOffsets)

// @refactor: moved to assets/js/ui-layout.js (ensureNotObscured & focus handler)

// @refactor: moved to assets/js/ui.js (focusTrap)

// @refactor: moved to assets/js/ui-errors.js (restErrorMessage, uiRestError, withBusy)
  
/** MODULE: AUTH
 * intent: verwaltet Supabase-Sitzung, legt Auth-Locks frei, bindet Login-Overlay ein
 * contracts: stellt isLoggedIn @public, setAuthGuard, setDoctorAccess bereit und sichert spaeter Client/Header fuer DATA ACCESS
 * exports: isLoggedIn, isLoggedInFast, setAuthGuard, setDoctorAccess
 * notes: Seiteneffekte auf Auth-Surfaces beschraenken; Verhalten unveraendert lassen
 */
/* ===== Auth-Guard ===== */
// SUBMODULE: isLoggedIn @public - quick check to gate protected actions
async function isLoggedIn(){
  if (!sbClient) return false;
  return await isLoggedInFast({ timeout: 800 });
}

/** Schaltet optisch auf "gesperrt" - ohne Controls hart zu deaktivieren */
// SUBMODULE: setAuthGuard - dims UI when auth session missing
function setAuthGuard(logged){
  // Nur visuelles Dimmen; die Save-Logik prueft isLoggedIn() ohnehin.
  document.body.classList.toggle('auth-locked', !logged);
  // Kein auto-boot mehr hier - Start erfolgt in main()/watchAuthState.
}

// SUBMODULE: setDoctorAccess - toggles doctor tab when auth state changes
function setDoctorAccess(enabled){
  // Tab-Button
  const tabBtn = document.getElementById('tab-doctor');
  if (tabBtn){
    tabBtn.disabled = !enabled;
    tabBtn.classList.toggle('ghost', !enabled);
    tabBtn.title = enabled ? '' : 'Bitte zuerst anmelden';
  }
  // "Werte anzeigen"-Button
  const chartBtn = document.getElementById('doctorChartBtn');
  if (chartBtn){
    chartBtn.disabled = !enabled;
    chartBtn.title = enabled ? 'Werte als Grafik' : 'Bitte zuerst anmelden';
  }
  // Lifestyle-Tab mitsteuern
  
}
  
/** END MODULE */
  
/** MODULE: UTILITIES
 * intent: generische DOM/Format Helper fuer das Monolith-Skript
 * contracts: stellt $, $$, fmtNum, todayStr, timeStr, esc/nl2br fuer UI-/Capture-Module bereit
 * exports: $, $$, fmtNum, todayStr, timeStr, esc, nl2br
 * notes: deterministische Hilfsfunktionen; rein funktional belassen
 */
// @refactor: moved to assets/js/utils.js ($, $$, fmtNum, pad2, todayStr, timeStr, esc, nl2br)

/** END MODULE */

/** MODULE: CAPTURE (Intake)
 * intent: steuert Intake-State, Mitternachts-Resets und Bindings fuer die Tageserfassung
 * contracts: nutzt DATA ACCESS.loadIntakeToday/saveIntakeTotals*, UI.requestUiRefresh, AUTH.isLoggedIn
 * exports: refreshCaptureIntake, scheduleMidnightRefresh, maybeResetIntakeForToday, bindIntakeCapture, updateCaptureIntakeStatus
 * notes: spiegelt CAPTURE UI Modul; reine Logik
 */
/** MODULE: DATA ACCESS (IndexedDB)
 * intent: lokale IndexedDB- und Konfig-Hilfen fuer Intake-/Doctor-Features
 * contracts: stellt initDB, Config-Lese/Schreibhelfer sowie Entry-Stores fuer CAPTURE/BP bereit
 * exports: initDB, putConf, getConf, addEntry, updateEntry, getAllEntries, getEntryByRemoteId, deleteEntryLocal, dayIsoToMidnightIso
 * notes: dient als Basis fuer Offline-Zwischenspeicher; keine Netz-Calls
 */
// @refactor: moved to assets/js/data-local.js (initDB, putConf, getConf, dayIsoToMidnightIso, addEntry, updateEntry, getAllEntries, getEntryByRemoteId, deleteEntryLocal)

/** END MODULE */

/* ===== Remote (Supabase REST) ===== */
/** MODULE: AUTH
 * intent: stellt Supabase JWT Header bereit und kapselt Service-Role-Schutz (Fortsetzung)
 * contracts: stellt getHeaders @public fuer DATA ACCESS.fetchWithAuth zur Verfuegung
 * exports: getHeaders
 * notes: kurzer Zwischenblock; Caching-Semantik unveraendert lassen
 */
// SUBMODULE: getHeaders @public - resolved JWT/anon header bundle with timeout fallback
// Dep: expects SupabaseAPI helpers (assets/js/supabase/index.js) to be ready.
async function getHeaders({ forceRefresh = false } = {}) {
  const supaApi = getSupabaseApi();
  const maxAgeMs = 5 * 60 * 1000;

  if (!forceRefresh) {
    try {
      const cached = supaApi.getCachedHeaders?.();
      const cachedAt = supaApi.getCachedHeadersAt?.();
      if (cached && cachedAt && (Date.now() - cachedAt) < maxAgeMs) {
        diag.add?.('[headers] cache hit');
        return cached;
      }
    } catch (_) {
      /* noop */
    }
    const inflight = supaApi.getHeaderPromise?.();
    if (inflight) {
      diag.add?.('[headers] await inflight');
      return inflight;
    }
  }

  const load = (async () => {
    const key = await getConf("webhookKey");
    if (!key) {
      diag.add?.('Headers: kein Key (webhookKey)');
      supaApi.clearHeaderCache?.();
      return null;
    }
    if (isServiceRoleKey(key)) {
      diag.add?.('Headers: service_role Key blockiert');
      supaApi.clearHeaderCache?.();
      return null;
    }
    const anonKey = key.replace(/^Bearer\s+/i, "");

    const supa = await ensureSupabaseClient();
    if (!supa) {
      diag.add?.('Headers: Supabase-Client fehlt');
      supaApi.clearHeaderCache?.();
      return null;
    }

    let timeoutId;
    let timedOut = false;
    const timeoutPromise = new Promise((_, reject) => {
      timeoutId = setTimeout(() => {
        timedOut = true;
        reject(new Error('getSession-timeout'));
      }, GET_USER_TIMEOUT_MS);
    });
    let sessionInfo = null;
    try {
      const result = await Promise.race([supa.auth.getSession(), timeoutPromise]);
      sessionInfo = result?.data?.session ?? null;
    } catch (err) {
      if (timedOut) {
        diag.add?.('[auth] getSession timeout');
      } else {
        diag.add?.('[auth] getSession error: ' + (err?.message || err));
      }
    } finally {
      clearTimeout(timeoutId);
    }

    if (timedOut) {
      const cached = supaApi.getCachedHeaders?.();
      const cachedAt = supaApi.getCachedHeadersAt?.();
      if (cached && cachedAt) {
        diag.add?.('[headers] fallback cached (timeout)');
        return cached;
      }
    }

    const jwt = sessionInfo?.access_token;
    if (!anonKey || !jwt) {
      diag.add?.('Headers: fehlende Session/JWT');
      supaApi.clearHeaderCache?.();
      return supaApi.getCachedHeaders?.() ?? null;
    }

    const headers = {
      "Content-Type": "application/json",
      "apikey": anonKey,
      "Authorization": `Bearer ${jwt}`,
      "Prefer": "return=representation"
    };
    supaApi.cacheHeaders?.(headers);
    diag.add?.('[headers] ok');
    return headers;
  })();

  supaApi.setHeaderPromise?.(load);
  try {
    return await load;
  } finally {
    supaApi.setHeaderPromise?.(null);
  }
}

/** END MODULE */

const REQUIRED_GLOBALS = [
  'diag',
  'recordPerfStat',
  'uiError',
  'uiInfo',
  '$',
  '$$',
  'fmtNum',
  'todayStr',
  'nl2br',
  'formatDateTimeDE',
  'toHealthEvents',
  'initDB',
  'getConf',
  'putConf',
  'addEntry',
  'updateEntry',
  'getAllEntries',
  'getEntryByRemoteId',
  'deleteEntryLocal',
  'fmtDE',
  'updateLifestyleBars',
  'AppModules.uiCore.helpPanel',
  'AppModules.uiCore.debounce',
  'AppModules.uiCore.setUnderlayInert',
  'AppModules.uiCore.focusTrap',
  'AppModules.uiLayout.updateStickyOffsets',
  'AppModules.uiLayout.ensureNotObscured'
];

const REQUIRED_SUPABASE_EXPORTS = [
  'fetchWithAuth',
  'ensureSupabaseClient',
  'getUserId',
  'isLoggedInFast',
  'syncWebhook',
  'loadIntakeToday',
  'saveIntakeTotalsRpc',
  'cleanupOldIntake',
  'fetchDailyOverview',
  'deleteRemoteDay',
  'syncCaptureToggles',
  'setupRealtime',
  'setConfigStatus',
  'showLoginOverlay',
  'requireSession',
  'watchAuthState',
  'bindAuthButtons',
  'afterLoginBoot',
  'baseUrlFromRest',
  'requireDoctorUnlock',
  'bindAppLockButtons',
  'resumeFromBackground'
];

function resolveGlobal(path) {
  return path.split('.').reduce((acc, part) => {
    if (acc == null) return undefined;
    return acc[part];
  }, window);
}

async function ensureModulesReady() {
  let supabaseReady = !!getSupabaseApi();
  if (!supabaseReady) {
    try {
      await waitForSupabaseApi({ timeout: 8000 });
      supabaseReady = !!getSupabaseApi();
    } catch (err) {
      console.warn('[BOOT] SupabaseAPI nicht rechtzeitig geladen', err);
    }
  }

  const missingGlobals = REQUIRED_GLOBALS.filter((name) => typeof resolveGlobal(name) === "undefined");
  const missingSupa = supabaseReady
    ? REQUIRED_SUPABASE_EXPORTS.filter((name) => !hasSupabaseFn(name)).map((name) => `SupabaseAPI.${name}`)
    : ['SupabaseAPI'];
  const missing = [...missingGlobals, ...missingSupa];
  if (!missing.length) return true;
  const message = `Fehler: Module fehlen (${missing.join(', ')})`;
  let displayed = false;
  if (document.readyState !== 'loading') {
    const errBox = document.getElementById('err');
    if (errBox) {
      errBox.textContent = message;
      errBox.style.display = 'block';
      displayed = true;
    } else if (document.body) {
      const div = document.createElement('div');
      div.textContent = message;
      div.style.background = '#ff6b6b';
      div.style.color = '#121417';
      div.style.padding = '12px';
      div.style.margin = '16px';
      div.style.borderRadius = '8px';
      div.style.fontWeight = '600';
      document.body.appendChild(div);
      displayed = true;
    }
  }
  if (!displayed) {
    console.error(message);
  }
  return false;
}

/** MODULE: DATA ACCESS (REST/RPC)
 * intent: kapselt Supabase REST/RPC Zugriffe fuer Intake/Doctor/Sync Flows
 * contracts: nutzt fetchWithAuth/getHeaders, befuellt CAPTURE/DOCTOR/CHART Pipelines
 * exports: deleteRemote, loadIntakeToday, saveIntakeTotals, saveIntakeTotalsRpc, fetchDailyOverview, deleteRemoteDay
 * notes: enthaelt Fallbacks fuer RPC/REST sowie Merge-Helper fuer Tagesansichten
 */
// @refactor: moved to assets/js/supabase.js (Supabase REST/RPC helpers)

/** END MODULE */

// SUBMODULE: setCaptureIntakeDisabled @internal - toggles intake inputs while syncing
function setCaptureIntakeDisabled(disabled){
  ['cap-water-add','cap-salt-add','cap-protein-add'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.disabled = !!disabled;
  });
  ['cap-water-add-btn','cap-salt-add-btn','cap-protein-add-btn'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.disabled = !!disabled;
  });
}

// SUBMODULE: clearFieldError @internal - entfernt visuelle Fehlerzustaende von Intake-Feldern
function clearFieldError(el){
  if (!el) return;
  el.style.outline = '';
  el.removeAttribute('aria-invalid');
}

// SUBMODULE: setFieldError @internal - markiert Intake-Felder bei Validierungsfehlern
function setFieldError(el){
  if (!el) return;
  el.style.outline = '2px solid var(--danger)';
  el.setAttribute('aria-invalid','true');
}

// SUBMODULE: prepareIntakeStatusHeader @internal - ensures pills/status container exists
function prepareIntakeStatusHeader(){
  try {
    const wrap = document.getElementById('capturePillsRow');
    const nab = wrap ? wrap.querySelector('#nextApptBadge') : document.getElementById('nextApptBadge');
    if (nab) {
      nab.textContent = 'Kein Termin geplant';
      nab.title = 'Kein Termin geplant';
    }
    if (!wrap) return;

    wrap.style.gap = '8px';
    wrap.style.flexWrap = 'wrap';
    wrap.style.alignItems = 'center';

    let top = document.getElementById('cap-intake-status-top');
    if (!top) {
      top = document.createElement('div');
      top.id = 'cap-intake-status-top';
      top.className = 'small';
      top.style.opacity = '.8';
      top.setAttribute('role','group');
      top.setAttribute('aria-live','polite');
      top.setAttribute('tabindex','0');
    }

    if (top) {
      top.setAttribute('role','group');
      top.setAttribute('aria-live','polite');
      top.setAttribute('tabindex','0');
      top.style.display = 'flex';
      top.style.gap = '8px';
      top.style.flexWrap = 'wrap';
      top.style.alignItems = 'center';
    }

    if (wrap && nab && top) {
      wrap.insertBefore(top, nab);
    } else if (wrap && top && !top.parentElement) {
      wrap.appendChild(top);
    }
  } catch(_) {}
}

// SUBMODULE: updateCaptureIntakeStatus @internal - renders intake KPI pills with aria-friendly labels
const updateCaptureIntakeStatus = debounce(function(){
  const startedAt = (typeof performance !== "undefined" && typeof performance.now === "function") ? performance.now() : null;
  try {
    const statusEl = document.getElementById('cap-intake-status');
    let statusTop = document.getElementById('cap-intake-status-top');
    if (!statusEl && !statusTop) return;

    if (!statusTop) {
      prepareIntakeStatusHeader();
      statusTop = document.getElementById('cap-intake-status-top');
    }

    if (statusTop) {
      statusTop.setAttribute('role','group');
      statusTop.setAttribute('aria-live','polite');
      statusTop.setAttribute('tabindex','0');
    }

    if (!captureIntakeState.logged){
      if (statusEl) {
        statusEl.textContent = 'Bitte anmelden, um Intake zu erfassen.';
        statusEl.style.display = '';
      }
      if (statusTop) {
        statusTop.innerHTML = '';
        statusTop.style.display = 'none';
        statusTop.setAttribute('aria-label', 'Tagesaufnahme: Bitte anmelden, um Intake zu erfassen.');
      }
      return;
    }

    const t = captureIntakeState.totals || {};
    const waterVal = Math.round(t.water_ml || 0);
    const saltVal = Number(t.salt_g || 0);
    const proteinVal = Number(t.protein_g || 0);

    const waterRatio = LS_WATER_GOAL ? waterVal / LS_WATER_GOAL : 0;
    const waterCls = waterRatio >= 0.9 ? 'ok' : (waterRatio >= 0.5 ? 'warn' : 'bad');
    const saltCls = saltVal > LS_SALT_MAX ? 'bad' : (saltVal >= 5 ? 'warn' : 'ok');
    const proteinCls = (proteinVal >= 78 && proteinVal <= LS_PROTEIN_GOAL) ? 'ok' : (proteinVal > LS_PROTEIN_GOAL ? 'bad' : 'warn');

    const describe = (cls) => ({
      ok: 'Zielbereich',
      warn: 'Warnung',
      bad: 'kritisch',
      neutral: 'neutral'
    }[cls] || 'unbekannt');

    const pills = [
      { cls: waterCls, label: 'Wasser', value: `${waterVal} ml` },
      { cls: saltCls, label: 'Salz', value: `${fmtDE(saltVal,1)} g` },
      { cls: proteinCls, label: 'Protein', value: `${fmtDE(proteinVal,1)} g` },
    ];

    const summary = pills.map(p => `${p.label} ${p.value} (${describe(p.cls)})`).join(', ');
    const html = pills.map(p => {
      const statusText = describe(p.cls);
      const aria = `${p.label}: ${p.value}, Status: ${statusText}`;
      return `<span class="pill ${p.cls}" role="status" aria-label="${aria}"><span class="dot" aria-hidden="true"></span>${p.label}: ${p.value}</span>`;
    }).join(' ');

    if (statusEl) {
      statusEl.innerHTML = '';
      statusEl.style.display = 'none';
    }
    if (statusTop) {
      statusTop.innerHTML = html;
      statusTop.style.display = 'flex';
      statusTop.setAttribute('aria-label', `Tagesaufnahme: ${summary}`);
    }
  } finally {
    recordPerfStat('header_intake', startedAt);
  }
}, 150);

// SUBMODULE: millisUntilNextMidnight @internal - calculates next zero reset window
function millisUntilNextMidnight(){
  try {
    const now = new Date();
    const next = new Date(now);
    next.setHours(0, 0, 10, 0);
    next.setDate(next.getDate() + 1);
    const diff = next.getTime() - now.getTime();
    return isNaN(diff) ? 3600_000 : Math.max(1000, diff);
  } catch { return 3600_000; }
}

// SUBMODULE: handleMidnightRefresh @internal - trigger capture refresh on new day
async function handleMidnightRefresh(){
  __midnightTimer = null;
  try {
    await maybeRefreshForTodayChange({ force: true, source: 'midnight' });
  } finally {
    scheduleMidnightRefresh();
  }
}

// SUBMODULE: scheduleMidnightRefresh @internal - arms midnight timer loop
function scheduleMidnightRefresh(){
  try {
    if (__midnightTimer) clearTimeout(__midnightTimer);
    const delay = millisUntilNextMidnight();
    __midnightTimer = setTimeout(handleMidnightRefresh, delay);
  } catch { /* noop */ }
}

// Fire-and-Forget: Intake-Totals beim echten Tageswechsel auf 0 setzen
// SUBMODULE: maybeResetIntakeForToday - ensures zeroed intake when day rolls over
function maybeResetIntakeForToday(todayIso){
  try {
    const last = window?.localStorage?.getItem(LS_INTAKE_RESET_DONE_KEY) || '';
    if (__intakeResetDoneFor === todayIso || last === todayIso) return;
  } catch(_) { /* ignore storage */ }

  (async () => {
    let guardSet = false;
    try {
      const logged = await isLoggedInFast();
      if (!logged) return;
      const uid = await getUserId();
      if (!uid) return;

      let existing = null;
      try {
        existing = await loadIntakeToday({ user_id: uid, dayIso: todayIso });
      } catch (err) {
        diag.add?.(`[capture] reset intake skip day=${todayIso} (lookup failed: ${err?.message || err})`);
        return;
      }

      const hasTotals = !!(existing && (
        Number(existing.water_ml || 0) > 0 ||
        Number(existing.salt_g || 0) > 0 ||
        Number(existing.protein_g || 0) > 0
      ));

      if (hasTotals) {
        diag.add?.(`[capture] reset intake skip day=${todayIso} (existing totals)`);
        guardSet = true;
      } else {
        diag.add?.(`[capture] reset intake start day=${todayIso}`);
        const zeros = { water_ml: 0, salt_g: 0, protein_g: 0 };
        await saveIntakeTotalsRpc({ dayIso: todayIso, totals: zeros });
        diag.add?.('[capture] reset intake ok');
        guardSet = true;
      }
    } catch(e) {
      try { diag.add?.('[capture] reset intake error: ' + (e?.message || e)); } catch(_) {}
      return;
    } finally {
      if (guardSet) {
        __intakeResetDoneFor = todayIso;
        try { window?.localStorage?.setItem(LS_INTAKE_RESET_DONE_KEY, todayIso); } catch(_) {}
        try { refreshCaptureIntake(); } catch(_) {}
      }
    }
  })();
}

// SUBMODULE: millisUntilNoonGrace @internal - calculates midday cutoff for BP context
function millisUntilNoonGrace(){
  try {
    const now = new Date();
    const next = new Date(now);
    next.setHours(12, 5, 0, 0);
    if (next.getTime() <= now.getTime()) {
      next.setDate(next.getDate() + 1);
    }
    const diff = next.getTime() - now.getTime();
    return Number.isFinite(diff) ? Math.max(1000, diff) : 3600_000;
  } catch {
    return 3600_000;
  }
}

// SUBMODULE: scheduleNoonSwitch @internal - toggles noon-based BP auto context timer
function scheduleNoonSwitch(){
  try {
    if (__noonTimer) clearTimeout(__noonTimer);
    const delay = millisUntilNoonGrace();
    __noonTimer = setTimeout(handleNoonSwitch, delay);
  } catch { /* noop */ }
}

function startDayHeartbeat(){ /* no-op: auf eventgetriebene Variante umgestellt */ }

// SUBMODULE: isAfterNoonGrace @internal - checks midday threshold for BP context
function isAfterNoonGrace(){
  try {
    const now = new Date();
    const minutes = now.getHours() * 60 + now.getMinutes();
    return minutes >= (12 * 60 + 5);
  } catch {
    return false;
  }
}

// SUBMODULE: maybeAutoApplyBpContext @internal - flips BP panes based on time-of-day
function maybeAutoApplyBpContext({ force = false, source = '' } = {}){
  if (!force && __bpUserOverride) return;
  const select = document.getElementById('bpContextSel');
  if (!select) return;
  const dateEl = document.getElementById('date');
  const todayIso = todayStr();
  const selected = dateEl?.value || '';
  if (selected && selected !== todayIso) return;

  const desired = isAfterNoonGrace() ? 'A' : 'M';
  if (select.value === desired) return;

  select.value = desired;
  applyBpContext(desired);
  updateBpCommentWarnings?.();
  diag.add?.(`bp:auto (${source || 'auto'}) -> ${desired}`);
}

// SUBMODULE: handleNoonSwitch @internal - noon timer callback to adjust BP context
function handleNoonSwitch(){
  __noonTimer = null;
  try {
    maybeAutoApplyBpContext({ source: 'noon-timer' });
  } finally {
    scheduleNoonSwitch();
  }
}

// SUBMODULE: getBpPanes @internal - caches BP accordion panes for faster toggles
function getBpPanes(){
  if (!__bpPanesCache || __bpPanesCache.length === 0) {
    __bpPanesCache = Array.from(document.querySelectorAll('.bp-pane'));
  }
  return __bpPanesCache;
}

// SUBMODULE: applyBpContext @internal - swaps visible BP pane
function applyBpContext(value){
  const ctx = value === 'A' ? 'A' : 'M';
  getBpPanes().forEach(pane => {
    const match = pane.getAttribute('data-context') === ctx;
    pane.classList.toggle('active', match);
  });
}

// SUBMODULE: maybeRefreshForTodayChange @extract-candidate - reconciles capture state across day changes
async function maybeRefreshForTodayChange({ force = false, source = '' } = {}){
  const todayIso = todayStr();
  const dateEl = document.getElementById('date');
  const selected = dateEl?.value || '';
  const todayChanged = __lastKnownToday !== todayIso;
  if (!force && !todayChanged) return;

  const userPinnedOtherDay = __dateUserSelected && selected && selected !== todayIso;
  if (!userPinnedOtherDay && dateEl) {
    if (selected !== todayIso) {
      dateEl.value = todayIso;
    }
    __dateUserSelected = false;
  }

  // Tageswechsel erkannt -> Intake ggf. automatisch auf 0 zuruecksetzen
  if (!userPinnedOtherDay) {
    try { maybeResetIntakeForToday(todayIso); } catch(_) {}
  }

  try {
    await refreshCaptureIntake();
  } catch(_) {}

  __lastKnownToday = todayIso;
  if (!__midnightTimer) scheduleMidnightRefresh();
  scheduleNoonSwitch();
  if (!userPinnedOtherDay) {
    __bpUserOverride = false;
    maybeAutoApplyBpContext({ force: true, source: source || 'day-change' });
  }
  diag.add?.(`intake: day refresh (${source || 'auto'})`);
}

/** END MODULE */

/** MODULE: APPOINTMENTS
 * intent: CRUD und UI-Sync fuer Arzttermine inkl. Badge und Summary Mapping
 * contracts: nutzt DATA ACCESS.fetchWithAuth, UI.requestUiRefresh, AUTH.getHeaders
 * exports: refreshAppointments, handleAppointmentSave, handleAppointmentDone, bindAppointmentsPanel, setAppointmentBadge
 * notes: integriert Capture-Header-Pills; reine Kommentare
 */
// SUBMODULE: getAppointmentsEndpoint @internal - derives base URL for appointments REST calls
async function getAppointmentsEndpoint(){
  const rest = await getConf('webhookUrl');
  if (!rest) return null;
  const base = baseUrlFromRest(rest);
  if (!base) {
    setConfigStatus('Bitte REST-Endpoint konfigurieren.', 'error');
    return null;
  }
  return { base };
}

// SUBMODULE: getAppointmentRoleLabel @internal - human readable role label
function getAppointmentRoleLabel(code){
  const role = APPOINTMENT_ROLES.find(r => r.code === code);
  return role ? role.label : (code || '');
}

// SUBMODULE: setAppointmentBadge @internal - updates capture header appointment pill
const setAppointmentBadge = debounce(function(details){
  const badge = document.getElementById('nextApptBadge');
  if (!badge) return;

  const startedAt = (typeof performance !== "undefined" && typeof performance.now === "function") ? performance.now() : null;
  try {
    badge.setAttribute('role','status');
    badge.setAttribute('aria-live','polite');
    badge.setAttribute('tabindex','0');

    const role = details?.role || null;
    const dtIso = details?.dt || null;

    if (!role || !dtIso) {
      badge.textContent = 'Kein Termin geplant';
      badge.title = 'Kein Termin geplant';
      badge.setAttribute('aria-label', 'Kein Termin geplant');
      badge.dataset.role = '';
      badge.dataset.dt = '';
      return;
    }

    const label = getAppointmentRoleLabel(role);
    const formatted = formatDateTimeDE(dtIso);
    const text = `N\u00e4chster Arzttermin bei: ${label} am: ${formatted}`;
    badge.textContent = text;
    badge.title = `Arzttermin bei ${label} am ${formatted}`;
    badge.setAttribute('aria-label', text);
    badge.dataset.role = role;
    badge.dataset.dt = dtIso;
  } finally {
    recordPerfStat('header_appt', startedAt);
  }
}, 160);

// SUBMODULE: computeNextAppointment @internal - finds nearest upcoming appointment
function computeNextAppointment(summary){
  if (!summary) return null;
  let nextRole = null;
  let nextIso = null;
  let nextTs = Number.POSITIVE_INFINITY;
  const nowTs = Date.now();

  for (const { code } of APPOINTMENT_ROLES) {
    const nextCandidate = summary[code]?.next;
    if (!nextCandidate) continue;
    const ts = Date.parse(nextCandidate);
    if (!Number.isFinite(ts)) continue;
    if (ts < nowTs - APPOINTMENT_GRACE_MS) continue;
    if (ts < nextTs) {
      nextTs = ts;
      nextRole = code;
      nextIso = nextCandidate;
    }
  }

  if (!nextRole || !nextIso) return null;
  return { role: nextRole, dt: nextIso };
}

// SUBMODULE: validateAppointmentInput @internal - guards appointment form inputs
function validateAppointmentInput({ date, time }){
  if (!date || !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return { ok: false, error: 'date' };
  }
  if (!time || !/^([01]\d|2[0-3]):[0-5]\d$/.test(time)) {
    return { ok: false, error: 'time' };
  }
  const dt = new Date(`${date}T${time}:00`);
  if (Number.isNaN(dt.getTime())) {
    return { ok: false, error: 'invalid' };
  }
  return { ok: true, iso: dt.toISOString() };
}

// SUBMODULE: resetAppointmentsUi @internal - clears appointment UI state
function resetAppointmentsUi(){
  APPOINTMENT_ROLES.forEach(({ code }) => {
    const nextEl = document.getElementById(`appt-${code}-next`);
    const lastEl = document.getElementById(`appt-${code}-last`);
    const doneBtn = document.getElementById(`appt-${code}-done`);
    if (nextEl) nextEl.textContent = '\u2014';
    if (lastEl) lastEl.textContent = '\u2014';
    if (doneBtn){
      doneBtn.disabled = true;
      doneBtn.dataset.hasNext = '0';
      doneBtn.hidden = true;
    }
  });
  appointmentsState.next = null;
  setAppointmentBadge();
}

// SUBMODULE: applyAppointmentsUi @internal - binds fetched appointment summary to DOM
function applyAppointmentsUi(summary){
  APPOINTMENT_ROLES.forEach(({ code }) => {
    const record = summary && summary[code] ? summary[code] : { next: null, last: null };
    const nextEl = document.getElementById(`appt-${code}-next`);
    const lastEl = document.getElementById(`appt-${code}-last`);
    const doneBtn = document.getElementById(`appt-${code}-done`);
    if (nextEl) nextEl.textContent = formatDateTimeDE(record.next);
    if (lastEl) lastEl.textContent = formatDateTimeDE(record.last);
    if (doneBtn){
      doneBtn.disabled = !record.next;
      doneBtn.dataset.hasNext = record.next ? '1' : '0';
      doneBtn.hidden = !record.next;
    }
  });
}

// SUBMODULE: fetchAppointmentsSummary @internal - loads scheduled/done appointments from REST
async function fetchAppointmentsSummary(){
  const rest = await getConf('webhookUrl');
  if (!rest) return null;
  const base = baseUrlFromRest(rest);
  if (!base) return null;

  const fetchJson = async (url) => {
    const res = await fetchWithAuth(
      headers => fetch(url.toString(), { headers }),
      { tag: 'appt:summary', maxAttempts: 2 }
    );
    if (res.status === 404) return [];
    if (!res.ok) {
      let details = '';
      try { const err = await res.json(); details = err?.message || err?.details || ''; } catch(_){ }
      throw new Error(`appointments fetch failed ${res.status} ${details}`);
    }
    return await res.json();
  };

  const scheduledUrl = new URL(`${base}/rest/v1/appointments`);
  scheduledUrl.searchParams.set('select', 'role,dt');
  scheduledUrl.searchParams.set('status', 'eq.scheduled');
  scheduledUrl.searchParams.set('order', 'dt.asc');

  const doneUrl = new URL(`${base}/rest/v1/appointments`);
  doneUrl.searchParams.set('select', 'role,dt');
  doneUrl.searchParams.set('status', 'eq.done');
  doneUrl.searchParams.set('order', 'dt.desc');

  const [scheduled, done] = await Promise.all([
    fetchJson(scheduledUrl),
    fetchJson(doneUrl)
  ]);
  return { scheduled, done };
}

// SUBMODULE: refreshAppointments @internal - orchestrates summary fetch and UI update
async function refreshAppointments(){
  if (appointmentsState.loading) return;
  appointmentsState.loading = true;
  try {
    const summaryRaw = await fetchAppointmentsSummary();
    const scheduledList = Array.isArray(summaryRaw?.scheduled) ? summaryRaw.scheduled : [];
    const doneList = Array.isArray(summaryRaw?.done) ? summaryRaw.done : [];

    const scheduledMap = new Map();
    for (const item of scheduledList) {
      const role = item?.role;
      const dt = item?.dt;
      if (!role || !dt) continue;
      if (!scheduledMap.has(role)) {
        scheduledMap.set(role, item);
      }
    }

    const doneMap = new Map();
    for (const item of doneList) {
      const role = item?.role;
      const dt = item?.dt;
      if (!role || !dt) continue;
      if (!doneMap.has(role)) {
        doneMap.set(role, item);
      }
    }

    const summary = Object.create(null);
    const now = Date.now();

    APPOINTMENT_ROLES.forEach(({ code }) => {
      let nextIso = null;
      let lastIso = doneMap.get(code)?.dt ?? null;

      const scheduled = scheduledMap.get(code);
      if (scheduled?.dt) {
        const ts = Date.parse(scheduled.dt);
        if (Number.isFinite(ts)) {
          if (ts >= now - APPOINTMENT_GRACE_MS) {
            nextIso = scheduled.dt;
          } else if (!lastIso) {
            lastIso = scheduled.dt;
          }
        }
      }

      summary[code] = { next: nextIso, last: lastIso };
    });

    appointmentsState.data = summary;
    appointmentsState.loaded = true;
    applyAppointmentsUi(summary);
    const nextAppt = computeNextAppointment(summary);
    appointmentsState.next = nextAppt;
    setAppointmentBadge(nextAppt);
  } catch (e) {
    diag.add?.('appointments refresh error: ' + (e?.message || e));
    appointmentsState.data = Object.create(null);
    appointmentsState.loaded = false;
    resetAppointmentsUi();
  } finally {
    appointmentsState.loading = false;
  }
}


// SUBMODULE: handleAppointmentSave @internal - POST/PUT appointment scheduling flow
async function handleAppointmentSave(role){
  const dateEl = document.getElementById(`appt-${role}-date`);
  const timeEl = document.getElementById(`appt-${role}-time`);
  const saveBtn = document.getElementById(`appt-${role}-save`);
  if (!dateEl || !timeEl || !saveBtn) return;

  const date = (dateEl.value || '').trim();
  const time = (timeEl.value || '').trim();
  const validation = validateAppointmentInput({ date, time });
  if (!validation.ok){
    if (validation.error === 'date'){
      uiError('Bitte Datum waehlen.');
      dateEl.focus();
    } else if (validation.error === 'time'){
      uiError('Bitte Uhrzeit im Format HH:MM angeben.');
      timeEl.focus();
    } else {
      uiError('Bitte Datum/Uhrzeit pruefen.');
      timeEl.focus();
    }
    return;
  }

  const endpoint = await getAppointmentsEndpoint();
  const base = endpoint?.base || null;
  const iso = validation.iso;

  const hasScheduled = !!(appointmentsState.data && appointmentsState.data[role] && appointmentsState.data[role].next);
  const patchUrl = base ? new URL(base + '/rest/v1/appointments') : null;
  if (patchUrl){
    patchUrl.searchParams.set('status', 'eq.scheduled');
    patchUrl.searchParams.set('role', 'eq.' + role);
  }

  const body = JSON.stringify({ dt: iso });
  withBusy(saveBtn, true);
  try {
    if (!base || !patchUrl){
      const errMissing = new Error('appointments-endpoint-missing');
      errMissing.status = 401;
      throw errMissing;
    }

    let saved = false;
    if (hasScheduled){
      const res = await fetchWithAuth(
        headers => fetch(patchUrl.toString(), { method: 'PATCH', headers, body }),
        { tag: 'appt:patch', maxAttempts: 2 }
      );
      if (!res.ok){
        let details = '';
        try { const err = await res.json(); details = err?.message || err?.details || ''; } catch(_){ }
        if (res.status === 400){
          uiError('Bitte Datum/Uhrzeit pruefen (HH:MM).');
          timeEl.focus();
          return;
        }
        if (res.status !== 404){
          const errPatch = new Error('appointments-patch-failed');
          errPatch.status = res.status;
          errPatch.details = details;
          throw errPatch;
        }
      } else {
        saved = true;
      }
    }

    if (!saved){
      const uid = await getUserId();
      if (!uid){
        const errAuth = new Error('appointments-user-missing');
        errAuth.status = 401;
        throw errAuth;
      }
      const postUrl = new URL(base + '/rest/v1/appointments');
      const payload = JSON.stringify([{ role, dt: iso, status: 'scheduled', user_id: uid }]);
      const resPost = await fetchWithAuth(
        headers => fetch(postUrl.toString(), { method: 'POST', headers, body: payload }),
        { tag: 'appt:post', maxAttempts: 2 }
      );
      if (resPost.status === 409){
        uiError('Es existiert bereits ein geplanter Termin. Bitte aktualisieren.');
        return;
      }
      if (!resPost.ok){
        let details = '';
        try { const err = await resPost.json(); details = err?.message || err?.details || ''; } catch(_){ }
        if (resPost.status === 400){
          uiError('Bitte Datum/Uhrzeit pruefen (HH:MM).');
          timeEl.focus();
          return;
        }
        const errPost = new Error('appointments-post-failed');
        errPost.status = resPost.status;
        errPost.details = details;
        throw errPost;
      }
    }

    dateEl.value = '';
    timeEl.value = '';
    await refreshAppointments();
    uiInfo('Termin gespeichert.');
  } catch (e){
    if (e?.status === 400){
      uiError('Bitte Datum/Uhrzeit pruefen (HH:MM).');
      timeEl.focus();
    } else if (e?.status === 401 || e?.status === 403){
      showLoginOverlay(true);
      uiError('Bitte erneut anmelden.');
    } else if (e?.status) {
      uiRestError(e.status, e.details || e.message);
      try {
        diag.add?.('appointments save error (' + role + '): ' + (e?.details || e?.message || e));
      } catch (logErr) {
        console.error('diag.add failed', logErr);
      }
    } else {
      uiError('Speichern fehlgeschlagen. Bitte erneut versuchen.');
      try {
        diag.add?.('appointments save error (' + role + '): ' + (e?.message || e));
      } catch (logErr) {
        console.error('diag.add failed', logErr);
      }
    }
  } finally {
    withBusy(saveBtn, false);
  }
}
// SUBMODULE: handleAppointmentDone @internal - marks scheduled appointment as completed
async function handleAppointmentDone(role){
  const btn = document.getElementById(`appt-${role}-done`);
  if (!btn || btn.hidden || btn.disabled || btn.dataset.hasNext !== '1') return;

  const endpoint = await getAppointmentsEndpoint();
  const base = endpoint?.base || null;
  withBusy(btn, true);
  try {
    if (!base){
      const errMissing = new Error('appointments-endpoint-missing');
      errMissing.status = 401;
      throw errMissing;
    }
    const url = new URL(base + '/rest/v1/appointments');
    url.searchParams.set('status', 'eq.scheduled');
    url.searchParams.set('role', 'eq.' + role);
    const body = JSON.stringify({ status: 'done' });

    const res = await fetchWithAuth(
      headers => fetch(url.toString(), { method: 'PATCH', headers, body }),
      { tag: 'appt:done', maxAttempts: 2 }
    );
    if (!res.ok){
      let details = '';
      try { const err = await res.json(); details = err?.message || err?.details || ''; } catch(_){ }
      if (res.status === 404){
        uiError('Kein geplanter Termin vorhanden.');
        await refreshAppointments();
        return;
      }
      const errDone = new Error('appointments-done-failed');
      errDone.status = res.status;
      errDone.details = details;
      throw errDone;
    }
    await refreshAppointments();
    uiInfo('Termin abgeschlossen.');
  } catch (e){
    if (e?.status === 401 || e?.status === 403){
      showLoginOverlay(true);
      uiError('Bitte erneut anmelden.');
    } else if (e?.status) {
      uiRestError(e.status, e.details || e.message, 'Termin konnte nicht abgeschlossen werden.');
      try {
        diag.add?.('appointments done error (' + role + '): ' + (e?.details || e?.message || e));
      } catch (logErr) {
        console.error('diag.add failed', logErr);
      }
    } else {
      uiError('Termin konnte nicht abgeschlossen werden.');
      try {
        diag.add?.('appointments done error (' + role + '): ' + (e?.message || e));
      } catch (logErr) {
        console.error('diag.add failed', logErr);
      }
    }
  } finally {
    withBusy(btn, false);
  }
}
// SUBMODULE: bindAppointmentsPanel @internal - wires appointment buttons to handlers
function bindAppointmentsPanel(){
  APPOINTMENT_ROLES.forEach(({ code }) => {
    const saveBtn = document.getElementById(`appt-${code}-save`);
    const doneBtn = document.getElementById(`appt-${code}-done`);
    if (saveBtn) saveBtn.addEventListener('click', () => handleAppointmentSave(code));
    if (doneBtn) doneBtn.addEventListener('click', () => handleAppointmentDone(code));
  });
}

/** END MODULE */

/** MODULE: CAPTURE (Intake)
 * intent: UI Helpers fuer Intake-Status, Guards und Reset-Flows (Fortsetzung)
 * contracts: nutzt requestUiRefresh, saveIntakeTotals*, DATA ACCESS Helfer
 * exports: setCaptureIntakeDisabled, prepareIntakeStatusHeader, updateCaptureIntakeStatus, clearCaptureIntakeInputs, handleCaptureIntake
 * notes: Fortsetzung des Capture-Logikblocks (Status/Guards)
 */
// SUBMODULE: clearCaptureIntakeInputs @internal - leert temporaere Intake-Felder vor neuem Save-Lauf
function clearCaptureIntakeInputs(){
  ['water', 'salt', 'protein'].forEach(kind => {
    const input = document.getElementById(`cap-${kind}-add`);
    if (input) input.value = '';
  });
}

// SUBMODULE: refreshCaptureIntake @extract-candidate - laedt Intake-Daten und synchronisiert Pills/UI
async function refreshCaptureIntake(){
  const wrap = document.getElementById('cap-intake-wrap');
  if (!wrap) return;
  const dayIso = document.getElementById('date')?.value || todayStr();
  captureIntakeState.dayIso = dayIso;
  clearCaptureIntakeInputs();

const logged = await isLoggedInFast();
// Unknown-Phase: so tun, als ob weiter eingeloggt (keine Sperre!)
const effectiveLogged = (__authState === 'unknown' && __lastLoggedIn) ? true : !!logged;
captureIntakeState.logged = effectiveLogged;

if (!effectiveLogged){
  captureIntakeState.totals = { water_ml: 0, salt_g: 0, protein_g: 0 };
  setCaptureIntakeDisabled(true);
  updateCaptureIntakeStatus();
  try{ __lsTotals = { water_ml: 0, salt_g: 0, protein_g: 0 }; updateLifestyleBars(); }catch(_){ }
  return;
}

setCaptureIntakeDisabled(false);
try{
  const uid = await getUserId();
  // Unknown-Phase: UID kann transient null sein -> NICHT sperren
  if (!uid && __authState !== 'unknown'){
    captureIntakeState.logged = false;
    captureIntakeState.totals = { water_ml: 0, salt_g: 0, protein_g: 0 };
    setCaptureIntakeDisabled(true);
  } else {
      const totals = await loadIntakeToday({ user_id: uid, dayIso });
      captureIntakeState.totals = totals || { water_ml: 0, salt_g: 0, protein_g: 0 };
      captureIntakeState.logged = true;
      try{ __lsTotals = captureIntakeState.totals; updateLifestyleBars(); }catch(_){ }
    }
  }catch(e){
    captureIntakeState.totals = { water_ml: 0, salt_g: 0, protein_g: 0 };
    try {
      diag.add?.('Capture intake load error: ' + (e?.message || e));
      updateLifestyleBars();
    } catch(_) { }
  }

  __lastKnownToday = todayStr();
  updateCaptureIntakeStatus();
}

// SUBMODULE: handleCaptureIntake @internal - validiert Intake-Eingaben, triggert RPC-Speicherpfad und Refresh-Fallbacks
async function handleCaptureIntake(kind){
  const btn = document.getElementById(`cap-${kind}-add-btn`);
  const input = document.getElementById(`cap-${kind}-add`);
  if (!btn || !input) return;

  diag.add?.(`[capture] click ${kind}`);

  try {
    if (!__dateUserSelected) {
      const todayIso = todayStr();
      const dateEl = document.getElementById('date');
      const selected = dateEl?.value || '';
      const stateDay = captureIntakeState.dayIso || '';
      if (stateDay !== todayIso || (selected && selected !== todayIso)) {
        await maybeRefreshForTodayChange({ force: true, source: 'capture:intake-click' });
      }
    }
  } catch(_){ }

  const dayIso = document.getElementById('date')?.value || todayStr();
  captureIntakeState.dayIso = dayIso;

  let value;
  if (kind === 'water'){
    value = Number(input.value);
    if (!(value > 0)){
      uiError('Bitte gueltige Wassermenge eingeben.');
      diag.add?.('[capture] blocked: invalid water value ' + input.value);
      return;
    }
  } else {
    value = toNumDE(input.value);
    if (!(value > 0)){
      uiError(kind === 'salt' ? 'Bitte gueltige Salzmenge eingeben.' : 'Bitte gueltige Proteinmenge eingeben.');
      diag.add?.(`[capture] blocked: invalid ${kind} value ${input.value}`);
      return;
    }
  }
  diag.add?.(`[capture] parsed ${kind}=${value}`);

  const totals = { ...captureIntakeState.totals };
  let message = '';
  if (kind === 'water'){
    const total = Math.min(6000, Math.max(0, (totals.water_ml || 0) + value));
    totals.water_ml = Math.round(total);
    message = 'Wasser aktualisiert.';
  } else if (kind === 'salt'){
    const total = Math.min(30, Math.max(0, (totals.salt_g || 0) + value));
    totals.salt_g = Number(total.toFixed(2));
    message = 'Salz aktualisiert.';
  } else {
    const total = Math.min(300, Math.max(0, (totals.protein_g || 0) + value));
    totals.protein_g = Number(total.toFixed(2));
    message = 'Protein aktualisiert.';
  }
  diag.add?.(`[capture] totals ${JSON.stringify(totals)}`);

withBusy(btn, true);
try{
    diag.add?.(`[capture] save start ${kind}: ${JSON.stringify(totals)}`);
    await saveIntakeTotalsRpc({ dayIso, totals });
    diag.add?.('[capture] save network ok');
    captureIntakeState.totals = totals;
    captureIntakeState.logged = true;
    input.value = '';
    updateCaptureIntakeStatus();
    const needsLifestyle = dayIso === todayStr();
    requestUiRefresh({
      reason: 'capture:intake',
      doctor: false,
      chart: false,
      appointments: false,
      lifestyle: needsLifestyle
    }).catch(err => {
      diag.add?.('ui refresh err: ' + (err?.message || err));
    });
    uiInfo(message);
    diag.add?.(`[capture] save ok ${kind}`);
  }catch(e){
    const msg = e?.details || e?.message || e;
    if (e?.status === 401 || e?.status === 403) {
      showLoginOverlay(true);
      uiError('Bitte erneut anmelden, um weiter zu speichern.');
    } else {
      uiError('Update fehlgeschlagen: ' + msg);
    }
    diag.add?.(`[capture] save error ${kind}: ` + msg);
  }finally{
    withBusy(btn, false);
  }
}

// SUBMODULE: bindIntakeCapture @extract-candidate - verbindet Intake-Inputs mit Save/Guard Flows
function bindIntakeCapture(){
  const wire = (id, kind) => {
    const oldBtn = document.getElementById(id);
    if (!oldBtn) return;

    // alten Button durch Clone ersetzen => entfernt alle alten Listener
    const fresh = oldBtn.cloneNode(true);
    oldBtn.replaceWith(fresh);

    // Safety: niemals "busy"/disabled, und Typ setzen
    fresh.disabled = false;
    fresh.classList.remove('busy');
    fresh.removeAttribute('aria-busy');
    fresh.removeAttribute('data-busy');
    if (!fresh.type) fresh.type = 'button';

    // Click-Handler binden (idempotent, weil frisch)
    fresh.addEventListener('click', () => {
      try { handleCaptureIntake(kind); } catch(_) {}
    });
  };

  wire('cap-water-add-btn',   'water');
  wire('cap-salt-add-btn',    'salt');
  wire('cap-protein-add-btn', 'protein');
}

function setProgState(el, state){
  if (!el) return;
  el.classList.remove('ok','warn','bad');
  if (state) el.classList.add(state);
}

function fmtDE(n, digits){
  if (!Number.isFinite(n)) return '0';
  return n.toFixed(digits).replace('.', ',');
}

function updateLifestyleBars(){
  const wBar = document.getElementById('ls-water-bar');
  const wProg = document.getElementById('ls-water-prog');
  const wLbl = document.getElementById('ls-water-label');
  const sBar = document.getElementById('ls-salt-bar');
  const sProg = document.getElementById('ls-salt-prog');
  const sLbl = document.getElementById('ls-salt-label');
  const pBar = document.getElementById('ls-protein-bar');
  const pProg = document.getElementById('ls-protein-prog');
  const pLbl = document.getElementById('ls-protein-label');

  const w = Math.max(0, Math.min(__lsTotals.water_ml || 0, 6000));
  const s = Math.max(0, Math.min(__lsTotals.salt_g || 0, 30));
  const p = Math.max(0, Math.min(__lsTotals.protein_g || 0, 300));

  const wPct = Math.min(1, w / LS_WATER_GOAL) * 100;
  const sPct = Math.min(1, s / LS_SALT_MAX) * 100;
  const pPct = Math.min(1, p / LS_PROTEIN_GOAL) * 100;

  if (wBar) wBar.style.width = `${wPct.toFixed(1)}%`;
  if (sBar) sBar.style.width = `${sPct.toFixed(1)}%`;
  if (pBar) pBar.style.width = `${pPct.toFixed(1)}%`;

  if (wLbl) {
    let status = '';
    if (w >= LS_WATER_GOAL * 1.1) status = ' * Ziel erreicht';
    else if (w >= LS_WATER_GOAL * 0.9) status = ' * Zielbereich';
    else if (w >= LS_WATER_GOAL * 0.5) status = ' * moderate Aufnahme';
    else status = ' * niedrig';
    wLbl.textContent = `${w|0} / ${LS_WATER_GOAL} ml${status}`;
  }

  if (sLbl) {
    let status = ' * Zielbereich';
    if (s > LS_SALT_MAX) status = ' * ueber Ziel';
    else if (s >= 5) status = ' * Warnung';
    sLbl.textContent = `${fmtDE(s,1)} / ${fmtDE(LS_SALT_MAX,1)} g${status}`;
  }

  if (pLbl) {
    let status = ' * noch offen';
    if (p >= 78 && p <= 90) status = ' * Zielbereich';
    else if (p > 90) status = ' * ueber Ziel';
    pLbl.textContent = `${fmtDE(p,1)} / ${fmtDE(LS_PROTEIN_GOAL,1)} g${status}`;
  }

  // Wasser: <50% rot, 50-89% gelb, 90% gruen
  let wState = 'bad';
  if (w >= LS_WATER_GOAL * 0.9) wState = 'ok';
  else if (w >= LS_WATER_GOAL * 0.5) wState = 'warn';
  setProgState(wProg, wState);

  // Salz: 0-4.9 g gruen, 5-6 gelb, >6 rot
  let sState = 'ok';
  if (s > LS_SALT_MAX) sState = 'bad';
  else if (s >= 5) sState = 'warn';
  setProgState(sProg, sState);

  // Protein: <78 neutral, 78-90 gruen, >90 rot
  let pState = 'neutral';
  if (p >= 78 && p <= 90) pState = 'ok';
  else if (p > 90) pState = 'bad';
  setProgState(pProg, pState);
}

async function renderLifestyle(){
  const logged = await isLoggedIn();
  if (!logged){
    // Nichts anzeigen, Tab ist ohnehin gesperrt
    return;
  }
  try{
    const uid = await getUserId();
    const dayIso = todayStr();
    const cur = await loadIntakeToday({ user_id: uid, dayIso });
    __lsTotals = { water_ml: cur.water_ml||0, salt_g: cur.salt_g||0, protein_g: cur.protein_g||0 };
    updateLifestyleBars();
  }catch(_){ /* ignore */ }
}

function bindLifestyle(){
  const addWaterBtn = document.getElementById('ls-water-add-btn');
  const addSaltBtn = document.getElementById('ls-salt-add-btn');
  const addProtBtn = document.getElementById('ls-protein-add-btn');

  const addWater = async ()=>{
    const el = document.getElementById('ls-water-add');
    const v = Number(el?.value || 0);
    if (!(v>0)) { uiError('Bitte gueltige Wassermenge eingeben.'); return; }

    const dayIso = todayStr();
    let total = Math.min(6000, Math.max(0, (__lsTotals.water_ml||0) + v));
    if (total > 6000) total = 6000;
    try{
      await saveIntakeTotalsRpc({ dayIso, totals: { water_ml: total, salt_g: __lsTotals.salt_g||0, protein_g: __lsTotals.protein_g||0 } });
      __lsTotals.water_ml = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Wasser aktualisiert.');
  }catch(e){
    uiError('Update fehlgeschlagen: ' + (e?.message||e));
    try {
      diag.add?.('Lifestyle update error (water): ' + (e?.message||e));
    } catch (logErr) {
      console.error('diag.add failed', logErr);
    }
  }
  };

  const addSalt = async ()=>{
    const el = document.getElementById('ls-salt-add');
    const v = toNumDE(el?.value);
    if (!(v>0)) { uiError('Bitte gueltige Salzmenge eingeben.'); return; }
    const dayIso = todayStr();
    let total = (__lsTotals.salt_g||0) + v;
    if (total > 30) total = 30;
    try{
      await saveIntakeTotalsRpc({ dayIso, totals: { water_ml: __lsTotals.water_ml||0, salt_g: total, protein_g: __lsTotals.protein_g||0 } });
      __lsTotals.salt_g = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Salz aktualisiert.');
  }catch(e){
    uiError('Update fehlgeschlagen: ' + (e?.message||e));
    try {
      diag.add?.('Lifestyle update error (salt): ' + (e?.message||e));
    } catch (logErr) {
      console.error('diag.add failed', logErr);
    }
  }
  };

  const addProtein = async ()=>{
    const el = document.getElementById('ls-protein-add');
    const v = toNumDE(el?.value);
    if (!(v>0)) { uiError('Bitte gueltige Proteinmenge eingeben.'); return; }
    const dayIso = todayStr();
    let total = (__lsTotals.protein_g||0) + v;
    if (total > 300) total = 300;
    try{
      await saveIntakeTotalsRpc({ dayIso, totals: { water_ml: __lsTotals.water_ml||0, salt_g: __lsTotals.salt_g||0, protein_g: total } });
      __lsTotals.protein_g = total;
      updateLifestyleBars();
      el.value = '';
      uiInfo('Protein aktualisiert.');
  }catch(e){
    uiError('Update fehlgeschlagen: ' + (e?.message||e));
    try {
      diag.add?.('Lifestyle update error (protein): ' + (e?.message||e));
    } catch (logErr) {
      console.error('diag.add failed', logErr);
    }
  }
  };

  if (addWaterBtn) addWaterBtn.addEventListener('click', addWater);
  if (addSaltBtn) addSaltBtn.addEventListener('click', addSalt);
  if (addProtBtn) addProtBtn.addEventListener('click', addProtein);
}

// PATCH: bestehende day_flags eines Tages aktualisieren (RLS: nur eigene Records)
// @refactor: moved to assets/js/supabase.js (patchDayFlags)

// @refactor: moved to assets/js/supabase.js (appendNoteRemote)

/** MODULE: DOCTOR VIEW
 * intent: Zeitraumansicht fuer Aerzt:innen inklusive KPIs, Tagesrendering und Cloud-Aktionen
 * contracts: verwendet DATA ACCESS.fetchDailyOverview, AUTH.requireDoctorUnlock, UI.requestUiRefresh
 * exports: renderDoctor, setDocBadges, renderDoctorDay, exportDoctorJson
 * notes: Markup-Erzeugung stabil halten; @todo buildDoctorSummaryJson @extract-candidate @public fuer Export
 */
/* ===== Doctor view ===== */
// SUBMODULE: setDocBadges @internal - updates toolbar KPI badges for training/bad days
function setDocBadges({ training, bad, visible } = {}) {
  const t = document.getElementById('docTrainCnt');
  const b = document.getElementById('docBadCnt');
  if (!t || !b) return;

  if (training !== undefined) t.querySelector('.val').textContent = String(training);
  if (bad !== undefined)      b.querySelector('.val').textContent = String(bad);

  if (visible !== undefined) {
    t.classList.toggle('hidden', !visible);
    b.classList.toggle('hidden', !visible);
  }
}

const __t0 = performance.now();
// SUBMODULE: renderDoctor @extract-candidate - orchestrates gated render flow, fetches days, manages scroll state
async function renderDoctor(){
  const host = $("#doctorView");
  if (!host) return;

  const scroller = document.getElementById('doctorDailyWrap') || host.parentElement || host;
  if (!scroller.dataset.scrollWatcher) {
    scroller.addEventListener('scroll', () => {
      const h = scroller.scrollHeight || 1;
      __doctorScrollSnapshot.top = scroller.scrollTop;
      __doctorScrollSnapshot.ratio = h ? Math.min(1, scroller.scrollTop / h) : 0;
    }, { passive: true });
    scroller.dataset.scrollWatcher = "1";
  }

  if (!(await isLoggedIn())){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte anmelden, um die Arzt-Ansicht zu sehen.</div>`;
    setDocBadges({ visible: false });
    if (scroller) scroller.scrollTop = 0;
    __doctorScrollSnapshot = { top: 0, ratio: 0 };
    return;
  }
  // Nur sperren, wenn die Arzt-Ansicht wirklich aktiv angezeigt wird
  const doctorSection = document.getElementById('doctor');
  const isActive = !!doctorSection && doctorSection.classList.contains('active');
  if (!isDoctorUnlocked()){
    if (isActive){
      host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte Arzt-Ansicht kurz entsperren.</div>`;
      setDocBadges({ visible: false });
      try { await requireDoctorUnlock(); } catch(_) {}
      if (!isDoctorUnlocked()) return;
    } else {
      return;
    }
  }

  const prevScrollTop = (__doctorScrollSnapshot?.top ?? scroller.scrollTop ?? 0) || 0;
  const prevScrollRatio = (__doctorScrollSnapshot?.ratio ?? 0) || 0;
  host.innerHTML = "";

  // Anzeige-Helper
  const dash = v => (v === null || v === undefined || v === "" ? "-" : String(v));
  const onClass = b => (b ? "on" : "");
  const fmtDateDE = (iso) => {
    const d = new Date(iso + "T00:00:00Z");
    return d.toLocaleDateString("de-AT", { weekday:"short", day:"2-digit", month:"2-digit", year:"numeric" });
  };

  // Zeitraum lesen
  const from = $("#from").value;
  const to   = $("#to").value;
  if (!from || !to){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte Zeitraum waehlen.</div>`;
    setDocBadges({ visible: false });
    if (scroller) scroller.scrollTop = 0;
    __doctorScrollSnapshot = { top: 0, ratio: 0 };
    return;
  }

  //  Server lesen  Tagesobjekte
  let daysArr = [];
  try{
    daysArr = await fetchDailyOverview(from, to);
  }catch(_){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Fehler beim Laden aus der Cloud.</div>`;
    setDocBadges({ visible: false });
    if (scroller) scroller.scrollTop = 0;
    __doctorScrollSnapshot = { top: 0, ratio: 0 };
    return;
  }

  daysArr.sort((a,b)=> b.date.localeCompare(a.date));

  // KPIs
  const trainingDays = daysArr.filter(d => !!d.flags.training).length;
  const badDays = daysArr.filter(d => {
    const f = d.flags;
    return !!(f.water_lt2 || f.salt_gt5 || f.protein_ge90 || f.sick || f.meds);
  }).length;
  setDocBadges({ training: trainingDays, bad: badDays, visible: true });

  // Renderer je Tag
  // SUBMODULE: renderDoctorDay @internal - templates per-day HTML card for doctor view
  const renderDoctorDay = (day) => `
<section class="doctor-day" data-date="${day.date}">
  <div class="col-date">
    <div class="date-top">
      <span class="date-label">${fmtDateDE(day.date)}</span>
      <span class="date-cloud" title="In Cloud gespeichert?">${day.hasCloud ? "&#9729;&#65039;" : ""}</span>
    </div>
    <div class="date-actions">
      <button class="btn ghost btn-xs" data-del-day="${day.date}">Loeschen</button>
    </div>
  </div>

  <div class="col-measure">
    <div class="measure-head">
      <div></div>
      <div>Sys</div><div>Dia</div><div>Puls</div><div>MAP</div>
    </div>
    <div class="measure-grid">
      <div class="measure-row">
        <div class="label">morgens</div>
        <div class="num ${ (day.morning.sys!=null && day.morning.sys>130) ? 'alert' : '' }">${dash(day.morning.sys)}</div>
        <div class="num ${ (day.morning.dia!=null && day.morning.dia>90)  ? 'alert' : '' }">${dash(day.morning.dia)}</div>
        <div class="num">${dash(day.morning.pulse)}</div>
        <div class="num ${ (day.morning.map!=null && day.morning.map>100) ? 'alert' : '' }">${dash(fmtNum(day.morning.map))}</div>
      </div>
      <div class="measure-row">
        <div class="label">abends</div>
        <div class="num ${ (day.evening.sys!=null && day.evening.sys>130) ? 'alert' : '' }">${dash(day.evening.sys)}</div>
        <div class="num ${ (day.evening.dia!=null && day.evening.dia>90)  ? 'alert' : '' }">${dash(day.evening.dia)}</div>
        <div class="num">${dash(day.evening.pulse)}</div>
        <div class="num ${ (day.evening.map!=null && day.evening.map>100) ? 'alert' : '' }">${dash(fmtNum(day.evening.map))}</div>
      </div>
    </div>
  </div>

  <div class="col-special">
    <div class="weight-line">
      <div>Gewicht</div>
      <div class="num">${dash(fmtNum(day.weight))}</div>
    </div>

    <div class="waist-line">
      <div>Bauchumfang (cm)</div>
      <div class="num">${dash(fmtNum(day.waist_cm))}</div>
    </div>

    <div class="flags">
      <div class="flag"><span class="flag-box ${onClass(day.flags.water_lt2)}"></span><span>&lt;2L Wasser</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.salt_gt5)}"></span><span>Salz &gt;5g</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.protein_ge90)}"></span><span>Protein &ge; 90 g</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.sick)}"></span><span>Krank</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.meds)}"></span><span>Medikamente</span></div>
      <div class="flag"><span class="flag-box ${onClass(day.flags.training)}"></span><span>Training</span></div>
    </div>

    <div class="notes">${nl2br((day.notes || "").trim() || "-")}</div>
  </div>
</section>
`;

  // Rendern / Leerzustand
  if (!daysArr.length){
    host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Keine Eintraege im Zeitraum</div>`;
    if (scroller) scroller.scrollTop = 0;
    __doctorScrollSnapshot = { top: 0, ratio: 0 };
  } else {
    host.innerHTML = daysArr.map(renderDoctorDay).join("");

    const restoreScroll = () => {
      const targetEl = scroller || host;
      const height = targetEl.scrollHeight || 1;
      const maxScroll = Math.max(0, height - targetEl.clientHeight);
      const fromTop = Math.max(0, Math.min(prevScrollTop, maxScroll));
      const fromRatio = Math.max(0, Math.min(Math.round(prevScrollRatio * height), maxScroll));
      const target = prevScrollTop ? fromTop : fromRatio;
      targetEl.scrollTop = target;
      const h = targetEl.scrollHeight || 1;
      __doctorScrollSnapshot.top = targetEl.scrollTop;
      __doctorScrollSnapshot.ratio = h ? Math.min(1, targetEl.scrollTop / h) : 0;
    };
    if (typeof requestAnimationFrame === "function") {
      requestAnimationFrame(restoreScroll);
    } else {
      setTimeout(restoreScroll, 0);
    }

    //  Loeschen: alle Server-Events des Tages entfernen
    host.querySelectorAll('[data-del-day]').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const date = btn.getAttribute('data-del-day');
        if (!date) return;
        if (!confirm(`Alle Eintraege in der Cloud fuer ${date} loeschen?`)) return;

        btn.disabled = true;
        const old = btn.textContent;
        btn.textContent = 'Loesche...';
        try{
          const r = await deleteRemoteDay(date);
          if (!r.ok){
            alert(`Server-Loeschung fehlgeschlagen (${r.status||"?"}).`);
          }
          await requestUiRefresh({ reason: 'doctor:delete' });
        } finally {
          btn.disabled = false; btn.textContent = old;
        }
      });
    });
  }
}

/** MODULE: CHARTS (SVG/Canvas)
 * intent: rendert Tages-Charts (BP/Body) inkl. KPI-Leiste, Flags-Overlay und Tooltips
 * contracts: haengt von DATA ACCESS.fetchDailyOverview, UTILITIES esc/fmtNum, PERF.diag Logging, SupabaseAPI.ensureSupabaseClient ab
 * exports: chartPanel
 * notes: drawing/scaling pipelines sind @extract-candidate fuer spaetere Auslagerung
 */
/* ===== Simple SVG Chart (Daily) - final, ohne Doppel-Helper & mit WHO-Ampel ===== */

/* Fallbacks nur, wenn extern nicht verfuegbar */
const safeEnsureSupabaseClient = async () => {
  try { if (typeof ensureSupabaseClient === "function") return await ensureSupabaseClient(); } catch(_) {}
  return null;
};
const safeGetConf = async (k) => {
  try { if (typeof getConf === "function") return await getConf(k); } catch(_) {}
  return null;
};

// SUBMODULE: chartPanel controller @extract-candidate - steuert Panel-Lifecycle, Datenbeschaffung und Zeichnung
const chartPanel = {
  el: null,
  svg: null,
  legend: null,
  open: false,
  tip: null,
  tipSticky: false,
  hoverSeries: null,
  SHOW_BODY_COMP_BARS: true,
  _abort: null,
  _ro: null,
  initialized: false,

  // SUBMODULE: chartPanel.init @internal - richtet Panel, Tooltip und Event-Handler ein
  init() {
    this.destroy();
    this.el = $("#chart");
    this.svg = $("#chartSvg");
    this.legend = $("#chartLegend");

    // Panel initial nicht anzeigen
    if (this.el) this.el.style.display = "none";

    // Close + Metric-Select
    const closeBtn = $("#chartClose");
    const supportsAbort = typeof AbortController === "function";
    this._abort = supportsAbort ? new AbortController() : null;
    if (!supportsAbort) this._listeners = [];
    const signal = this._abort?.signal || null;
    const add = (target, type, handler, opts = {}) => {
      if (!target) return;
      if (signal) {
        target.addEventListener(type, handler, { ...opts, signal });
      } else {
        target.addEventListener(type, handler, opts);
        this._listeners?.push({ target, type, handler, opts });
      }
    };
    add(closeBtn, "click", () => this.hide());
    const metricSel = $("#metricSel");
    add(metricSel, "change", () => this.draw());

    // Tooltip (hover/click)
    const contentHost = this.el?.querySelector(".content") || this.el || document.body;
    const tip = document.createElement("div");
    tip.className = "chart-tip";
    tip.id = "chartTip";
    contentHost.style.position = "relative";
    contentHost.appendChild(tip);
    this.tip = tip;
    this.tipHideTimer = null;

    // ARIA Live-Region (nur Text, fuer Screenreader)
    const live = document.createElement("div");
    live.id = "chartAria";
    live.setAttribute("aria-live", "polite");
    live.setAttribute("role", "status");
    Object.assign(live.style, {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: 0,
      border: 0,
      margin: "-1px",
      clip: "rect(0 0 0 0)",
      overflow: "hidden",
      whiteSpace: "nowrap",
    });
    contentHost.appendChild(live);
    this.live = live;

    // Interaktivitaet
    if (this.svg) {
      add(this.svg, "pointermove", (e) => {
        if (this.tipSticky) return;
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("chart-hit"));
        if (!(isPt || isHit)) { this.hideTip(); return; }
        const date = tgt.getAttribute("data-date") || "";
        const hasNote = !!(tgt.getAttribute("data-note"));
        const hasFlags = this.hasFlagsForDate?.(date);
        if (!(hasNote || hasFlags)) { this.hideTip(); return; }
        this.fillTipFromTarget(tgt);
        this.positionTip(e);
      });

      add(this.svg, "pointerleave", () => {
        if (this.tipSticky) return;
        this.hideTip();
      });

      // Click/Tap: Tooltip toggeln (mobil-freundlich)
      add(this.svg, "click", (e) => {
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("chart-hit"));
        if (!(isPt || isHit)) { if (this.tipSticky) { this.tipSticky = false; this.hideTip(); } return; }
        const date = tgt.getAttribute("data-date") || "";
        const hasNote = !!(tgt.getAttribute("data-note"));
        const hasFlags = this.hasFlagsForDate?.(date);
        if (!(hasNote || hasFlags)) { if (this.tipSticky) { this.tipSticky = false; this.hideTip(); } return; }
        this.fillTipFromTarget(tgt);
        this.tipSticky = !this.tipSticky;
        this.positionTip(e);
      });

      // Keyboard: Enter/Space toggelt Tooltip, ESC schliesst
      add(this.svg, "keydown", (e) => {
        const tgt = e.target;
        const isPt  = !!(tgt && tgt.classList?.contains("pt"));
        const isHit = !!(tgt && tgt.classList?.contains("chart-hit"));
        if (!(isPt || isHit)) return;
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          const date = tgt.getAttribute("data-date") || "";
          const hasNote = !!(tgt.getAttribute("data-note"));
          const hasFlags = this.hasFlagsForDate?.(date);
          if (!(hasNote || hasFlags)) return;
          this.fillTipFromTarget(tgt);
          this.tipSticky = !this.tipSticky;
        } else if (e.key === "Escape") {
          this.tipSticky = false; this.hideTip();
        }
      });
    }

    // Redraw bei Resize/Orientation
    if (this.el) {
      const ro = new ResizeObserver(() => { if (this.open) this.draw(); });
      ro.observe(this.el);
      this._ro = ro;
    }
    add(window, "orientationchange", () => {
      setTimeout(() => { if (this.open) this.draw(); }, 150);
    });

    // KPI-Box: Felder sicherstellen
    this.ensureKpiFields();
    this.initialized = true;
  },

  // SUBMODULE: chartPanel.toggle @internal - schaltet Chart-Panel an/aus inkl. Fokus
  toggle() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
    }
  },

  // SUBMODULE: chartPanel.show @internal - oeffnet Panel und aktiviert focusTrap
  show() {
    if (!this.el || !this.initialized) {
      this.init();
    }
    this.open = true;
    if (this.el) {
      this.el.style.display = "block";
      focusTrap?.activate?.(this.el);
    }
  },

  // SUBMODULE: chartPanel.hide @internal - schliesst Panel, deaktiviert focusTrap und Tooltips
  hide() {
    this.open = false;
    if (this.el) {
      this.el.style.display = "none";
      focusTrap?.deactivate?.();
    }
    this.tipSticky = false;
    this.hideTip();
    this.destroy();
  },
  destroy() {
    if (this._abort) {
      try { this._abort.abort(); } catch (_) {}
    }
    this._abort = null;
    if (this._listeners?.length) {
      try {
        this._listeners.forEach(({ target, type, handler, opts }) => {
          try { target.removeEventListener(type, handler, opts || false); } catch (_) {}
        });
      } catch (_) {
        /* noop */
      }
    }
    this._listeners = null;
    if (this._ro) {
      try { this._ro.disconnect(); } catch (_) {}
    }
    this._ro = null;
    if (this.tip?.parentNode) {
      this.tip.parentNode.removeChild(this.tip);
    }
    if (this.live?.parentNode) {
      this.live.parentNode.removeChild(this.live);
    }
    this.tip = null;
    this.live = null;
    this.tipHideTimer = null;
    this.tipSticky = false;
    this.hoverSeries = null;
    this.svg = null;
    this.el = null;
    this.legend = null;
    this.initialized = false;
  },
  // ----- Helpers -----
  // SUBMODULE: chartPanel.getFiltered @extract-candidate - aggregiert Cloud/Local Daten fuer Zeichnung
async getFiltered() {
  const from = $("#from")?.value;
  const to   = $("#to")?.value;

  // Wenn eingeloggt: Cloud nehmen (Events -> Daily), sonst fallback: lokale Entries
  if (await isLoggedIn()) {
    // gleiche Aggregation wie Arzt-Ansicht
    const days = await fetchDailyOverview(from, to);
    // Fuer die Chart-Logik bauen wir flache "entry"-aehnliche Objekte
    const flat = [];
    for (const d of days) {
      // Morgen
      if (d.morning.sys != null || d.morning.dia != null || d.morning.pulse != null) {
        const ts = Date.parse(d.date + "T07:00:00Z"); // Fix-Zeit am Tag
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Morgen",
          sys: d.morning.sys,
          dia: d.morning.dia,
          pulse: d.morning.pulse,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90,
          fat_kg: null,
          muscle_kg: null
        });
      }
      // Abend
      if (d.evening.sys != null || d.evening.dia != null || d.evening.pulse != null) {
        const ts = Date.parse(d.date + "T19:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Abend",
          sys: d.evening.sys,
          dia: d.evening.dia,
          pulse: d.evening.pulse,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90,
          fat_kg: null,
          muscle_kg: null
        });
      }
      // Body (Gewicht/Bauch)
      if (d.weight != null || d.waist_cm != null) {
        const ts = Date.parse(d.date + "T12:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Tag",
          sys: null, dia: null, pulse: null,
          weight: d.weight,
          waist_cm: d.waist_cm,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90,
          fat_kg: d.fat_kg,
          muscle_kg: d.muscle_kg
        });
      }
    }
    // Ergaenze Tage mit ausschliesslich Flags (ohne BP/Body), damit Flags-Overlay immer angezeigt wird
    for (const d of days) {
      const hasFlags = !!(d?.flags?.training || d?.flags?.sick || d?.flags?.water_lt2 || d?.flags?.salt_gt5 || d?.flags?.protein_ge90 || d?.flags?.meds);
      if (!hasFlags) continue;
      const already = flat.some(e => e?.date === d.date);
      if (!already) {
        const ts = Date.parse(d.date + "T12:00:00Z");
        flat.push({
          date: d.date,
          dateTime: new Date(ts).toISOString(),
          ts,
          context: "Tag",
          sys: null, dia: null, pulse: null,
          weight: null,
          waist_cm: null,
          notes: d.notes || "",
          training: d.flags.training,
          low_intake: d.flags.water_lt2,
          sick: d.flags.sick,
          valsartan_missed: !!d.flags.valsartan_missed,
          forxiga_missed:   !!d.flags.forxiga_missed,
          nsar_taken:       !!d.flags.nsar_taken,
          salt_high: d.flags.salt_gt5,
          protein_high90: d.flags.protein_ge90,
          fat_kg: null,
          muscle_kg: null
        });
      }
    }
    return flat.sort((a,b) => (a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime)));
  }

  // Fallback: lokal (wenn nicht eingeloggt)
  const entries = typeof getAllEntries === "function" ? await getAllEntries() : [];
  return entries
    .filter(e => {
      if (from && e.date < from) return false;
      if (to   && e.date > to)   return false;
      return true;
  })
    .sort((a,b) => (a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime)));
},

  // Hoehe laden (Konfig oder Fallback 183 cm)
  // SUBMODULE: chartPanel.getHeightCm @internal - liest Nutzerkoerpergroesse aus Supabase/Lokal
  async getHeightCm() {
    // 1) Supabase-Profil
    const supa = await safeEnsureSupabaseClient();
    if (supa) {
      try {
        const { data, error } = await supa.from("user_profile").select("height_cm").single();
        if (!error && data?.height_cm) return Number(data.height_cm);
      } catch(_) {}
    }
    // 2) lokale Konfig
    const v = await safeGetConf("height_cm");
    const n = Number(v);
    if (Number.isFinite(n) && n > 0) return n;
    return 183;
  },

  // Tooltip
  hideTip() {
    if (this.tip) {
      this.tip.dataset.visible = "0";
      this.tip.style.opacity = "0";
      clearTimeout(this.tipHideTimer);
      this.tipHideTimer = setTimeout(() => {
        if (!this.tip || this.tip.dataset.visible === "1") return;
        this.tip.style.display = "none";
        this.tip.textContent = "";
      }, 160);
    }
    this.setHoverSeries(null);
  },
  // SUBMODULE: chartPanel.setHoverSeries @internal - hebt aktuelle Serie in Chart/Legende hervor
  setHoverSeries(seriesKey) {
    if (!this.svg && !this.legend) return;
    const nextKey = seriesKey || null;
    if (this.hoverSeries === nextKey) return;
    this.hoverSeries = nextKey;

    const svgNodes = this.svg ? Array.from(this.svg.querySelectorAll('[data-series]')) : [];
    const legendNodes = this.legend ? Array.from(this.legend.querySelectorAll('[data-series]')) : [];
    [...svgNodes, ...legendNodes].forEach(node => {
      node.classList.remove('is-hover', 'is-dim');
    });

    if (!nextKey) return;
    svgNodes.forEach(node => {
      const key = node.getAttribute('data-series');
      if (!key) return;
      node.classList.add(key === nextKey ? 'is-hover' : 'is-dim');
    });
    legendNodes.forEach(node => {
      const key = node.getAttribute('data-series');
      if (!key) return;
      node.classList.add(key === nextKey ? 'is-hover' : 'is-dim');
    });
  },
  // SUBMODULE: chartPanel.positionTip @internal - positioniert Tooltip relativ zum Cursor
  positionTip(e) {
    if (!this.tip || !this.el) return;
    const hostRect = (this.el.querySelector(".content") || this.el).getBoundingClientRect();
    const x = e.clientX - hostRect.left;
    const y = e.clientY - hostRect.top;
    this.tip.style.left = `${x + 10}px`;
    this.tip.style.top  = `${y + 10}px`;
    if (this.tip.dataset.visible !== "1") {
      this.tip.style.display = "block";
      this.tip.style.opacity = "0";
      requestAnimationFrame(() => {
        if (!this.tip) return;
        this.tip.dataset.visible = "1";
        this.tip.style.opacity = "1";
      });
    } else {
      this.tip.dataset.visible = "1";
      this.tip.style.display = "block";
      this.tip.style.opacity = "1";
    }
  },
  // SUBMODULE: chartPanel.fillTipFromTarget @internal - generiert Tooltip-Inhalt inkl. Flags
  fillTipFromTarget(tgt) {
    if (!this.tip) return;
    this.setHoverSeries(tgt?.getAttribute("data-series") || null);
    const note = tgt.getAttribute("data-note") || "";
    const date = tgt.getAttribute("data-date") || "";
    const ctx  = tgt.getAttribute("data-ctx")  || "";
    const flags = (typeof this.flagsByDate?.get === 'function') ? this.flagsByDate.get(date) : null;
    const items = [];
    if (flags) {
      if (flags.training)         items.push("Training");
      if (flags.sick)             items.push("Krank");
      if (flags.low_intake)       items.push("< 2 L Wasser");
      if (flags.salt_high)        items.push("> 5 g Salz");
      if (flags.protein_high90)   items.push("Protein  90 g");
      if (flags.valsartan_missed) items.push("Valsartan vergessen");
      if (flags.forxiga_missed)   items.push("Forxiga vergessen");
      if (flags.nsar_taken)       items.push("NSAR genommen");
      if (!flags.valsartan_missed && !flags.forxiga_missed && !flags.nsar_taken && flags.meds) items.push("Medikamente");
    }

    const parts = [];
    const hdr = (date || ctx) ? `<div style="opacity:.85;margin-bottom:4px">${esc([date, ctx].filter(Boolean).join(" . "))}</div>` : "";
    if (hdr) parts.push(hdr);
    if (note) parts.push(`<div style="white-space:pre-wrap;margin-bottom:${items.length? '6' : '0'}px">${esc(note)}</div>`);
    if (items.length) {
      const lis = items.map(esc).map(t => `<li>${t}</li>`).join("");
      parts.push(`<div style="margin-top:${note? '0' : '2'}px"><strong>Flags:</strong><ul style="margin:4px 0 0 16px; padding:0">${lis}</ul></div>`);
    }
    if (!parts.length) { this.hideTip(); return; }
    this.tip.innerHTML = parts.join("");
    this.tip.dataset.visible = "1";
    this.tip.style.display = "block";
    this.tip.style.opacity = "1";
    if (this.live) this.live.textContent = `${date || ''} ${ctx || ''} ${note ? 'Notiz vorhanden. ' : ''}${items.length ? 'Flags: ' + items.join(', ') : ''}`.trim();
  },

  /* ---------- KPI-Felder + WHO-Ampellogik ---------- */
  // SUBMODULE: chartPanel.ensureKpiFields @internal - stellt KPI-Marker im UI bereit
  ensureKpiFields() {
    const box = $("#chartAverages");
    if (!box) return;
    const need = [
      { k: "sys",  label: "Durchschnitt Sys: -" },
      { k: "dia",  label: "Durchschnitt Dia: -" },
      { k: "map",  label: "Durchschnitt MAP: -" },
      { k: "bmi",  label: "BMI (letzter): -" },
      { k: "whtr", label: "WHtR (letzter): -" },
    ];
    need.forEach((n) => {
      if (!box.querySelector(`[data-k="${n.k}"]`)) {
        const span = document.createElement("span");
        span.setAttribute("data-k", n.k);
        span.textContent = n.label;
        box.appendChild(span);
      }
    });
  },

  // WHO-Farben
  // SUBMODULE: chartPanel.kpiColorBMI @internal - mappt BMI auf WHO-Farben
  kpiColorBMI(v) {
    if (v == null) return "#9aa3af";        // unknown
    if (v < 18.5) return "#60a5fa";         // untergew.
    if (v < 25)   return "#10b981";         // normal
    if (v < 30)   return "#f59e0b";         // uebergew.
    return "#ef4444";                        // adipoes
  },
  // SUBMODULE: chartPanel.kpiColorWHtR @internal - mappt WHtR auf WHO-Farben
  kpiColorWHtR(v) {
    if (v == null) return "#9aa3af";
    if (v < 0.5)   return "#10b981";        // ok
    if (v <= 0.6)  return "#f59e0b";        // erhoeht
    return "#ef4444";                        // hoch
  },

  // Ein Punkt pro KPI, korrekt eingefaerbt; saubere Separatoren
  // SUBMODULE: chartPanel.layoutKpis @internal - zeichnet KPI-Dots/Sep dynamisch
  layoutKpis() {
    const box = $("#chartAverages");
    if (!box) return;

    // 1) Alle alten Deko-Elemente entfernen (auch statische .sep aus dem HTML!)
    [...box.querySelectorAll(".kpi-dot, .kpi-sep, .sep")].forEach(n => n.remove());

    // 2) Sichtbare KPI-Spans ermitteln (display != "none")
    const items = [...box.querySelectorAll('[data-k]')].filter(el => el.style.display !== "none");

    // 3) Pro Item farbigen Punkt einsetzen + exakt einen Separator zwischen Items
    const makeDot = (color) => {
      const d = document.createElement("span");
      d.className = "kpi-dot";
      Object.assign(d.style, {
        display: "inline-block",
        width: "9px", height: "9px",
        borderRadius: "50%",
        margin: "0 8px 0 12px",
        background: color,
        verticalAlign: "middle",
        boxShadow: "0 0 4px rgba(0,0,0,.35)"
      });
      return d;
    };
    const makeSep = () => {
      const s = document.createElement("span");
      s.className = "kpi-sep";
      s.textContent = "*";
      Object.assign(s.style, {
        color: "#6b7280",
        margin: "0 10px",
        userSelect: "none"
      });
      return s;
    };

    items.forEach((el, idx) => {
      let color = "#9aa3af";
      const k = el.getAttribute("data-k");

      // Wert aus Text extrahieren (erste Zahl im Text)
      const m = el.textContent.match(/([\d.]+)/);
      const v = m ? parseFloat(m[1]) : null;

      if (k === "bmi") {
        color = this.kpiColorBMI(Number.isFinite(v) ? v : null);
      } else if (k === "whtr") {
        color = this.kpiColorWHtR(Number.isFinite(v) ? v : null);
      } else {
        // BP-KPIs neutral blau
        color = "#60a5fa";
      }

      el.before(makeDot(color));
      if (idx < items.length - 1) el.after(makeSep());
    });

    box.style.display = items.length ? "inline-flex" : "none";
    box.style.alignItems = "center";
  },

  // ----- Zeichnen -----
  // SUBMODULE: chartPanel.draw @extract-candidate - berechnet Scales, Flags und rendert SVG Layer
  async draw() {
    const t0 = performance.now?.() ?? Date.now();
if (!(await isLoggedIn())) {
  if (this.svg) this.svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Bitte anmelden</text>';
  if (this.legend) this.legend.innerHTML = "";
  return;
}
const metric = $("#metricSel")?.value || "bp";

    const data   = await this.getFiltered();

    // X-Basis
    const xsAll = data.map(e => e.ts ?? Date.parse(e.dateTime));
    let series = [];
    let barSeries = [];
    let X = xsAll;
    let pendingBodyHitsSvg = "";

    // KPI-Box
    const avgBox = $("#chartAverages");

    // Schwellen (nur BP)
    const TH_SYS = 130;
    const TH_DIA = 90;

    // Tagesstempel (UTC, 00:00)
    const toDayTs = (isoDate /* "YYYY-MM-DD" */) => {
      if (!isoDate) return NaN;
      const [y, m, d] = isoDate.split("-").map(Number);
      return Date.UTC(y, (m || 1) - 1, d || 1);
    };

    // Tageskommentare (erste Zeile)
    const notesByDate = new Map();
    for (const e of data) {
      const hasDayLike = e?.context === "Tag" || isWeightOnly(e);
      const txt = (e?.notes || "").trim();
      if (hasDayLike && txt) {
        const firstLine = txt.split(/\r?\n/)[0].trim();
        if (firstLine) notesByDate.set(e.date, firstLine);
      }
    }

    // Fuer BP benoetigen wir Meta je Punkt
    let meta = null;

    if (metric === "bp") {
      // Nur echte Messungen
      const mData = data.filter(
        e => (e.context === "Morgen" || e.context === "Abend") && (e.sys != null || e.dia != null)
      );

      // Meta
      meta = mData.map(e => ({
        date: e.date,
        ctx:  e.context,
        sys:  e.sys != null ? Number(e.sys) : null,
        dia:  e.dia != null ? Number(e.dia) : null,
        note: notesByDate.get(e.date) || "",
      }));

      // X auf Tage normalisieren
      const xsBP = mData.map(e => toDayTs(e.date));

      // Werte-Reihen (Index passend zu meta)
      const sysM = mData.map(e => (e.context === "Morgen" && e.sys != null) ? Number(e.sys) : null);
      const sysA = mData.map(e => (e.context === "Abend"  && e.sys != null) ? Number(e.sys) : null);
      const diaM = mData.map(e => (e.context === "Morgen" && e.dia != null) ? Number(e.dia) : null);
      const diaA = mData.map(e => (e.context === "Abend"  && e.dia != null) ? Number(e.dia) : null);

      // KPIs ( ueber alle Messungen)
      const avg = (arr) => {
        const v = arr.filter(x => x != null);
        return v.length ? v.reduce((p,c) => p + c, 0) / v.length : null;
      };
      const mapArr = mData.map(e =>
        e.sys != null && e.dia != null
          ? Number(e.dia) + (Number(e.sys) - Number(e.dia)) / 3
          : null
      );

      if (avgBox) {
        const avgSys = avg(mData.map(e => (e.sys != null ? Number(e.sys) : null)));
        const avgDia = avg(mData.map(e => (e.dia != null ? Number(e.dia) : null)));
        const avgMap = avg(mapArr);

        const f0 = (v) => (v == null ? "-" : Math.round(v).toString());

        // Zeige BP-KPIs, blende BMI/WHtR aus
        const sEl  = avgBox.querySelector('[data-k="sys"]');
        const dEl  = avgBox.querySelector('[data-k="dia"]');
        const mEl  = avgBox.querySelector('[data-k="map"]');
        const bmiEl  = avgBox.querySelector('[data-k="bmi"]');
        const whtrEl = avgBox.querySelector('[data-k="whtr"]');
        if (sEl)  { sEl.style.display  = ""; sEl.textContent  = "Durchschnitt Sys: " + f0(avgSys); }
        if (dEl)  { dEl.style.display  = ""; dEl.textContent  = "Durchschnitt Dia: " + f0(avgDia); }
        if (mEl)  { mEl.style.display  = ""; mEl.textContent  = "Durchschnitt MAP: " + f0(avgMap); }
        if (bmiEl)  bmiEl.style.display  = "none";
        if (whtrEl) whtrEl.style.display = "none";

        avgBox.style.display = (avgSys != null || avgDia != null || avgMap != null) ? "inline-flex" : "none";
        this.layoutKpis();
      }

      // Serien definieren
      series = [
        { key: "bp-sys-m", name: "Sys Morgens", values: sysM, color: "var(--chart-line-secondary)", type: "sys" },
        { key: "bp-sys-a", name: "Sys Abends",  values: sysA, color: "var(--chart-line-primary)", type: "sys" },
        { key: "bp-dia-m", name: "Dia Morgens", values: diaM, color: "var(--chart-line-tertiary, var(--chart-line-secondary))", type: "dia" },
        { key: "bp-dia-a", name: "Dia Abends",  values: diaA, color: "var(--chart-line-dia)", type: "dia" },
      ];

      X = xsBP; // wichtig
} else if (metric === "weight") {
  // Serien: Gewicht + Bauchumfang
  series = [
    {
      key: "body-weight",
      name: "Gewicht (kg)",
      values: data.map(e => e.weight != null ? Number(e.weight) : null),
      color: "var(--chart-line-weight)",
      type: "misc",
    },
    {
      key: "body-waist",
      name: "Bauchumfang (cm)",
      values: data.map(e => e.waist_cm != null ? Number(e.waist_cm) : null),
      color: "var(--chart-line-waist)",
      type: "misc",
    }
  ];

  // KPI-Leiste: BMI & WHtR aus dem LETZTEN verfuegbaren Wert
  if (avgBox) {
    // BP-KPIs ausblenden
    ["sys","dia","map"].forEach(k => {
      const el = avgBox.querySelector(`[data-k="${k}"]`);
      if (el) el.style.display = "none";
    });

    // letzten Weight/Bauchumfang finden (data ist aufsteigend sortiert)
    let lastWeight = null, lastWaist = null;
    for (let i = data.length - 1; i >= 0; i--) {
      if (lastWeight == null && data[i].weight   != null) lastWeight = Number(data[i].weight);
      if (lastWaist  == null && data[i].waist_cm != null) lastWaist  = Number(data[i].waist_cm);
      if (lastWeight != null && lastWaist != null) break;
    }

    const heightCm = await this.getHeightCm();
    const hM = heightCm > 0 ? heightCm / 100 : null;

    const bmi  = (lastWeight != null && hM)         ? lastWeight / (hM * hM) : null;
    const whtr = (lastWaist  != null && heightCm>0) ? lastWaist  / heightCm  : null;

    const bmiEl  = avgBox.querySelector('[data-k="bmi"]');
    const whtrEl = avgBox.querySelector('[data-k="whtr"]');

    if (bmiEl)  { bmiEl.textContent  = `BMI (letzter): ${bmi  == null ? "-" : bmi.toFixed(1)}`;  bmiEl.style.display  = ""; }
    if (whtrEl) { whtrEl.textContent = `WHtR (letzter): ${whtr == null ? "-" : whtr.toFixed(2)}`; whtrEl.style.display = ""; }

    avgBox.style.display = "inline-flex";
    this.layoutKpis();
  }

  const muscleKg = data.map(e => e.muscle_kg != null ? Number(e.muscle_kg) : null);
  const fatKg    = data.map(e => e.fat_kg    != null ? Number(e.fat_kg)    : null);
  barSeries = [
    { key: "body-muscle", name: "Muskelmasse (kg)", values: muscleKg, color: "var(--chart-bar-muscle)" },
    { key: "body-fat",    name: "Fettmasse (kg)",   values: fatKg,    color: "var(--chart-bar-fat)" },
  ];
}

  // --- Render-Prep ---
    if (this.svg) {
      this.svg.innerHTML = "";
      this.svg.classList.remove("chart-refresh");
      void this.svg.offsetWidth;
      this.svg.classList.add("chart-refresh");
    }
    if (this.legend) this.legend.innerHTML = "";
    if (!this.tipSticky) this.hideTip();

    // Wenn es Flags gibt, soll das Chart nicht fruehzeitig abbrechen
    const hasBarData = barSeries.some(s => s.values.some(v => v != null));
    const hasAnyFlagsData = (metric !== "weight") && Array.isArray(data) && data.some(e => !!(e?.training || e?.low_intake || e?.sick || e?.salt_high || e?.protein_high90 || e?.valsartan_missed || e?.forxiga_missed || e?.nsar_taken));
    const hasAny = series.some(s => s.values.some(v => v != null)) || hasBarData || hasAnyFlagsData;
    if (!hasAny) {
      if (this.svg) this.svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Keine darstellbaren Werte</text>';
      return;
    }

    // Dynamische Groesse
    const bbox = this.svg?.getBoundingClientRect?.() || { width: 640, height: 280 };
    const W = Math.max(300, Math.floor(bbox.width  || 640));
    const H = Math.max(200, Math.floor(bbox.height || 280));
    if (this.svg) this.svg.setAttribute("viewBox", `0 0 ${W} ${H}`);

    const PL = 48, PR = 16, PT = 12, PB = 28;
    const innerW = W - PL - PR, innerH = H - PT - PB;

    // === Flags -> X-Bereich erweitern (immer) + Lookup fuer Tooltip ===
    let flagTs = [];
    if (metric === "weight") {
      this.flagsByDate = new Map();
      this.hasFlagsForDate = () => false;
    } else {
      const dayFlagsTmp = new Map(); // date -> { training:bool, badCount:int, seen:{} }
      const flagsByDate = new Map(); // date -> detailed flags for tooltip
      for (const e of data) {
        if (!e?.date) continue;
        let rec = dayFlagsTmp.get(e.date);
        if (!rec) {
          rec = {
            training: false,
            badCount: 0,
            seen: { water:false, salt:false, protein:false, sick:false, meds:false },
          };
          dayFlagsTmp.set(e.date, rec);
        }
        if (e.training) rec.training = true;
        const meds = !!(e.valsartan_missed || e.forxiga_missed || e.nsar_taken);
        const flags = {
          water: !!e.low_intake,
          salt:  !!e.salt_high,
          protein: !!e.protein_high90,
          sick:  !!e.sick,
          meds,
        };
        for (const k of Object.keys(flags)) {
          if (flags[k] && !rec.seen[k]) { rec.seen[k] = true; rec.badCount++; }
        }

        // Tooltip-Detailflags sammeln
        let f = flagsByDate.get(e.date);
        if (!f) f = { training:false, sick:false, low_intake:false, salt_high:false, protein_high90:false, valsartan_missed:false, forxiga_missed:false, nsar_taken:false, meds:false };
        f.training = f.training || !!e.training;
        f.sick = f.sick || !!e.sick;
        f.low_intake = f.low_intake || !!e.low_intake;
        f.salt_high = f.salt_high || !!e.salt_high;
        f.protein_high90 = f.protein_high90 || !!e.protein_high90;
        f.valsartan_missed = f.valsartan_missed || !!e.valsartan_missed;
        f.forxiga_missed   = f.forxiga_missed   || !!e.forxiga_missed;
        f.nsar_taken       = f.nsar_taken       || !!e.nsar_taken;
        f.meds = f.meds || meds;
        flagsByDate.set(e.date, f);
      }
      flagTs = [...dayFlagsTmp.keys()].map(d => Date.parse(d + "T00:00:00Z"));
      this.flagsByDate = flagsByDate;
      this.hasFlagsForDate = (dayIso) => {
        if (!dayIso || !this.flagsByDate) return false;
        const f = this.flagsByDate.get(dayIso);
        if (!f) return false;
        return !!(f.training || f.sick || f.low_intake || f.salt_high || f.protein_high90 || f.valsartan_missed || f.forxiga_missed || f.nsar_taken || f.meds);
      };
    }

    // Skalen
    const xVals = X.filter(t => Number.isFinite(t));
    let xmin = Math.min(...xVals);
    let xmax = Math.max(...xVals);

    if (!Number.isFinite(xmin) || !Number.isFinite(xmax)) {
      // Fallback
      xmin = Date.now() - 7 * 864e5;
      xmax = Date.now();
    }

    // Union mit Flag-Tagen (immer)
    if (flagTs.length) {
      xmin = Math.min(xmin, Math.min(...flagTs));
      xmax = Math.max(xmax, Math.max(...flagTs));
    }

    // Padding (2%)
    const xPad = xmax > xmin ? (xmax - xmin) * 0.02 : 0;
    xmin -= xPad; xmax += xPad;

    const lineVals = series.flatMap(s => s.values.filter(v => v != null && Number.isFinite(v)));
    const barVals  = metric === "weight"
      ? []
      : barSeries.flatMap(s => s.values.filter(v => v != null && Number.isFinite(v)));
    let allY = [...lineVals, ...barVals];
    if (metric === "weight") {
      const weightValsOnly = series
        .filter(s => s.key === "body-weight" || s.key === "body-waist")
        .flatMap(s => s.values.filter(v => v != null && Number.isFinite(v)));
      allY = weightValsOnly.length ? weightValsOnly : [75, 110];
    }
    if (!allY.length) allY = [0];
    let yminRaw = Math.min(...allY);
    let ymaxRaw = Math.max(...allY);
    const ensureSpan = (min, max, minSpan) => {
      if (!Number.isFinite(min) || !Number.isFinite(max)) return [0, 1];
      if ((max - min) < minSpan) {
        const mid = (max + min) / 2;
        return [mid - minSpan / 2, mid + minSpan / 2];
      }
      return [min, max];
    };
    let yPad = 1;
    if (metric === "weight") {
      const baseMin = 75;
      const baseMax = 110;
      const belowBase = yminRaw < baseMin;
      const aboveBase = ymaxRaw > baseMax;
      if (!belowBase && !aboveBase) {
        yminRaw = baseMin;
        ymaxRaw = baseMax;
      } else {
        yminRaw = belowBase ? Math.min(yminRaw, baseMin) : baseMin;
        ymaxRaw = aboveBase ? Math.max(ymaxRaw, baseMax) : baseMax;
        [yminRaw, ymaxRaw] = ensureSpan(yminRaw, ymaxRaw, 6);
      }
      yPad = Math.max((ymaxRaw - yminRaw) * 0.08, 0.5);
    } else {
      [yminRaw, ymaxRaw] = ensureSpan(yminRaw, ymaxRaw, 2);
      yPad = Math.max((ymaxRaw - yminRaw) * 0.08, 1);
    }
    const y0 = yminRaw - yPad;
    const y1 = ymaxRaw + yPad;

    const x = (t) => PL + ((t - xmin) / Math.max(1, xmax - xmin)) * innerW;
    const y = (v) => PT + (1 - (v - y0) / Math.max(1, y1 - y0)) * innerH;

    const line = (x1,y1_,x2,y2,stroke,dash="") =>
      `<line x1="${x1}" y1="${y1_}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="1" ${dash ? `stroke-dasharray="${dash}"` : ""} />`;
    const text = (tx,ty,str,anchor="end") =>
      `<text x="${tx}" y="${ty}" fill="#9aa3af" font-size="11" text-anchor="${anchor}">${esc(str)}</text>`;

    // Zielbereiche (BP)
    if (this.svg) {
    }
    if (this.svg && metric === "bp") {
      const band = (min, max, cls) => {
        const top = Math.min(y(min), y(max));
        const height = Math.abs(y(max) - y(min));
        return `<rect class="goal-band ${cls}" x="${PL}" y="${top.toFixed(1)}" width="${innerW.toFixed(1)}" height="${height.toFixed(1)}" />`;
      };
      const goalLayers =
        band(110, 130, "goal-sys") +
        band(70, 85, "goal-dia");
      this.svg.insertAdjacentHTML("beforeend", goalLayers);
    }

    // Grid + Labels
    let grid = "";
    const ticks = 9;
    for (let i=0; i<=ticks; i++) {
      const vv = y0 + (i * (y1 - y0)) / ticks;
      const yy = y(vv);
      grid += line(PL, yy, W-PR, yy, "#2a3140");
      grid += text(PL - 6, yy + 4, Math.round(vv).toString());
    }
    // vertikale Wochenlinien + Datum
    const week = 7 * 24 * 3600 * 1000;
    let start = xmin - (xmin % week) + week;
    for (let t = start; t < xmax; t += week) {
      const xx = x(t);
      grid += line(xx, PT, xx, H - PB, "#1b1f28", "3 3");
      const d = new Date(t);
      const lbl = `${String(d.getDate()).padStart(2,"0")}.${String(d.getMonth()+1).padStart(2,"0")}.`;
      grid += text(xx, H - 8, lbl, "middle");
    }
    // Achsen
    grid += line(PL, PT, PL, H - PB, "#2b2f3a");
    grid += line(PL, H - PB, W - PR, H - PB, "#2b2f3a");

    // Schwellenlinien (BP)
    if (metric === "bp") {
      const ySys = y(TH_SYS);
      const yDia = y(TH_DIA);
      grid += line(PL, ySys, W - PR, ySys, "#ef4444", "6 4");
      grid += line(PL, yDia, W - PR, yDia, "#ef4444", "6 4");
grid += text(W - PR - 2, ySys + 4, "Sys 130", "end");
grid += text(W - PR - 2, yDia  + 4, "Dia 90",  "end");
    }

    if (this.svg) this.svg.insertAdjacentHTML("beforeend", grid);

    // === Flags Overlay (nur fuer BP) ===
    if (this.svg && metric !== "weight") {
      const dayFlags = new Map(); // date -> { training:bool, badCount:int, seen:{} }
      for (const e of data) {
        if (!e?.date) continue;
        let rec = dayFlags.get(e.date);
        if (!rec) {
          rec = { training:false, badCount:0, seen:{ water:false, salt:false, protein:false, sick:false, meds:false } };
          dayFlags.set(e.date, rec);
        }
        if (e.training) rec.training = true;
        const meds = !!(e.valsartan_missed || e.forxiga_missed || e.nsar_taken);
        const flags = {
          water: !!e.low_intake, salt: !!e.salt_high, protein: !!e.protein_high90, sick: !!e.sick, meds
        };
        for (const k of Object.keys(flags)) {
          if (flags[k] && !rec.seen[k]) { rec.seen[k] = true; rec.badCount++; }
        }
      }

      const toDayTsLocal = (iso) => Date.parse(iso + "T00:00:00Z");
      const flaggedDays = [...dayFlags.keys()]
        .filter(d => {
          const r = dayFlags.get(d);
          return r && (r.training || r.badCount > 0);
        })
        .sort();

      if (flaggedDays.length) {
        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.setAttribute("class","flags");
        g.setAttribute("pointer-events","auto");
        g.setAttribute("aria-hidden","true");

        const uniqDays = [...new Set([...flaggedDays.map(d => toDayTsLocal(d)), ...X.filter(Boolean)])].sort((a,b)=>a-b);
        const dayXs = uniqDays.map(t => x(t));
        const minStep = dayXs.length > 1 ? Math.min(...dayXs.slice(1).map((v,i)=>v - dayXs[i])) : innerW;
        const bandW   = Math.max(10, Math.floor(minStep * 0.45));
        const yBottom = PT + innerH;
        const slotH   = innerH / 6; // 1 Training + bis zu 5 Bad

        for (const d of flaggedDays) {
          const t = toDayTsLocal(d);
          const cx = x(t), xLeft = Math.round(cx - bandW/2);
          const rec = dayFlags.get(d);
          let used = 0;

          // Training (gruen)
          if (rec.training) {
            const yTop = Math.round(yBottom - (used + 1) * slotH);
            const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
            r.setAttribute("x", xLeft); r.setAttribute("y", yTop);
            r.setAttribute("width", bandW); r.setAttribute("height", Math.ceil(slotH));
            r.setAttribute("fill", "#10b981"); r.setAttribute("fill-opacity","0.22");
            r.setAttribute("stroke", "#fff");  r.setAttribute("stroke-opacity","0.06");
            r.setAttribute("shape-rendering","crispEdges");
            g.appendChild(r);
            used++;
          }
          // Bad-Flags (rot gestapelt)
          for (let i=0; i<rec.badCount; i++) {
            const yTop = Math.round(yBottom - (used + 1) * slotH);
            const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
            r.setAttribute("x", xLeft); r.setAttribute("y", yTop);
            r.setAttribute("width", bandW); r.setAttribute("height", Math.ceil(slotH));
            r.setAttribute("fill", "#ef4444"); r.setAttribute("fill-opacity","0.18");
            r.setAttribute("stroke", "#fff");  r.setAttribute("stroke-opacity","0.06");
            r.setAttribute("shape-rendering","crispEdges");
            g.appendChild(r);
            used++;
          }

          // Interaktiver Hit-Bereich pro Tag ueber alle Slots
          const totalSlots = used;
          if (totalSlots > 0) {
            const yTopAll = Math.round(yBottom - totalSlots * slotH);
            const hit = document.createElementNS("http://www.w3.org/2000/svg","rect");
            hit.setAttribute("x", xLeft); hit.setAttribute("y", yTopAll);
            hit.setAttribute("width", bandW); hit.setAttribute("height", Math.ceil(totalSlots * slotH));
            hit.setAttribute("fill", "transparent");
            hit.setAttribute("pointer-events", "all");
            hit.setAttribute("class", "flag-hit chart-hit");
            hit.setAttribute("data-date", d);
            hit.setAttribute("role", "button");
            hit.setAttribute("tabindex", "0");
            // ARIA-Label aus Flags ableiten
            try {
              const f = this.flagsByDate?.get?.(d);
              if (f) {
                const items = [];
                if (f.training) items.push("Training");
                if (f.sick) items.push("Krank");
                if (f.low_intake) items.push("< 2 L Wasser");
                if (f.salt_high) items.push("> 5 g Salz");
                if (f.protein_high90) items.push("Protein  90 g");
                if (f.valsartan_missed) items.push("Valsartan vergessen");
                if (f.forxiga_missed) items.push("Forxiga vergessen");
                if (f.nsar_taken) items.push("NSAR genommen");
                if (!f.valsartan_missed && !f.forxiga_missed && !f.nsar_taken && f.meds) items.push("Medikamente");
                if (items.length) hit.setAttribute("aria-label", `Flags: ${items.join(", ")}`);
              }
            } catch(_){}
            g.appendChild(hit);
          }
        }
        this.svg.appendChild(g); // hinter den Linien/Punkten
      }
    }

    // Koerper: Kompositionsbalken (Muskel/Fett) als hinterer Layer
    if (metric === "weight" && this.SHOW_BODY_COMP_BARS && this.svg) {
      const baseLineValue = 75;
      const baseline = y(baseLineValue);
      const muscleSeries = barSeries[0] || { values: [] };
      const fatSeries    = barSeries[1] || { values: [] };
      const entries = data.map((entry, idx) => {
        const ts = X[idx];
        if (!Number.isFinite(ts)) return null;
        const muscle = muscleSeries.values[idx];
        const fat = fatSeries.values[idx];
        if (muscle == null && fat == null) return null;
        return { ts, muscle, fat, src: data[idx], idx };
      }).filter(Boolean);

      if (entries.length) {
        const uniqTs = [...new Set(entries.map(e => e.ts))].sort((a,b)=>a-b);
        const dayXs = uniqTs.map(t => x(t));
        const baseStep = dayXs.length > 1
          ? Math.min(...dayXs.slice(1).map((v,i) => v - dayXs[i]))
          : innerW / Math.max(1, uniqTs.length);
        const groupWidth = Math.max(12, Math.min(36, Math.floor(baseStep * 0.5)));
        const gap = Math.max(2, Math.floor(groupWidth * 0.12));
        const barWidth = Math.max(4, Math.floor((groupWidth - gap) / 2));

        if (barWidth > 0 && Number.isFinite(baseline)) {
          const formatKg = (val) => {
            if (val == null) return null;
            const num = Number(val);
            if (!Number.isFinite(num)) return null;
            return (typeof fmtNum === "function" ? fmtNum(num, 1) : num.toFixed(1));
          };
          let barsSvg = '<g class="body-bars" aria-hidden="true">';
          let hitsSvg = '<g class="body-bar-hits">';
          for (const { ts, muscle, fat, src } of entries) {
            const center = x(ts);
            const start = center - groupWidth / 2;
            const raw = src || {};
            const dayIso = raw?.date || (raw?.dateTime ? raw.dateTime.slice(0, 10) : new Date(ts).toISOString().slice(0, 10));
            const weightVal = formatKg(raw?.weight);
            const muscleNum = muscle != null ? Number(muscle) : null;
            const fatNum = fat != null ? Number(fat) : null;
            const hasMuscle = muscleNum != null && Number.isFinite(muscleNum);
            const hasFat = fatNum != null && Number.isFinite(fatNum);
            let muscleX = start;
            let fatX = start + barWidth + gap;
            if (hasMuscle && !hasFat) {
              muscleX = center - barWidth / 2;
            }
            if (!hasMuscle && hasFat) {
              fatX = center - barWidth / 2;
            }

            if (hasMuscle) {
              const yVal = y(baseLineValue + muscleNum);
              if (Number.isFinite(yVal)) {
                const h = Math.abs(baseline - yVal);
                if (h > 0.5) {
                  const top = Math.min(baseline, yVal);
                  barsSvg += `<rect class="body-bar" data-series="body-muscle" x="${muscleX.toFixed(1)}" y="${top.toFixed(1)}" width="${barWidth}" height="${h.toFixed(1)}" fill="var(--chart-bar-muscle)" fill-opacity="0.55" stroke="none" pointer-events="none" />`;
                  let hitHeight = Math.max(h, 14);
                  let hitTop = Math.min(top, baseline - hitHeight);
                  if (hitTop < PT) {
                    hitTop = PT;
                    hitHeight = Math.max(4, baseline - hitTop);
                  }
                  if (hitHeight > 0.5) {
                    const muscleVal = formatKg(muscleNum);
                    const parts = [];
                    if (muscleVal) parts.push(`Muskelmasse: ${muscleVal} kg`);
                    if (weightVal) parts.push(`Gewicht: ${weightVal} kg`);
                    const note = parts.join('\n');
                    const aria = `${dayIso || ''} Muskel ${muscleVal ? muscleVal + ' kg' : ''}`.trim();
                    hitsSvg += `<rect class="body-hit chart-hit" x="${muscleX.toFixed(1)}" y="${hitTop.toFixed(1)}" width="${barWidth}" height="${hitHeight.toFixed(1)}" fill="transparent" pointer-events="all"
                      data-series="body-muscle" data-date="${esc(dayIso || '')}" data-ctx="Muskel" data-note="${esc(note)}"
                      aria-label="${esc(aria)}" title="${esc(aria)}" role="button" tabindex="0"></rect>`;
                  }
                }
              }
            }

            if (hasFat) {
              const yVal = y(baseLineValue + fatNum);
              if (Number.isFinite(yVal)) {
                const h = Math.abs(baseline - yVal);
                if (h > 0.5) {
                  const top = Math.min(baseline, yVal);
                  barsSvg += `<rect class="body-bar" data-series="body-fat" x="${fatX.toFixed(1)}" y="${top.toFixed(1)}" width="${barWidth}" height="${h.toFixed(1)}" fill="var(--chart-bar-fat)" fill-opacity="0.55" stroke="none" pointer-events="none" />`;
                  let hitHeight = Math.max(h, 14);
                  let hitTop = Math.min(top, baseline - hitHeight);
                  if (hitTop < PT) {
                    hitTop = PT;
                    hitHeight = Math.max(4, baseline - hitTop);
                  }
                  if (hitHeight > 0.5) {
                    const fatVal = formatKg(fatNum);
                    const parts = [];
                    if (fatVal) parts.push(`Fettmasse: ${fatVal} kg`);
                    if (weightVal) parts.push(`Gewicht: ${weightVal} kg`);
                    const note = parts.join('\n');
                    const aria = `${dayIso || ''} Fett ${fatVal ? fatVal + ' kg' : ''}`.trim();
                    hitsSvg += `<rect class="body-hit chart-hit" x="${fatX.toFixed(1)}" y="${hitTop.toFixed(1)}" width="${barWidth}" height="${hitHeight.toFixed(1)}" fill="transparent" pointer-events="all"
                      data-series="body-fat" data-date="${esc(dayIso || '')}" data-ctx="Fett" data-note="${esc(note)}"
                      aria-label="${esc(aria)}" title="${esc(aria)}" role="button" tabindex="0"></rect>`;
                  }
                }
              }
            }
          }
          barsSvg += '</g>';
          hitsSvg += '</g>';
          this.svg.insertAdjacentHTML("beforeend", barsSvg);
          pendingBodyHitsSvg = hitsSvg;
        }
      }
    }

    // Linien + Punkte
const isFiniteTs = (t) => Number.isFinite(t);

const mkPath = (seriesItem) => {
  const { values = [], color = "#fff", key } = seriesItem || {};
  let d = "";
  values.forEach((v,i) => {
    if (v == null || !isFiniteTs(X[i])) return; // statt !X[i]
    d += (d === "" ? "M" : "L") + `${x(X[i]).toFixed(1)},${y(v).toFixed(1)} `;
  });
  const seriesAttr = key ? ` data-series="${esc(key)}"` : "";
  return `<path${seriesAttr} d="${d}" fill="none" stroke="${color}" stroke-width="2.2" pointer-events="none" />`;
};

const mkDots = (seriesItem) => {
  const { values = [], color = "#fff", type, key } = seriesItem || {};
  const kind = (type === "sys" || type === "dia") ? type : "misc";
  let out = "";
  values.forEach((v, i) => {
    if (v == null || !Number.isFinite(X[i])) return;
    const cx = x(X[i]).toFixed(1);
    const cy = y(v).toFixed(1);

    // Tooltip-Infos (nur bei BP vorhanden)
    const m = (kind === "sys" || kind === "dia") ? (meta?.[i] || {}) : {};
    const date = (m.date || (data?.[i]?.date || ""));
    const ctx  = (m.ctx  || (kind === "misc" ? "Tag" : ""));
    const note = (m.note || "");
    const labelBase = (kind === "sys" || kind === "dia") ? `${kind.toUpperCase()} ${v}` : `${v}`;
    const aria = `${date} ${ctx} ${labelBase}`.trim();

    const seriesAttr = key ? ` data-series="${esc(key)}"` : "";
    out += `<circle class="pt" cx="${cx}" cy="${cy}" r="2.6" fill="${color}"
                data-kind="${esc(kind)}" data-val="${v}"
                data-date="${esc(date)}" data-ctx="${esc(ctx)}"
               data-note="${esc(note)}"${seriesAttr} tabindex="0" role="button" aria-label="${esc(aria)}" title="${esc(aria)}"
               stroke="rgba(0,0,0,0)" stroke-width="12" pointer-events="stroke" />`;
  });
  return out;
};

const mkAlertDots = (seriesItem) => {
  if (metric !== "bp") return "";
  const isSys = seriesItem.type === "sys";
  const thr   = isSys ? TH_SYS : TH_DIA;
  const kind  = isSys ? "sys" : "dia";
  let out = "";
  seriesItem.values.forEach((v, i) => {
    if (v == null || !isFiniteTs(X[i])) return;
    if (v > thr) {
      const cx = x(X[i]).toFixed(1), cy = y(v).toFixed(1);
      const m = meta?.[i] || {};
      const seriesAttr = seriesItem?.key ? ` data-series="${esc(seriesItem.key)}"` : "";
      out += `<circle class="pt" cx="${cx}" cy="${cy}" r="5.2" fill="#ef4444" stroke="#000" stroke-width="0.8"
               data-kind="${kind}" data-val="${v}"
               data-date="${esc(m.date || "")}" data-ctx="${esc(m.ctx || "")}"
               data-note="${esc(m.note || "")}"${seriesAttr} />`;
    }
  });
  return out;
};

    // Zeichnen
    series.forEach((s) => {
      if (!this.svg) return;
      this.svg.insertAdjacentHTML("beforeend", mkPath(s));
      this.svg.insertAdjacentHTML("beforeend", mkDots(s));
      if (metric === "bp") {
        this.svg.insertAdjacentHTML("beforeend", mkAlertDots(s));
      }
      // Legende
      if (this.legend) {
        const wrap = document.createElement("span");
        wrap.style.display = "inline-flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        if (s.key) wrap.setAttribute("data-series", s.key);
        const dot = Object.assign(document.createElement("span"), { className: "dot" });
        dot.style.background = s.color;
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        const label = document.createElement("span");
        label.textContent = s.name;
        wrap.append(dot, label);
        this.legend.appendChild(wrap);
      }
    });

    if (pendingBodyHitsSvg && this.svg) {
      this.svg.insertAdjacentHTML("beforeend", pendingBodyHitsSvg);
    }

    if (metric === "weight" && this.legend) {
      barSeries.forEach((s) => {
        if (!s.values.some(v => v != null)) return;
        const wrap = document.createElement("span");
        wrap.style.display = "inline-flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        if (s.key) wrap.setAttribute("data-series", s.key);
        const dot = Object.assign(document.createElement("span"), { className: "dot" });
        dot.style.background = s.color;
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        const label = document.createElement("span");
        label.textContent = s.name;
        wrap.append(dot, label);
        this.legend.appendChild(wrap);
      });
    }

    if (this.tipSticky) { this.tipSticky = false; this.hideTip(); }

    const sPerf = (perfStats.add?.("drawChart", (performance.now?.() ?? Date.now()) - t0), perfStats.snap?.("drawChart")) || {p50:0,p90:0,p95:0,p99:0,count:0};
    if (sPerf && typeof sPerf.count === 'number' && (sPerf.count % 25 === 0)) {
      diag.add?.(`[perf] drawChart p50=${sPerf.p50|0}ms p90=${sPerf.p90|0}ms p95=${sPerf.p95|0}ms p99=${sPerf.p99|0}ms (n=${sPerf.count})`);
    }
  },
};

/** END MODULE */

/* --- Button-Flash (nur Platzhalter, wie gehabt) --- */


function flashButtonOk(btn, successHtml){
  if (!btn) return;
  const base = btn.dataset.label || btn.innerHTML;
  btn.dataset.label = base;
  btn.disabled = true;
  btn.innerHTML = successHtml;
  const panel = btn.closest('.card, .card-nested');
  if (panel){
    panel.classList.remove('panel-flash');
    void panel.offsetWidth;
    panel.classList.add('panel-flash');
    setTimeout(()=>panel.classList.remove('panel-flash'), 480);
  }
  setTimeout(()=>{
    btn.innerHTML = btn.dataset.label;
    btn.disabled = false;
  }, 1200);
}

/** MODULE: UI / ROUTING / VIEWS - Navigation (Tabs/Resume/Focus)
 * intent: Tab- und Overlay-Routing, Resume-Listener, Fokusreparatur
 * exports: setTab, bindTabs
 * notes: Fortsetzung der Navigations-Hooks nach dem Chart-Block; keine DOM-Aenderungen
 */
/* ===== Tabs / Segments ===== */
// @refactor: moved to assets/js/ui-tabs.js (setTab, bindTabs, bindHeaderShadow)
/** END MODULE */

/** MODULE: CAPTURE (Intake)
 * intent: Panel hotkeys, save/reset flows und flag handling (Fortsetzung)
 * contracts: interagiert mit DATA ACCESS.saveBlock, UI.requestUiRefresh, AUTH Guards
 * exports: setProteinHigh, setTraining, setLowIntake, setSaltHigh
 * notes: Fortsetzung fuer Panel-Operationen (Hotkeys/Speichern)
 */

/* ===== Save flows ===== */
// Replace sugar toggle with protein (runtime migration for legacy layouts)
// Migration entfernt: Markup nutzt direkt #proteinHighToggle
// SUBMODULE: captureFlagToggles @internal - manages capture flag buttons and state cache
function setProteinHigh(on){
  proteinHigh = !!on;
  setToggle($("#proteinHighToggle"), proteinHigh, "&#x1F969; Protein >= 90 g (aktiv)", "&#x1F969; Protein >= 90 g");
}
let trainingActive=false, lowIntakeActive=false, sickActive=false, valsartanMissed=false, forxigaMissed=false, nsarTaken=false,
saltHigh=false, proteinHigh=false;
function setToggle(el, on, activeText, baseText){
el = el || null;
if (!el) return;
el.classList.toggle("active", !!on);
el.setAttribute("aria-pressed", on ? "true" : "false");
el.innerHTML = on ? activeText : baseText;
}
function setTraining(on){ trainingActive=!!on; setToggle($("#trainingToggle"), trainingActive, "&#x1F3CB;&#xFE0F; Training heute (aktiv)", "&#x1F3CB;&#xFE0F; Training heute"); }
function setLowIntake(on){ lowIntakeActive=!!on; setToggle($("#lowIntakeToggle"), lowIntakeActive, "&#x1F4A7; < 2 L (aktiv)", "&#x1F4A7; < 2 L getrunken"); }
function setSaltHigh(on){ saltHigh = !!on; setToggle($("#saltHighToggle"), saltHigh, "&#x1F9C2; > 5 g Salz (aktiv)", "&#x1F9C2; > 5 g Salz"); }
// Kommentar-Pflicht fuer BP: Grenzwerte markieren
/** END MODULE */

/** MODULE: BP (Blood Pressure)
 * intent: BP-spezifische Validierungen, Kontextumschaltung und Panel-Reset
 * contracts: arbeitet mit CAPTURE UI, DATA ACCESS.saveBlock, CHARTS-Schwellenwerten
 * exports: requiresBpComment, updateBpCommentWarnings, resetBpPanel
 * notes: UI-Validierung strikt halten; keine DOM-Umbauten
 */
// SUBMODULE: requiresBpComment @internal - enforces comment when vitals exceed thresholds
function requiresBpComment(which){
  const sys = Number($(bpSelector('sys', which)).value);
  const dia = Number($(`#dia${which}`).value);
  const el = document.getElementById(which === "M" ? "bpCommentM" : "bpCommentA");
  const comment = (el?.value || "").trim();
  return ((sys > 130) || (dia > 90)) && !comment;
}
// SUBMODULE: updateBpCommentWarnings @internal - highlights comment fields requiring input
function updateBpCommentWarnings(){
  ['M','A'].forEach(which => {
    const el = document.getElementById(which === "M" ? "bpCommentM" : "bpCommentA");
    if (!el) return;
    const needs = requiresBpComment(which);
    el.style.outline = needs ? "2px solid var(--danger)" : "";
    if (needs) el.setAttribute("aria-invalid","true");
    else el.removeAttribute("aria-invalid");
  });
}

/* === Panel Reset Helpers (V1.5.7) === */
// SUBMODULE: bpFieldId @internal - maps BP field ids for capture contexts
function bpFieldId(base, ctx){
  if (base === 'sys' && ctx === 'M') return 'captureAmount';
  return base + ctx;
}

// SUBMODULE: bpSelector @internal - resolves selector for BP inputs
function bpSelector(base, ctx){
  return base === 'sys' && ctx === 'M' ? '#captureAmount' : `#${base}${ctx}`;
}

// SUBMODULE: resetBpPanel @internal - clears BP inputs per context
function resetBpPanel(which, opts = {}) {
  const { focus = true } = opts;
  const ctx = which === 'A' ? 'A' : 'M';
  ['sys','dia','pulse','bpComment'].forEach(id => {
    const el = document.getElementById(bpFieldId(id, ctx));
    if (el) el.value = '';
  });
  try { updateBpCommentWarnings?.(); } catch(_){}
  if (focus) {
    const target = document.getElementById(bpFieldId('sys', ctx));
    if (target) target.focus();
  }
}
/** END MODULE */

/** MODULE: CAPTURE (Intake)
 * intent: Panel Resets, Flag-Hooks und Tastatur-Shortcuts (Fortsetzung)
 * contracts: verbindet BP-/BODY-Panels, nutzt CAPTURE State Toggles
 * exports: resetBodyPanel, resetFlagsPanel, resetCapturePanels, addCapturePanelKeys, setSick, setValsartanMiss, setForxigaMiss, setNsar
 * notes: Fortsetzung fuer Capture-Hilfsfunktionen (Resets/Toggles)
 */
// SUBMODULE: resetBodyPanel @internal - leert Body-Eingaben und stellt optional den Fokus wieder her
function resetBodyPanel(opts = {}) {
  const { focus = true } = opts;
  const weightEl = document.getElementById('weightDay');
  const waistEl = document.getElementById('input-waist-cm');
  const fatEl = document.getElementById('fatPctDay');
  const muscleEl = document.getElementById('musclePctDay');
  if (weightEl) weightEl.value = '';
  if (waistEl) waistEl.value = '';
  if (fatEl) { fatEl.value = ''; clearFieldError(fatEl); }
  if (muscleEl) { muscleEl.value = ''; clearFieldError(muscleEl); }
  if (focus && weightEl) weightEl.focus();
}
// SUBMODULE: resetFlagsPanel @internal - setzt Flag-Toggles und Kommentar auf Ausgangszustand
function resetFlagsPanel(opts = {}) {
  const { focus = true } = opts;
  try {
    setTraining(false);
    setLowIntake(false);
    setSick(false);
    setValsartanMiss(false);
    setForxigaMiss(false);
    setNsar(false);
    setSaltHigh(false);
    if (typeof setProteinHigh === 'function') setProteinHigh(false);
  } catch(_){ }
  const commentEl = document.getElementById('flagsComment');
  if (commentEl) commentEl.value = '';
  if (focus && commentEl) commentEl.focus();
}
// SUBMODULE: resetCapturePanels @internal - kombiniert Panel-Resets (BP/Body/Flags) und setzt Kontext zurueck
function resetCapturePanels(opts = {}) {
  const { focus = true } = opts;
  resetBpPanel('M', { focus: false });
  resetBpPanel('A', { focus: false });
  resetBodyPanel({ focus: false });
  resetFlagsPanel({ focus: false });
  const ctxSel = document.getElementById('bpContextSel');
  if (ctxSel) ctxSel.value = 'M';
  document.querySelectorAll('.bp-pane').forEach(pane => {
    pane.classList.toggle('active', pane.dataset.context === 'M');
  });
  try { updateBpCommentWarnings?.(); } catch(_){ }
  if (focus) {
    const first = document.getElementById('captureAmount');
    if (first) first.focus();
  }
}
// SUBMODULE: addCapturePanelKeys @internal - registriert Tastaturkuerzel fuer Save-/Reset-Flows
function addCapturePanelKeys(){
  const bind = (selectors, onEnter, onEsc) => {
    document.querySelectorAll(selectors).forEach(el => {
      el.addEventListener('keydown', e => {
        if (e.key === 'Enter') { e.preventDefault(); onEnter?.(); }
        if (e.key === 'Escape') { e.preventDefault(); onEsc?.(); }
      });
    });
  };
  bind('#captureAmount, #diaM, #pulseM, #bpCommentM', () => document.getElementById('saveBpPanelBtn')?.click(), () => resetBpPanel('M'));
  bind('#sysA, #diaA, #pulseA, #bpCommentA', () => document.getElementById('saveBpPanelBtn')?.click(), () => resetBpPanel('A'));
  bind('#weightDay, #input-waist-cm, #fatPctDay, #musclePctDay', () => document.getElementById('saveBodyPanelBtn')?.click(), () => resetBodyPanel());
  bind('#flagsComment', () => document.getElementById('saveFlagsPanelBtn')?.click(), () => resetFlagsPanel());
}
// SUBMODULE: setSick @internal - setzt Krank-Flag und sperrt Forxiga-Toggle bei Bedarf
function setSick(on){
sickActive=!!on; setToggle($("#sickToggle"), sickActive, "&#x1F912; Krank (Forxiga pausiert) (aktiv)", "&#x1F912; Krank (Forxiga pausiert)");
if(sickActive){ setForxigaMiss(true); $("#forxigaMissToggle").disabled=true; $("#forxigaMissToggle").style.opacity=0.6; }
else { $("#forxigaMissToggle").disabled=false; $("#forxigaMissToggle").style.opacity=1; }
}
// SUBMODULE: setValsartanMiss @internal - pflegt Valsartan-vergessen Status und UI-Text
function setValsartanMiss(on){ valsartanMissed=!!on; setToggle($("#valsartanMissToggle"), valsartanMissed, "&#x1F48A; Valsartan vergessen (aktiv)", "&#x1F48A; Valsartan vergessen"); }
// SUBMODULE: setForxigaMiss @internal - pflegt Forxiga-vergessen Status inkl. Label
function setForxigaMiss(on){ forxigaMissed=!!on; setToggle($("#forxigaMissToggle"), forxigaMissed, "&#x23F0; Forxiga vergessen (aktiv)", "&#x23F0; Forxiga vergessen"); }
// SUBMODULE: setNsar @internal - pflegt NSAR-Flag und Screenreader-Label
function setNsar(on){ nsarTaken=!!on; setToggle($("#nsarToggle"), nsarTaken, "&#x1F489; NSAR genommen (aktiv)", "&#x1F489; NSAR genommen"); }

/** END MODULE */

/** MODULE: BP (Blood Pressure)
 * intent: verarbeitet Blutdruck-Erfassung, Validation und Persistierung
 * contracts: interagiert mit DATA ACCESS.addEntry/syncWebhook, CAPTURE Toggles, UI-Warnungen
 * exports: saveBlock, appendNote, allocateNoteTimestamp
 * notes: Validierungslogik unveraendert dokumentieren; nur Kommentare
 */
// SUBMODULE: blockHasData @internal - detects if BP panel has any input before saving
function blockHasData(which){
  const getVal = (sel) => document.querySelector(sel)?.value?.trim();
  const sys = getVal(bpSelector('sys', which));
  const dia = getVal(`#dia${which}`);
  const pulse = getVal(`#pulse${which}`);
  const commentEl = document.getElementById(which === "M" ? "bpCommentM" : "bpCommentA");
  const comment = (commentEl?.value || "").trim();
  return !!(sys || dia || pulse || comment);
}
// SUBMODULE: saveBlock @internal - persists BP measurements and optional comments
async function saveBlock(contextLabel, which, includeWeight=false, force=false){
const date = $("#date").value || todayStr();
const time = which === 'M' ? '07:00' : '22:00';

const sys   = $(bpSelector('sys', which)).value   ? toNumDE($(bpSelector('sys', which)).value)   : null;
const dia   = $(`#dia${which}`).value   ? toNumDE($(`#dia${which}`).value)   : null;
const pulse = $(`#pulse${which}`).value ? toNumDE($(`#pulse${which}`).value) : null;

const commentEl = document.getElementById(which === 'M' ? 'bpCommentM' : 'bpCommentA');
const comment = (commentEl?.value || '').trim();

const hasAny = (sys != null) || (dia != null) || (pulse != null);
const hasComment = comment.length > 0;

if (!force && !hasAny && !hasComment) return false;

if (hasAny){
  if ((sys != null && dia == null) || (dia != null && sys == null)){
    uiError('Bitte beide Blutdruck-Werte (Sys und Dia) eingeben.');
    return false;
  }
  if (pulse != null && (sys == null || dia == null)){
    uiError('Puls kann nur mit Sys und Dia zusammen gespeichert werden.');
    return false;
  }

  const currentISO = new Date(date + "T" + time).toISOString();
  const ts = new Date(date + "T" + time).getTime();

  const entry = {
    date, time, dateTime: currentISO, ts,
    context: contextLabel,
    sys, dia, pulse,
    weight: null,
    map: (sys!=null && dia!=null) ? calcMAP(sys, dia) : null,
    notes: '',
    training: false,
    low_intake: false,
    sick: false,
    valsartan_missed: false,
    forxiga_missed: false,
    nsar_taken: false,
    salt_high: false,
    protein_high90: false
  };

  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
}

if (hasComment){
  try {
    await appendNote(date, which === 'M' ? '[Morgens] ' : '[Abends] ', comment);
    if (commentEl) commentEl.value = '';
    updateBpCommentWarnings();
  } catch(err) {
    diag.add?.('BP-Kommentar Fehler: ' + (err?.message || err));
  }
}

return hasAny || hasComment;
}

// SUBMODULE: baseEntry @internal - composes canonical intake/bp entry skeleton
function baseEntry(date, time, contextLabel){
const iso = new Date(date + "T" + time).toISOString();
const ts = new Date(date + "T" + time).getTime();
return {
date, time, dateTime: iso, ts,
context: contextLabel, 
sys: null, dia: null, pulse: null, weight: null, map: null,
notes: ($("#notesDay")?.value || "").trim(),
training: trainingActive,
low_intake: lowIntakeActive,
sick: sickActive,
valsartan_missed: valsartanMissed,
forxiga_missed: forxigaMissed,
nsar_taken: nsarTaken,
salt_high: saltHigh,
protein_high90: proteinHigh
};
}

// SUBMODULE: appendNote @internal - stores supplemental note entries for BP/flags
async function appendNote(date, prefix, text){
  const trimmed = (text || '').trim();
  if (!trimmed) return;
  const stamp = allocateNoteTimestamp(date);
  const entry = baseEntry(date, stamp.time, 'Tag');
  entry.dateTime = stamp.iso;
  entry.ts = stamp.ts;
  entry.notes = prefix + trimmed;
  entry.training = false;
  entry.low_intake = false;
  entry.sick = false;
  entry.valsartan_missed = false;
  entry.forxiga_missed = false;
  entry.nsar_taken = false;
  entry.salt_high = false;
  entry.protein_high90 = false;
  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
}

// SUBMODULE: allocateNoteTimestamp @internal - generates staggered timestamps for notes
function allocateNoteTimestamp(date){
  const base = new Date(date + "T22:30:00");
  const now = Date.now();
  const minuteOffset = now % 60;
  const secondOffset = Math.floor(now / 1000) % 60;
  base.setMinutes(base.getMinutes() + minuteOffset);
  base.setSeconds(base.getSeconds() + secondOffset);
  const iso = base.toISOString();
  return { iso, ts: base.getTime(), time: iso.slice(11,16) };
}

// SUBMODULE: saveFlagsCommentNote @internal - persists capture flags note
async function saveFlagsCommentNote(date, text){
  const trimmed = (text || '').trim();
  if (!trimmed) return false;
  await appendNote(date, '[Flags] ', trimmed);
  return true;
}

/** END MODULE */

/** MODULE: BODY (Koerperwerte)
 * intent: verarbeitet Tageszusammenfassung, Flags und Body-Werte Validierung
 * contracts: nutzt DATA ACCESS.saveDaySummary/saveFlagsCommentNote, CAPTURE Toggles
 * exports: saveDaySummary, saveFlagsCommentNote
 * notes: Body- und Flag-Eintraege konsistent dokumentieren; nur Kommentare
 */
// SUBMODULE: saveDaySummary @internal - validates and saves body/flags daily summary
async function saveDaySummary(options = {}){
  const { includeBody = true, includeFlags = true, includeFlagsComment = true } = options;
  const date = $("#date")?.value || todayStr();
  const time = "12:00";

  const entry = baseEntry(date, time, "Tag");
  let validationFailed = false;

  const notesRaw = ($("#notesDay")?.value || "").trim();
  if (includeBody){
    entry.notes = notesRaw;
    const w = $("#weightDay")?.value?.trim();
    entry.weight = w ? Number((w||"").replace(',', '.')) : null;
    const waistRaw = $("#input-waist-cm")?.value?.trim();
    entry.waist_cm = waistRaw ? toNumDE(waistRaw) : null;

    const fatPctEl = document.getElementById('fatPctDay');
    const musclePctEl = document.getElementById('musclePctDay');
    const parsePct = (el, label) => {
      if (!el) return null;
      const raw = (el.value || '').trim();
      if (!raw){
        clearFieldError(el);
        return null;
      }
      const pct = toNumDE(raw);
      if (!Number.isFinite(pct) || pct < 0 || pct > 100){
        setFieldError(el);
        uiError(`Bitte gueltigen Wert fuer ${label} (0-100 %) eingeben.`);
        if (!validationFailed) el.focus();
        validationFailed = true;
        return null;
      }
      clearFieldError(el);
      return pct;
    };

    const fatPct = parsePct(fatPctEl, 'Fett');
    const musclePct = parsePct(musclePctEl, 'Muskel');
    entry.fat_pct = fatPct;
    entry.muscle_pct = musclePct;
  } else {
    entry.notes = '';
    entry.weight = null;
    entry.waist_cm = null;
    entry.fat_pct = null;
    entry.muscle_pct = null;
    clearFieldError(document.getElementById('fatPctDay'));
    clearFieldError(document.getElementById('musclePctDay'));
  }

  if (validationFailed) return false;

  if (includeFlags){
    entry.training = trainingActive;
    entry.low_intake = lowIntakeActive;
  entry.sick = sickActive;
  entry.valsartan_missed = valsartanMissed;
  entry.forxiga_missed = forxigaMissed;
  entry.nsar_taken = nsarTaken;
  entry.salt_high = saltHigh;
  entry.protein_high90 = proteinHigh;
} else {
  entry.training = null;
  entry.low_intake = null;
  entry.sick = null;
  entry.valsartan_missed = null;
  entry.forxiga_missed = null;
  entry.nsar_taken = null;
  entry.salt_high = null;
  entry.protein_high90 = null;
}

  const flagsComment = includeFlagsComment ? ($("#flagsComment")?.value || "").trim() : "";
let saved = false;

const hasBodyContent = includeBody && ((entry.weight != null) || (entry.waist_cm != null) || !!entry.notes);
const hasFlagContent = includeFlags && !!(trainingActive || lowIntakeActive || sickActive ||
  valsartanMissed || forxigaMissed || nsarTaken ||
  saltHigh || proteinHigh);

if (hasBodyContent || hasFlagContent){
  const localId = await addEntry(entry);
  await syncWebhook(entry, localId);
  saved = true;
}

if (includeFlagsComment && flagsComment){
  const savedNote = await saveFlagsCommentNote(date, flagsComment);
  if (savedNote){
    const el = document.getElementById('flagsComment');
    if (el) el.value = '';
    diag.add('Flags-Kommentar gespeichert');
    saved = true;
  }
}

return saved;
}

/** END MODULE */

/** MODULE: DATA ACCESS (Auth Helpers)
 * intent: Hilfsfunktionen fuer Netzwerk-Retries und Auth-gebundene Fetches
 * contracts: wird von BP/BODY/APPOINTMENTS Save-Flows genutzt, haengt von AUTH.ensureSupabaseClient ab
 * exports: withRetry, fetchWithAuth, syncWebhook
 * notes: Fortsetzung; reine Kommentare
 */
// @refactor: moved to assets/js/supabase.js (withRetry, fetchWithAuth, syncWebhook)

/** END MODULE */

/* ===== App-Lock (Passkey + PIN) ===== */
/* Doctor-Lock-Logik lebt in SupabaseAPI.guard (requireDoctorUnlock/bindAppLockButtons). */
let __doctorScrollSnapshot = { top: 0, ratio: 0 };

/* ===== Main ===== */
async function main(){
  if (document.readyState === 'loading') {
    await new Promise((resolve) => {
      document.addEventListener('DOMContentLoaded', resolve, { once: true });
    });
  }
  if (!(await ensureModulesReady())) {
    return;
  }
  diag.init();
  helpPanel?.init?.();
  await initDB();
  window.AppModules?.uiLayout?.updateStickyOffsets?.();
  bindHeaderShadow();
  try {
    await getConf("webhookUrl");
    await getConf("webhookKey");
  } catch (_) {}
  // Dep: chart panel and refresh flows expect Supabase client to exist beforehand.
  await ensureSupabaseClient();
  chartPanel.init();
  bindTabs();
const todayIso = todayStr();
$("#date").value = todayIso;
__lastKnownToday = todayIso;
__dateUserSelected = false;
__bpUserOverride = false;
prepareIntakeStatusHeader();
$("#from").value = new Date(Date.now()-90*24*3600*1000).toISOString().slice(0,10);
$("#to").value = todayIso;
setTab("capture");
try{ resetCapturePanels(); updateBpCommentWarnings?.(); }catch(_){ }
try { addCapturePanelKeys?.(); } catch(_){ }
bindAuthButtons();
if (sbClient) watchAuthState()

// Wenn schon eingeloggt -> App starten, sonst Login-Leiste zeigen
const hasSession = await requireSession();
if (hasSession) {
  await afterLoginBoot(); // wichtig fuer Reload mit persistierter Session
      // Doctor-Unlock: nur bei Arzt-Ansicht (kein globaler App-Lock)  //  App-Lock direkt nach Boot pruefen/anzeigen
  await setupRealtime();  //  NEU: Realtime direkt aktivieren
  await requestUiRefresh();
}
  try {
    await refreshCaptureIntake();
  } catch(_) {}
await maybeRefreshForTodayChange({ force: true, source: 'boot' });
  __lastKnownToday = todayStr();
  scheduleMidnightRefresh();
  scheduleNoonSwitch();
  maybeAutoApplyBpContext({ source: 'boot-post-refresh' });
await refreshAppointments();
bindAppLockButtons();     //  Buttons der Lock-Card binden

// Konfiguration laden
const savedUrl = await getConf("webhookUrl");
const savedKey = await getConf("webhookKey");
// Diagnose: aktive REST-URL und Key-Typ
diag.add?.('Config URL: ' + (savedUrl || '(none)'));
diag.add?.('Config Key: ' + (savedKey ? (isServiceRoleKey(savedKey) ? 'service_role(BLOCKED)' : 'anon/ok') : '(none)'));
if (!savedUrl || !savedKey) {
  setTab("capture"); // In Erfassung bleiben
}

// Sanfte Warnung
// === Live-Kommentar-Pflicht: sofort roter Rand bei Grenzwertueberschreitung ===
['#captureAmount','#diaM','#bpCommentM','#sysA','#diaA','#bpCommentA'].forEach(sel=>{
  const el = $(sel); if(!el) return;
  el.addEventListener('input', updateBpCommentWarnings);
});
updateBpCommentWarnings();


// Toggle-Handler
const bpContextSel = document.getElementById('bpContextSel');
__bpPanesCache = Array.from(document.querySelectorAll('.bp-pane'));
if (bpContextSel){
  applyBpContext(bpContextSel.value || 'M');
  maybeAutoApplyBpContext({ force: true, source: 'boot' });
  bpContextSel.addEventListener('change', (e)=>{
    __bpUserOverride = true;
    applyBpContext(e.target.value);
    updateBpCommentWarnings();
  });
}

const saveBpPanelBtn = document.getElementById('saveBpPanelBtn');
if (saveBpPanelBtn){
  saveBpPanelBtn.addEventListener('click', async (e)=>{
    try {
      const logged = await isLoggedInFast();
      if (!logged) {
        diag.add?.('[panel] bp save while auth unknown');
        // Diagnostics only: keep going so fetchWithAuth can recover auth state.
      }
    } catch(err) {
      console.error('isLoggedInFast check failed', err);
    }
    const btn = e.currentTarget;
    const ctxSel = document.getElementById('bpContextSel');
    const which = (ctxSel?.value === 'A') ? 'A' : 'M';
    updateBpCommentWarnings();
    if (requiresBpComment(which)){
      alert("Bitte Kommentar eingeben bei Grenzwertueberschreitung (Sys>130 oder Dia>90).");
      const target = document.getElementById(which === 'M' ? 'bpCommentM' : 'bpCommentA');
      if (target) target.focus();
      return;
    }
    withBusy(btn, true);
    let savedOk = false;
    try{
      const saved = await saveBlock(which === 'M' ? 'Morgen' : 'Abend', which, false, false);
      if (!saved){
        uiError('Keine Daten fuer diesen Messzeitpunkt eingegeben.');
      } else {
        savedOk = true;
        requestUiRefresh({ reason: 'panel:bp' }).catch(err => {
          diag.add?.('ui refresh err: ' + (err?.message || err));
        });
      }
    }catch(err){
      diag.add?.('Panel BP Fehler: ' + (err?.message || err));
      uiError('Speichern fehlgeschlagen. Bitte erneut versuchen.');
    }finally{
      withBusy(btn, false);
    }
    if (savedOk){
      updateBpCommentWarnings();
      resetBpPanel(which); flashButtonOk(btn, '&#x2705; Blutdruck gespeichert');
    }
  });
}

const saveBodyPanelBtn = document.getElementById('saveBodyPanelBtn');
if (saveBodyPanelBtn){
  saveBodyPanelBtn.addEventListener('click', async (e)=>{
    try {
      const logged = await isLoggedInFast();
      if (!logged) {
        diag.add?.('[panel] body save while auth unknown');
        // Diagnostics only: continue to let fetchWithAuth handle auth refresh.
      }
    } catch(err) {
      console.error('isLoggedInFast check failed', err);
    }
    const btn = e.currentTarget;
    withBusy(btn, true);
    let savedOk = false;
    try{
      const saved = await saveDaySummary({ includeBody: true, includeFlags: false, includeFlagsComment: false });
      if (!saved){
        uiError('Keine Koerperdaten eingegeben.');
      } else {
        savedOk = true;
        requestUiRefresh({ reason: 'panel:body' }).catch(err => {
          diag.add?.('ui refresh err: ' + (err?.message || err));
        });
      }
    }catch(err){
      diag.add?.('Panel Koerper Fehler: ' + (err?.message || err));
      uiError('Speichern fehlgeschlagen. Bitte erneut versuchen.');
    }finally{
      withBusy(btn, false);
    }
    if (savedOk){
      resetBodyPanel();
      diag.add?.('[body] cleared');
      flashButtonOk(btn, '&#x2705; Koerper gespeichert');
    }
  });
}

const saveFlagsPanelBtn = document.getElementById('saveFlagsPanelBtn');
if (saveFlagsPanelBtn){
  saveFlagsPanelBtn.addEventListener('click', async (e)=>{
    try {
      const logged = await isLoggedInFast();
      if (!logged) {
        diag.add?.('[panel] flags save while auth unknown');
        // Diagnostics only: request proceeds so auth wrapper can retry properly.
      }
    } catch(err) {
      console.error('isLoggedInFast check failed', err);
    }
    const btn = e.currentTarget;
    withBusy(btn, true);
    let savedOk = false;
    try{
      const saved = await saveDaySummary({ includeBody: false, includeFlags: true, includeFlagsComment: true });
      if (!saved){
        uiError('Keine Flag-Daten eingegeben.');
      } else {
        savedOk = true;
        requestUiRefresh({ reason: 'panel:flags' }).catch(err => {
          diag.add?.('ui refresh err: ' + (err?.message || err));
        });
      }
    }catch(err){
      diag.add?.('Panel Flags Fehler: ' + (err?.message || err));
      uiError('Speichern fehlgeschlagen. Bitte erneut versuchen.');
    }finally{
      withBusy(btn, false);
    }
    if (savedOk){
      resetFlagsPanel(); flashButtonOk(btn, '&#x2705; Flags gespeichert');
    }
  });
}

const bindToggle = (id, setter, getVal)=>{
  const el = $(id);
  el.addEventListener("click", ()=>{
    setter(!getVal());
  });
};
bindToggle("#trainingToggle", setTraining, ()=>trainingActive);
bindToggle("#lowIntakeToggle", setLowIntake, ()=>lowIntakeActive);
bindToggle("#sickToggle", setSick, ()=>sickActive);
bindToggle("#valsartanMissToggle", setValsartanMiss, ()=>valsartanMissed);
bindToggle("#forxigaMissToggle", setForxigaMiss, ()=>forxigaMissed);
bindToggle("#nsarToggle", setNsar, ()=>nsarTaken);
bindToggle("#saltHighToggle", setSaltHigh, ()=>saltHigh);
bindToggle("#proteinHighToggle", setProteinHigh, ()=>proteinHigh);

// Sync toggles when the date changes in capture view
const dateEl = document.getElementById('date');
  if (dateEl) {
    dateEl.addEventListener('change', async () => {
      try {
        const todayIso = todayStr();
        __dateUserSelected = (dateEl.value || '') !== todayIso;
        // was du beim Datum aendern haben willst:
        await refreshCaptureIntake();
        await syncCaptureToggles();
        resetCapturePanels();
        updateBpCommentWarnings?.();
        await prefillBodyInputs();
      } catch(_) {}
    });
  }

// Apply Range -> Arztansicht neu rendern
const applyBtn = $("#applyRange");
if (applyBtn) {
  applyBtn.addEventListener("click", async () => {
    await requestUiRefresh({ reason: 'doctor:range' });
    setDocBadges({ visible: true });
  });
}

$("#doctorChartBtn").addEventListener("click", async ()=>{
  try {
    const logged = await isLoggedInFast();
    if (!logged) {
      diag.add?.('[doctor] chart open while auth unknown');
      // Diagnostics only: chart refresh still runs so auth flow can recover.
    }
  } catch(err) {
    console.error('isLoggedInFast check failed', err);
  }
  if (!isDoctorUnlocked()){
    setAuthPendingAfterUnlock('chart');
    const ok = await requireDoctorUnlock();
    if (!ok) return;
    setAuthPendingAfterUnlock(null);
  }
  setDocBadges({ visible: true });
  chartPanel.show();
  await requestUiRefresh({ reason: 'doctor:chart-open', chart: true });
});

document.addEventListener('keydown', (e)=>{
  if (e.key !== 'Escape') return;

  try {
    if (chartPanel?.open) {
      chartPanel.hide();
      e.preventDefault();
      return;
    }
    if (helpPanel?.open) {
      helpPanel?.hide?.();
      e.preventDefault();
      return;
    }
    if (diag?.open) {
      diag.hide();
      e.preventDefault();
      return;
    }
  } catch(_){ }

  try {
    const appLock = document.getElementById('appLock');
    if (appLock && appLock.style.display !== 'none') {
      setAuthPendingAfterUnlock(null);
      const lockFn = getLockUi();
      if (lockFn) {
        lockFn(false);
      } else {
        document.body.classList.remove('app-locked');
        appLock.style.display = 'none';
      }
      e.preventDefault();
      return;
    }
    const login = document.getElementById('loginOverlay');
    if (login && login.style.display !== 'none') {
      showLoginOverlay(false);
      e.preventDefault();
      return;
    }
  } catch(_){ }
});

const resumeEventHandler = (source) => {
  (async () => {
    try {
      await resumeFromBackground(source);
    } catch (err) {
      diag.add?.(`[resume] handler error ${source}: ${err?.message || err}`);
    }
  })();
};
document.addEventListener('visibilitychange', () => {
  diag.add?.(`[event] visibilitychange -> ${document.visibilityState}`);
  if (document.visibilityState !== 'visible') return;
  resumeEventHandler('visibility');
});

window.addEventListener('pageshow', (event) => {
  diag.add?.(`[event] pageshow (persisted=${event.persisted ? 1 : 0})`);
  if (event.persisted || document.visibilityState === 'visible') {
    resumeEventHandler('pageshow');
  }
});

window.addEventListener('focus', () => {
  diag.add?.('[event] focus');
  resumeEventHandler('focus');
});

/** END MODULE */

// --- Arzt-Export ---
// SUBMODULE: buildDoctorSummaryJson @extract-candidate @public - planned aggregator for doctor export payloads
// SUBMODULE: exportDoctorJson @internal - triggers download (future: route via buildDoctorSummaryJson @extract-candidate @public)
$("#doctorExportJson").addEventListener("click", async () => {
  try {
    const logged = await isLoggedInFast();
    if (!logged) {
      diag.add?.('[doctor] export while auth unknown');
      // Diagnostics only: export still runs so auth wrapper can trigger re-login if needed.
    }
  } catch(err) {
    console.error('isLoggedInFast check failed', err);
  }
  if (!isDoctorUnlocked()) {
    setAuthPendingAfterUnlock('export');
    const ok = await requireDoctorUnlock();
    if (!ok) return;
    setAuthPendingAfterUnlock(null);
  }
  const all = await getAllEntries();
  dl("gesundheitslog.json", JSON.stringify(all, null, 2), "application/json");
});

// --- Lifestyle binden und initial (falls bereits angemeldet) laden ---
bindIntakeCapture();
bindAppointmentsPanel();
try { if (await isLoggedInFast()) { await cleanupOldIntake(); } } catch(_) {}

// Initial Render
await requestUiRefresh({ reason: 'boot:initial', appointments: true });

// --- Failsafe: nach Reload alles sicher freigeben (falls etwas "disabled" haengen blieb)
$$('#appMain input, #appMain select, #appMain textarea, #appMain button, nav.tabs button').forEach(el=>{
el.disabled = false;
});
document.body.classList.remove('auth-locked');

// Auto-Push Pending sobald online
window.addEventListener('online', async ()=>{
const resPush = await pushPendingToRemote();
if(resPush.pushed || resPush.failed){
diag.add('Online-Push: OK=' + resPush.pushed + ', FAIL=' + resPush.failed);
if (typeof reconcileFromRemote === 'function') {
  await reconcileFromRemote();
}
}
});
}

resetAppointmentsUi();

/* boot */
if (!window.__bootDone) {
  window.__bootDone = true;
  if (document.readyState === "loading") {
    window.addEventListener("DOMContentLoaded", main);

    window.addEventListener('focus', () => {
      try { maybeRefreshForTodayChange({ source: 'focus' }); } catch(_){ }
    });
  } else {
    main();
  }
}

/** MODULE: FUTURE (placeholders)
 * intent: haelt geplante Assist/PWA/BLE-Refactors fuer die Zeit nach dem Annotations-Pass bereit
 * exports: (geplant) assistHooks, pwaBootstrap, bleIntegration
 * notes: Nur Kommentare; Logik folgt bei Modul-Extraction
 */
// SUBMODULE: assist hooks (planned) @internal - future foodcoach/health assistants
// SUBMODULE: pwa bootstrap (planned) @internal - manifest/service worker wiring
// SUBMODULE: ble integration (planned) @internal - GATT 0x1810 blood pressure bridge
/** END MODULE */

/* === Debug-Notizen
- V1.5: Realtime ueber supabase-js; Projekt-URL aus REST-URL abgeleitet.
- Auto-Sync: push pending ? reconcile (Entries) ohne Wipe.
- Realtime-Events: INSERT/UPDATE ? upsert, DELETE ? lokal entfernen.
- UI-Refresh: Arzt-Ansicht sofort; Charts nur, wenn Panel offen.
=== */
</script>
<!-- Login-Overlay (zentriert) -->
<div id="loginOverlay" style="display:none">
  <div class="login-card" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
    <h3 id="loginTitle">Willkommen</h3>
    <p class="small" style="margin:0 0 8px">Melde dich an, um Arzt-Ansicht & Diagramme zu nutzen.</p>
    <button class="btn primary" id="googleLoginBtn" type="button" style="width:100%;height:48px;margin-bottom:12px">Mit Google anmelden</button>
    <details id="configAdv" class="config-box" style="margin-bottom:12px">
      <summary class="small" style="cursor:pointer;list-style:none;padding:8px 0">Erweiterte Einstellungen</summary>
      <div style="display:flex;flex-direction:column;gap:6px;margin-top:4px">
        <label class="small" for="configRestUrl">Supabase REST-Endpoint</label>
        <input id="configRestUrl" type="url" inputmode="url" placeholder="https://...supabase.co/rest/v1/health_events" style="width:100%;padding:10px;border-radius:8px;border:1px solid #d1d5db">
        <label class="small" for="configAnonKey" style="margin-top:4px">Supabase ANON-Key</label>
        <textarea id="configAnonKey" rows="3" placeholder="ANON-Key (kein service_role)" style="width:100%;padding:10px;border-radius:8px;border:1px solid #d1d5db;resize:vertical"></textarea>
        <button class="btn ghost" id="configSaveBtn" type="button" style="width:100%;margin-top:4px">Konfiguration speichern</button>
        <div id="configStatus" class="small" style="min-height:16px;color:#9aa3af"></div>
      </div>
    </details>
    <div id="whoAmI" class="small" style="text-align:center;margin-top:6px"></div>
  </div>
</div>

<!-- App-Lock Overlay (zentriert) -->
<div id="appLock" style="display:none">
  <div class="lock-card" role="dialog" aria-modal="true" aria-labelledby="lockTitle">
    <h3 id="lockTitle">App gesperrt</h3>
    <p class="small" style="margin:0 0 8px">
      Bitte entsperren: bevorzugt per Passkey (Finger/Face). Alternativ PIN.
    </p>

    <div class="row" style="gap:8px">
      <button class="btn primary" id="unlockPasskeyBtn" type="button" style="width:100%;height:48px">
        Per Passkey entsperren
      </button>
    </div>

    <div class="pin-wrap">
      <input id="pinInput" type="password" inputmode="numeric" autocomplete="off" placeholder="PIN (optional)">
      <button class="btn ghost" id="unlockPinBtn" type="button">PIN</button>
    </div>

    <div class="small" style="margin-top:8px; opacity:.8">
      <button class="btn ghost" id="setupPasskeyBtn" type="button" style="width:100%;margin-top:6px">
        Passkey einrichten
      </button>
      <button class="btn ghost" id="setPinBtn" type="button" style="width:100%;margin-top:6px">
        PIN setzen/aendern
      </button>
    </div>

    <button class="btn ghost" id="lockCancelBtn" type="button" style="width:100%;margin-top:8px">
      Abbrechen
    </button>

    <div id="lockMsg" class="small" style="margin-top:6px;color:#6b7280"></div>
  </div>
</div>

</body>
</html>

<!-- ANNOTATION SUMMARY
  modules:
    - BOOTSTRAP & CONSTANTS -> #SUBMODULES: 0, #@extract: 0, Exports:[none]
    - CAPTURE (Intake) - HTML Shell -> #SUBMODULES: 0, #@extract: 0, Exports:[none]
    - DOCTOR VIEW - HTML -> #SUBMODULES: 0, #@extract: 0, Exports:[none]
    - CONFIG -> #SUBMODULES: 0, #@extract: 0, Exports:[DEV_ALLOW_DEFAULTS, APPOINTMENT_ROLES]
    - LOGGING & DIAGNOSTICS -> #SUBMODULES: 2, #@extract: 0, Exports:[diag, recordPerfStat, uiError, uiInfo]
    - UI / ROUTING / VIEWS - Core (Refresh/Help) -> #SUBMODULES: 7, #@extract: 0, Exports:[requestUiRefresh, runUiRefresh, maybeRefreshForTodayChange, setUnderlayInert]
    - AUTH - Guards -> #SUBMODULES: 3, #@extract: 0, Exports:[isLoggedIn, isLoggedInFast, setAuthGuard, setDoctorAccess]
    - UTILITIES -> #SUBMODULES: 0, #@extract: 0, Exports:[$,$$,fmtNum,todayStr,timeStr,esc,nl2br]
    - CAPTURE (Intake) - State & Timer -> #SUBMODULES: 1, #@extract: 0, Exports:[refreshCaptureIntake, scheduleMidnightRefresh, maybeResetIntakeForToday, bindIntakeCapture, updateCaptureIntakeStatus]
    - DATA ACCESS (IndexedDB) -> #SUBMODULES: 2, #@extract: 0, Exports:[initDB, putConf, getConf, addEntry, updateEntry, getAllEntries, getEntryByRemoteId, deleteEntryLocal, dayIsoToMidnightIso]
    - AUTH - Header Cache -> #SUBMODULES: 1, #@extract: 0, Exports:[getHeaders]
    - DATA ACCESS (REST/RPC) -> #SUBMODULES: 30, #@extract: 1, Exports:[deleteRemote, loadIntakeToday, saveIntakeTotals, saveIntakeTotalsRpc, fetchDailyOverview, deleteRemoteDay]
    - APPOINTMENTS -> #SUBMODULES: 12, #@extract: 0, Exports:[refreshAppointments, handleAppointmentSave, handleAppointmentDone, bindAppointmentsPanel, setAppointmentBadge]
    - CAPTURE (Intake) - Status & RPC Hooks -> #SUBMODULES: 7, #@extract: 2, Exports:[clearCaptureIntakeInputs, setCaptureIntakeDisabled, prepareIntakeStatusHeader, updateCaptureIntakeStatus, handleCaptureIntake]
    - DOCTOR VIEW - Logic -> #SUBMODULES: 3, #@extract: 1, Exports:[renderDoctor, setDocBadges, renderDoctorDay, exportDoctorJson]
    - CHARTS (SVG/Canvas) -> #SUBMODULES: 15, #@extract: 3, Exports:[chartPanel]
    - UI / ROUTING / VIEWS - Navigation (Tabs/Resume/Focus) -> #SUBMODULES: 1, #@extract: 1, Exports:[setTab, bindTabs]
    - CAPTURE (Intake) - Flag Toggles -> #SUBMODULES: 1, #@extract: 0, Exports:[setProteinHigh, setTraining, setLowIntake, setSaltHigh]
    - BP (Blood Pressure) - Validierung -> #SUBMODULES: 5, #@extract: 0, Exports:[requiresBpComment, updateBpCommentWarnings, resetBpPanel]
    - CAPTURE (Intake) - Panel Resets & Shortcuts -> #SUBMODULES: 8, #@extract: 0, Exports:[resetBodyPanel, resetFlagsPanel, resetCapturePanels, addCapturePanelKeys, setSick, setValsartanMiss, setForxigaMiss, setNsar]
    - BP (Blood Pressure) - Persistenz -> #SUBMODULES: 6, #@extract: 0, Exports:[saveBlock, appendNote, allocateNoteTimestamp]
    - BODY (Koerperwerte) -> #SUBMODULES: 1, #@extract: 0, Exports:[saveDaySummary, saveFlagsCommentNote]
    - DATA ACCESS (Auth Helpers) -> #SUBMODULES: 3, #@extract: 2, Exports:[withRetry, fetchWithAuth, syncWebhook]
    - REALTIME -> #SUBMODULES: 17, #@extract: 8, Exports:[ensureSupabaseClient, setupRealtime, requireDoctorUnlock, resumeFromBackground]
    - FUTURE (placeholders) -> #SUBMODULES: 3, #@extract: 0, Exports:[assistHooks (planned), pwaBootstrap (planned), bleIntegration (planned)]
  total @extract-candidate markers: 18
-->












