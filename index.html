<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Gesundheits-Logger (V1.0.0)</title>
<style>

/* ANKER: chart-controls styles (move to assets/app.css bei nächster Release) */
  /* Dropdown optisch kompakter */
  #chart .controls .compact { max-width: 240px; }

  /* KPI-Zeile: Ø-Werte neben dem Dropdown */
  #chart .controls .kpis {
    display: inline-flex;
    gap: 16px;
    align-items: center;
    margin-left: 16px;
    color: var(--text, #e5e7eb);
    font-size: 0.95rem;
    white-space: nowrap;
  }
  #chart .controls .kpis .sep { opacity: .6; }
  
body.auth-locked main{ opacity:.6; }
:root { --bg:#0b0c10; --card:#15171c; --fg:#e8e8e8; --muted:#9aa3af; --accent:#4f46e5; --warn:#f59e0b; --ok:#10b981; --danger:#ef4444; }
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial;background:var(--bg);color:var(--fg);-webkit-tap-highlight-color:transparent;touch-action:manipulation;overscroll-behavior-y:none}
header{position:sticky;top:0;background:linear-gradient(180deg,rgba(11,12,16,.95),rgba(11,12,16,.7));backdrop-filter:blur(6px);z-index:10;padding:10px 12px;border-bottom:1px solid #1f232b}
h1{margin:0;font-size:20px}
nav.tabs{display:flex;gap:8px;padding:8px 12px;position:sticky;top:54px;background:rgba(11,12,16,.9);backdrop-filter:blur(6px);z-index:11}
nav.tabs button{flex:1;min-width:100px;touch-action:manipulation}
main{padding:12px;position:relative;z-index:1}
.card{background:var(--card);border:1px solid #242833;border-radius:16px;padding:14px;margin-bottom:12px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
.row{display:flex;gap:8px;flex-wrap:wrap}
.grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
@media (max-width:640px){ .grid{grid-template-columns:1fr} }
label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
input, select, textarea {width:100%;padding:12px;border-radius:12px;border:1px solid #2b2f3a;background:#0f1116;color:var(--fg);font-size:16px}
textarea{min-height:64px;resize:vertical}

.small{font-size:12px;color:var(--muted)}
.btn{appearance:none;border:none;border-radius:12px;padding:12px 14px;font-weight:600;color:white;background:#2b2f3a;cursor:pointer;touch-action:manipulation;transition: background .25s ease, color .25s ease, transform .06s ease, box-shadow .25s ease}
.btn:disabled{opacity:.6;cursor:not-allowed}
.btn:active{ transform: scale(0.98) }
.btn.primary{background:var(--accent)}
.btn.ghost{background:#0f1116;border:1px solid #2b2f3a;color:var(--fg)}
.btn.warn{background:var(--warn);color:#1a1200}
.btn.toggle.active{ background: var(--ok); color:#06110b; border-color: transparent; }
/* Tabs: aktiver Zustand = wie Primary */
nav.tabs .btn.primary {
  background: var(--accent);
  color: #fff;
  border-color: transparent;
}

.btn.flash{background:linear-gradient(90deg,var(--accent) 0%,#7c3aed 50%,var(--accent) 100%)!important;background-size:200% 100%;color:#fff!important;animation:flashGradient 1s ease forwards,flashPop .2s ease;box-shadow:0 6px 24px rgba(79,70,229,.35)}
@keyframes flashGradient{0%{background-position:0% 50%}100%{background-position:100% 50%}}
@keyframes flashPop {
0% { transform: scale(1) }
50% { transform: scale(1.03) }
100% { transform: scale(1) }
}

/* Toolbar mit zentrierter Mitte + Badges rechts */
#doctorCard .toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: space-between; /* Titel links + Mitte + Badges rechts */
}

#doctorCard .toolbar .center-group {
  flex: 1;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center; /* Buttons + Datum + Anwenden mittig */
}

#doctorCard .toolbar .badge {
  margin-left: 8px;
}

.spacer{flex:1}
section.view{display:none}
section.view.active{display:block}

#doctorCard .toolbar{border-bottom:1px solid #242833;padding-bottom:8px;margin-bottom:8px}

#err{position:fixed;left:8px;right:8px;bottom:8px;background:#3d0d0d;color:#fecaca;padding:8px 10px;border-radius:10px;display:none;z-index:9999}

/* === Arzt-Ansicht (Daily): 3-Spalten-Layout je Tag === */
.doctor-view .doctor-day{
display:grid;
grid-template-columns: 1fr; /* Standard = gestapelt */
gap:12px;
align-items:start;
padding:12px 14px;
margin:8px 0;
border-radius:12px;
background:var(--card);
border:1px solid #242833;
box-shadow:0 6px 18px rgba(0,0,0,.25);
page-break-inside:avoid;
break-inside:avoid;
}

  /* --- Arzt-Toolbar Badges (Daily KPIs) --- */
.badge {
  display: inline-block;
  padding: 6px 12px;         /* etwas mehr Platz */
  border: 1.5px solid #2b2f3a;
  border-radius: 12px;       /* runder = moderner */
  font-size: 13px;           /* +1pt größer */
  font-weight: 600;          /* kräftiger */
  margin-left: 10px;
}
.badge.good{border-color:var(--ok); color:var(--ok)}
.badge.bad{ border-color:var(--danger); color:var(--danger)}
.badge.hidden{ display:none !important; }

/* Tablet/Desktop: nebeneinander */
@media (min-width: 900px){
.doctor-view .doctor-day{
grid-template-columns: 18% 46% 36%;
}
}

/* Zwischenbereich: 2 Spalten */
@media (min-width: 600px) and (max-width: 899px){
.doctor-view .doctor-day{
grid-template-columns: 40% 60%;
grid-template-areas:
"date measure"
"date special";
}
.doctor-view .col-date{ grid-area: date; }
.doctor-view .col-measure{ grid-area: measure; }
.doctor-view .col-special{ grid-area: special; }
}

/* Spalte A – Datum */
.doctor-view .col-date{
display:flex; align-items:center;
font-weight:800;
font-size:clamp(16px,1.6vw,20px);
letter-spacing:.2px;
}
  /* Datumsspalte mit Cloud + Delete untereinander */
.doctor-view .col-date{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.doctor-view .col-date .date-top{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}
.doctor-view .col-date .date-label{
  font-weight:800;
  font-size:clamp(16px,1.6vw,20px);
  letter-spacing:.2px;
}
.doctor-view .col-date .date-cloud{ font-size:16px; line-height:1; }
.doctor-view .col-date .date-actions{
  display:flex;
  justify-content:flex-start; /* oder center, wenn du’s mittig magst */
}
.btn-xs{ padding:6px 10px; font-size:12px; border-radius:8px; }

/* Spalte B – Messungen */
.doctor-view .col-measure{ display:grid; grid-template-rows:auto 1fr; gap:6px; }
/* Kopf und Werte-Spalten: gleiche Breiten wie Zahlen, Label links fix */
.doctor-view .measure-head,
.doctor-view .measure-grid{
display:grid;
grid-template-columns: minmax(70px, auto) repeat(4, 1fr);
gap:4px;
}
.doctor-view .measure-head{ font-size:12px; opacity:.8; }


/* Head-Zellen als Flex: rechtsbündig wie die Zahlen */
.doctor-view .measure-head > div{ display:flex; align-items:center; }
.doctor-view .measure-head > div:first-child{ justify-content:flex-start; }
.doctor-view .measure-head > div:not(:first-child){ justify-content:flex-end; }
.doctor-view .measure-row{ display:contents; }
.doctor-view .label{ display:flex; align-items:center; font-size:13px; opacity:.9; }

/* Zahlenbild */
.doctor-view .num{
font-variant-numeric: tabular-nums lining-nums;
-moz-font-feature-settings:"tnum","lnum";
-webkit-font-feature-settings:"tnum","lnum";
font-feature-settings:"tnum","lnum";
text-align:right;
display:flex; align-items:center; justify-content:flex-end;

min-width: 4ch; /* Basisschutz gegen Abschneiden */
white-space: nowrap;
}
  
  /* Grenzwert-Highlight für Arzt-Ansicht */
.doctor-view .num.alert{ color: var(--danger); }

.doctor-view .measure-grid .num,
.doctor-view .col-special .num{
text-align:right; justify-content:flex-end;
}

/* Spalte C – Spezialinfos */
/* Gewicht: Überschrift + Zahl darunter */
.doctor-view .weight-line{
  display:flex;
  flex-direction: column;
  align-items: center;   /* mittig statt links */
  gap: 4px;
  background: transparent;
  border: none;
  padding: 0;
  font-weight: 600;
}

.doctor-view .weight-line > :first-child{
  font-size: 12px;
  opacity:.8;
  font-weight:600;
  letter-spacing:.2px;
}
.doctor-view .weight-line .num{
  font-size:clamp(16px,1.6vw,20px);
  font-weight:700;
  line-height:1.1;
  text-align:center;   /* mittig */
}

/* Spalten C/D/E: Gewicht | Flags | Kommentar */
.doctor-view .col-special{
  display: grid;
  grid-template-columns: minmax(120px, max-content) 220px 1fr; /* C | D | E */
  column-gap: 16px;
  row-gap: 6px;
  align-items: start; /* <-- alles oben ausrichten */
}

/* Elemente gezielt in Spalten setzen */
.doctor-view .col-special > .weight-line { grid-column: 1; }
.doctor-view .col-special > .flags       { grid-column: 2; }
.doctor-view .col-special > .notes       { grid-column: 3; }

/* D: Flags – Desktop: eine Spalte untereinander */
.doctor-view .flags{
  display:grid;
  grid-template-columns: repeat(2, max-content); /* 2 Spalten */
  justify-content:start;
  align-items:start;
  gap: 6px 16px; /* vertikal 6px, horizontal 16px */
}

.doctor-view .weight-line .num{ font-variant-numeric: tabular-nums; } /* Spalten wirken ruhiger */
.doctor-view .flag span:last-child{ white-space:nowrap; }
.doctor-view .flag{ display:grid; grid-template-columns:18px 1fr; align-items:center; gap:6px; font-size:12px; opacity:.95; }
.doctor-view .flag-box{
width:16px; height:16px; border:1.5px solid #2b2f3a; border-radius:3px; display:inline-block; position:relative;
}
.doctor-view .flag-box.on::after{
content:""; position:absolute; inset:2px; background:var(--accent); border-radius:2px;
}

/* Notizen: im Screen 3 Zeilen, im Druck voll */
/* Kommentar: Titel + Box */
/* Kommentar: Kopf + Wert, ohne Kasten */
.doctor-view .notes{
  font-size: 13px;
  line-height: 1.35;
  display: -webkit-box;
  -webkit-line-clamp: 3;      /* 3 Zeilen, bei Bedarf 2 setzen */
  -webkit-box-orient: vertical;
  overflow: hidden;
  word-break: break-word;
  padding: 0;                 /* kein Box-Feeling */
  background: transparent;
  border: none;
}
.doctor-view .notes::before{
  content: "Kommentar";
  display: block;
  font-size: 12px;
  opacity: .8;
  font-weight: 600;
  letter-spacing: .2px;
  margin-bottom: 4px;
}
/* NICHT ausblenden, auch wenn leer – der Renderer liefert "–" */

/* Mobile-Optimierung */
@media (max-width: 599px){

  /* Kopf & Werte: schmälere Label-Spalte + garantierte Zahlbreite */
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(72px, 1fr) repeat(4, minmax(56px, 1fr));
  }
  .doctor-view .measure-head{ font-size: 11px; }

  /* Zahlen dürfen nicht schrumpfen → keine abgeschnittenen Dezimalstellen */
  .doctor-view .num{
    min-width: 4.5ch; /* ~ „96.7“ passt sicher */
    white-space: nowrap;
    flex: 0 0 auto;
  }
  .doctor-view .col-special .weight-line .num{
    min-width: 5ch; /* „84.5“ o. Ä. */
  }

  /* Spalten: Gewicht | Flags nebeneinander, Kommentar darunter über volle Breite */
  .doctor-view .col-special{
    grid-template-columns: minmax(110px, max-content) 1fr; /* Flags bekommen flex Breite */
    column-gap: 12px;
  }
  .doctor-view .col-special > .notes{
    grid-column: 1 / -1; /* Kommentar über beide Spalten */
  }

  /* Kommentar: mobil 4 Zeilen anzeigen */
  .doctor-view .notes{
    -webkit-line-clamp: 4; /* bei Bedarf auf 5 erhöhen */
  }

  /* Flags: kompakt in 2 Spalten, keine abgeschnittenen Labels */
  .doctor-view .flags{
    display: grid;
    grid-template-columns: repeat(2, max-content);
    justify-content: start;
    align-items: center;
    column-gap: 14px;
    row-gap: 6px;
    margin-top: 6px;
  }
  .doctor-view .flag span:last-child{ white-space: nowrap; }
}

/* Extra-eng (≤ 390px Breite) */
@media (max-width: 390px){
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(66px, 1fr) repeat(4, minmax(50px, 1fr));
  }
  .doctor-view .flags{
    grid-template-columns: repeat(3, max-content);
  }
}

/* Panels */
.panel{position:fixed;right:8px;bottom:8px;max-height:80vh;overflow:auto;background:#0f1116;border:1px solid #2b2f3a;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.35);display:none;z-index:9998}
/* Panel (Charts) — Fullscreen */
.panel.chart{
  inset: 0;                 /* volle Fläche (top/right/bottom/left = 0) */
  width: 100vw;
  height: 100dvh;           /* korrekt auf Mobile (sichtbare Höhe) */
  max-width: 100vw;
  max-height: 100dvh;
  border-radius: 0;         /* keine abgerundeten Ecken im Vollbild */
}

/* Flex-Layout: Header fix oben, Inhalt füllt Rest */
.panel.chart{
  /* Sichtbarkeit steuert JS; NICHT auf block setzen */
}
.panel.chart header{ 
  /* bleibt oben, keine Änderung nötig – aber fixere Höhe ist hilfreich */
  min-height: 44px;
}
.panel.chart .content{
  /* Inhalt füllt den verfügbaren Raum */
  height: calc(100dvh - 44px - 2px); /* 44px Header + 1px border oben/unten */
  display: flex;
  flex-direction: column;
  overflow: auto;
}
.panel header{display:flex;gap:6px;align-items:center;justify-content:space-between;padding:8px;border-bottom:1px solid #2b2f3a}
.panel h4{margin:0;font-size:14px}
.panel .content{
  padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) 
           max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
  font-size: 13px;
  line-height: 1.45;
}
#diag pre{margin:0;padding:8px;font-size:12px;white-space:pre-wrap}

/* FABs */
.fab-wrap{position:fixed;right:8px;bottom:8px;display:flex;flex-direction:column;gap:8px;z-index:9999}
.fab{width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;border:1px solid #2b2f3a;background:#0f1116;cursor:pointer}
.fab:hover{box-shadow:0 8px 24px rgba(0,0,0,.35)}

/* Chart panel */
#chart .controls{
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  margin-bottom:6px;
}
#chart .controls > * {flex:1}
#chart .controls .half{flex:0 0 calc(50% - 4px)}
/* SVG füllt verbleibende Höhe vollständig */
#chart svg{
  width: 100%;
  height: 100%;
  display: block;
  background: #0f1116;
  border: 1px solid #2b2f3a;
  border-radius: 10px;
  min-height: 0; /* wichtig für Flex-Container */
}
#chart .legend{display:flex;gap:10px;font-size:12px;color:var(--muted);margin-top:6px;flex-wrap:wrap}

.dot{width:8px;height:8px;border-radius:50%;display:inline-block;margin-right:6px;border:1px solid #000}

/* Busy overlay */
#busy{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);z-index:99998}
#busy .box{background:#10131a;border:1px solid #2b2f3a;border-radius:12px;padding:12px 16px;font-weight:600}

.seg{display:flex;gap:8px;margin:8px 0 12px}
.seg .seg-btn.active{background:var(--accent);color:#fff}
.hidden{display:none!important}
:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }
  
</style>
</head>
<body>
<header>
<div style="display:flex;align-items:center;gap:10px">
<h1>Gesundheits-Logger</h1><span class="small">V1.0.0</span>
<div class="spacer"></div>
<button class="btn ghost" id="helpToggle" type="button">Hilfe</button>
<button class="btn ghost" id="diagToggle" type="button">Log</button>
</div>
</header>

<nav class="tabs">
<button class="btn ghost" data-tab="capture" id="tab-capture" type="button">Erfassen</button>
<button class="btn ghost" data-tab="doctor" id="tab-doctor" type="button">Arzt-Ansicht</button>
</nav>

<!-- Hilfe-Panel -->
<div id="help" class="panel" role="dialog" aria-modal="false" aria-labelledby="helpTitle">
<header>
<h4 id="helpTitle">Hilfe • Was soll ich ankreuzen?</h4>
<button class="btn ghost" id="helpClose" type="button">×</button>
</header>
<div class="content">
<strong>NSAR genommen</strong> ankreuzen, wenn du ein Schmerz-/Entzündungsmedikament der Klasse NSAR genommen hast.
<ul>
<li><em>Beispiele (AT, frei):</em> Ibuprofen, Diclofenac, Naproxen.</li>
<li><em>Kombo-Achtung:</em> Viele „Erkältungs-/Kopfweh“-Mittel enthalten NSAR.</li>
<li><em>Bei Nierenkrankheit:</em> NSAR möglichst vermeiden, Alternativen mit Arzt besprechen.</li>
</ul>
</div>
</div>

<!-- Diagnose-Panel -->
<div id="diag" class="panel" role="dialog" aria-modal="false" aria-labelledby="diagTitle">
<header>
<h4 id="diagTitle">Touch-Log</h4>
<button class="btn ghost" id="diagClose" type="button">×</button>
</header>
<pre id="diagLog" class="content" style="margin:0"></pre>
</div>

<!-- Diagramm-Panel (Daily) -->
<div id="chart" class="panel chart" role="dialog" aria-modal="false" aria-labelledby="chartTitle">
<header>
<h4 id="chartTitle">Diagramm (Daily)</h4>
<button class="btn ghost" id="chartClose" type="button">×</button>
</header>
<div class="content">
<div class="controls">
  <select id="metricSel" class="half compact" aria-label="Messgröße auswählen">
    <option value="bp">Blutdruck (Sys/Dia)</option>
    <option value="pulse">Puls</option>
    <option value="weight">Gewicht</option>
  </select>

  <!-- ANKER: chart-averages (Daily) -->
  <div id="chartAverages" class="kpis" aria-live="polite">
    <span data-k="sys">Durchschnitt Sys: –</span>
    <span class="sep" aria-hidden="true">•</span>
    <span data-k="dia">Durchschnitt Dia: –</span>
    <span class="sep" aria-hidden="true">•</span>
    <span data-k="map">Durchschnitt MAP: –</span>
  </div>
</div>

<svg id="chartSvg" viewBox="0 0 640 280" preserveAspectRatio="none" role="img" aria-label="Werteverlauf"></svg>
<div class="legend" id="chartLegend"></div>
<div class="small" style="opacity:.7;margin-top:6px">Zeitraum: nutzt die <em>Arzt-Ansicht</em> (von/bis).</div>
</div>
</div>

<div id="err" role="status" aria-live="polite"></div>
<div id="busy"><div class="box">⏳ Bitte warten…</div></div>

<main>
<!-- Capture -->
<section class="view active" id="capture">
 
  <!-- Daily-Capture -->
  <section class="card" id="entry">
    <div class="row">
      <div style="flex:1">
        <label>Datum</label>
        <input type="date" id="date">
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Morgens</h3>
      <div class="row">
        <div style="width:130px">
          <label>Uhrzeit</label>
          <input type="time" id="timeM" step="60">
        </div>
      </div>
      <div class="grid">
        <div><label>Systolisch (mmHg)</label><input type="number" id="sysM" inputmode="numeric" placeholder="z. B. 128"></div>
        <div><label>Diastolisch (mmHg)</label><input type="number" id="diaM" inputmode="numeric" placeholder="z. B. 82"></div>
        <div><label>Puls (bpm)</label><input type="number" id="pulseM" inputmode="numeric" placeholder="z. B. 66"></div>
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Abends</h3>
      <div class="row">
        <div style="width:130px">
          <label>Uhrzeit</label>
          <input type="time" id="timeA" step="60">
        </div>
      </div>
      <div class="grid">
        <div><label>Systolisch (mmHg)</label><input type="number" id="sysA" inputmode="numeric" placeholder="z. B. 128"></div>
        <div><label>Diastolisch (mmHg)</label><input type="number" id="diaA" inputmode="numeric" placeholder="z. B. 82"></div>
        <div><label>Puls (bpm)</label><input type="number" id="pulseA" inputmode="numeric" placeholder="z. B. 66"></div>
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Gewicht</h3>
      <div class="row">
        <div style="flex:1">
          <label>Gewicht (kg)</label>
          <input type="number" step="0.1" id="weightDay" inputmode="decimal" placeholder="z. B. 84.2">
        </div>
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Kommentar</h3>
      <div class="row">
        <div style="flex:1">
          <textarea id="notesDay" placeholder="Allgemeiner Kommentar zum Tag (optional)"></textarea>
        </div>
      </div>
    </div>

    <div class="row" style="align-items:center; gap:8px; margin-top:4px">
      <button class="btn toggle" id="trainingToggle" type="button" aria-pressed="false">🏋️ Training heute</button>
      <button class="btn toggle" id="sickToggle" type="button" aria-pressed="false">🤒 Krank (Forxiga pausiert)</button>
      <button class="btn toggle" id="valsartanMissToggle" type="button" aria-pressed="false">💊 Valsartan vergessen</button>
      <button class="btn toggle" id="forxigaMissToggle" type="button" aria-pressed="false">💊 Forxiga vergessen</button>
      <button class="btn toggle" id="lowIntakeToggle" type="button" aria-pressed="false">🚰 &lt; 2 L getrunken</button>
      <button class="btn toggle" id="saltHighToggle" type="button" aria-pressed="false" title="> 5 g Salz">🧂 &gt; 5 g Salz</button>
      <button class="btn toggle" id="sugarHighToggle" type="button" aria-pressed="false" title="> 10 g Zucker">🍬 &gt; 10 g Zucker</button>
      <button class="btn toggle" id="nsarToggle" type="button" aria-pressed="false" title="Nicht-steroidale Antirheumatika">⚠️ NSAR genommen</button>
      <div class="spacer"></div>
    </div>

<div class="row" style="align-items:center; gap:8px; margin-top:12px">
  <button class="btn primary" id="saveAllBtn" type="button">💾 Speichern</button>
  <button class="btn ghost" id="captureChartBtn" type="button" title="Werte als Grafik">Werte anzeigen</button>
  <div class="spacer"></div>
</div>
  </section>
</section>

<!-- Doctor -->
<section class="view" id="doctor">
  <section class="card" id="doctorCard">
    <div class="toolbar">
      <strong id="doctorTitle">Arzt-Ansicht</strong>

      <div class="center-group">
        <label class="small">Von <input type="date" id="from" style="width:auto"></label>
        <label class="small">Bis <input type="date" id="to" style="width:auto"></label>
        <button class="btn ghost" id="applyRange" type="button">Anwenden</button>
        <button class="btn ghost" id="doctorChartBtn" type="button" title="Werte als Grafik">Werte anzeigen</button>
        <button class="btn ghost" id="doctorExportJson" type="button">Export JSON</button>
      </div>

      <span id="docTrainCnt" class="badge good" title="Anzahl Tage mit Training im Zeitraum">🏋️ Trainingstage: <span class="val">0</span></span>
      <span id="docBadCnt" class="badge bad" title="Anzahl Tage mit mind. einem Bad-Flag">⚠️ Tage mit Bad-Flag: <span class="val">0</span></span>
    </div> <!-- 👈 Toolbar sauber schließen -->

    <div style="overflow:auto" id="doctorDailyWrap">
      <div class="doctor-view" id="doctorView"></div>
    </div>

        <div class="small" style="margin-top:6px">
      Tipp: „Werte anzeigen“ öffnet die passende Grafik zum aktuellen Tab (Daily).
    </div>
  </section>
</section>

<!-- Supabase (UMD, v2) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

<script>
/* ===== Supabase Defaults (ANON only – niemals service_role!) ===== */
const SUPABASE_URL_DEFAULT = "https://jlylmservssinsavlkdi.supabase.co";
const SUPABASE_ANON_DEFAULT = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpseWxtc2VydnNzaW5zYXZsa2RpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNTQ2NjAsImV4cCI6MjA3MDgzMDY2MH0.4BpnwDJAlPohSYLfNcaEJfxQNvlHBbMvxVcCOAWpkFA";
const DEFAULT_WEBHOOK_ENTRIES = `${SUPABASE_URL_DEFAULT}/rest/v1/health_entries`;

/* ===== Fehlerbox ===== */
window.addEventListener('unhandledrejection', (e)=>{
const box = document.getElementById('err');
box.style.display='block';
box.textContent = 'Fehler: ' + (e.reason?.message || e.reason || 'Unbekannter Fehler');
});

/* ===== Diagnostics ===== */
const perfStats = (() => {
const buckets = Object.create(null);
const add = (k, ms) => (buckets[k] ??= []).push(ms);
const pct = (arr, p) => {
if (!arr.length) return 0;
const a = [...arr].sort((x,y)=>x-y);
const i = Math.ceil((p/100)*a.length)-1;
return a[Math.max(0, Math.min(i, a.length-1))];
};
const snap = (k) => {
const arr = buckets[k] || [];
return { count: arr.length, p50: pct(arr,50), p95: pct(arr,95), p99: pct(arr,99) };
};
return { add, snap };
})();

const diag = { el:null, logEl:null, open:false, lines:[],
add(msg){ const t=new Date().toLocaleTimeString(); this.lines.unshift(`[${t}] ${msg}`); this.lines=this.lines.slice(0,80); if(this.logEl) this.logEl.textContent = this.lines.join('\n'); },
init(){ this.el=document.getElementById('diag'); this.logEl=document.getElementById('diagLog');
const t1=document.getElementById('diagToggle'); const t2=document.getElementById('diagToggleFab');
const close=document.getElementById('diagClose');
const toggle=()=>{ this.open=!this.open; this.el.style.display=this.open?'block':'none'; };
t1.addEventListener('click', toggle);
if (t2) t2.addEventListener('click', toggle);
close.addEventListener('click', ()=>{ this.open=false; this.el.style.display='none'; });
}
};

/* ===== Help panel ===== */
const helpPanel={ el:null, open:false,
init(){ this.el=document.getElementById('help');
const t1=document.getElementById('helpToggle'); const t2=document.getElementById('helpToggleFab'); const close=document.getElementById('helpClose');
const toggle=()=>{ this.open=!this.open; this.el.style.display=this.open?'block':'none'; };
t1.addEventListener('click', toggle);
if (t2) t2.addEventListener('click', toggle);
close.addEventListener('click', ()=>{ this.open=false; this.el.style.display='none'; });
}
};

/* ===== Helpers ===== */
// --- DRAFT (Soft Save) ------------------------------
// Key-Format: "draft:YYYY-MM-DD" im CONF-Store
const DRAFT_PREFIX = "draft:";
const draftKeyFor = (dateStr) => `${DRAFT_PREFIX}${dateStr}`;

async function loadDraft(dateStr){
  return await getConf(draftKeyFor(dateStr));
}
async function saveDraft(dateStr, patch){
  const cur = (await loadDraft(dateStr)) || {};
  const next = Object.assign({}, cur, patch, { updatedAt: Date.now() });
  await putConf(draftKeyFor(dateStr), next);
  return next;
}
async function clearDraft(dateStr){
  // Wir setzen den Wert auf null – getConf() liefert dann wieder null
  await putConf(draftKeyFor(dateStr), null);
}

// Zahlen-Parser (DE/AT robust)
const parseNum = (v) => {
  if (v==null || v==="") return null;
  const s = String(v).replace(",", ".");
  const n = Number(s);
  return isNaN(n) ? null : n;
};

// Snapshot ← UI lesen
function readDraftFromUI(){
  return {
    timeM: $("#timeM")?.value || "",
    sysM:  parseNum($("#sysM")?.value),
    diaM:  parseNum($("#diaM")?.value),
    pulseM:parseNum($("#pulseM")?.value),

    timeA: $("#timeA")?.value || "",
    sysA:  parseNum($("#sysA")?.value),
    diaA:  parseNum($("#diaA")?.value),
    pulseA:parseNum($("#pulseA")?.value),

    weight: parseNum($("#weightDay")?.value),
    notes:  ($("#notesDay")?.value || "").trim(),

    // Flags aus State-Variablen
    flags: {
      training:       !!trainingActive,
      lowIntake:      !!lowIntakeActive,
      sick:           !!sickActive,
      valsartanMiss:  !!valsartanMissed,
      forxigaMiss:    !!forxigaMissed,
      nsar:           !!nsarTaken,
      saltHigh:       !!saltHigh,
      sugarHigh:      !!sugarHigh
    }
  };
}

// Draft → UI anwenden
function applyDraftToUI(d){
  if(!d) return;
  if (d.timeM)   $("#timeM").value = d.timeM;
  if (d.sysM!=null)   $("#sysM").value = d.sysM;
  if (d.diaM!=null)   $("#diaM").value = d.diaM;
  if (d.pulseM!=null) $("#pulseM").value = d.pulseM;

  if (d.timeA)   $("#timeA").value = d.timeA;
  if (d.sysA!=null)   $("#sysA").value = d.sysA;
  if (d.diaA!=null)   $("#diaA").value = d.diaA;
  if (d.pulseA!=null) $("#pulseA").value = d.pulseA;

  if (d.weight!=null) $("#weightDay").value = d.weight;
  if (typeof d.notes === "string") $("#notesDay").value = d.notes;

  // Flags über die vorhandenen Setter (UI + State + A11y)
  if (d.flags){
    if ("training"     in d.flags) setTraining(!!d.flags.training);
    if ("lowIntake"    in d.flags) setLowIntake(!!d.flags.lowIntake);
    if ("sick"         in d.flags) setSick(!!d.flags.sick);
    if ("valsartanMiss"in d.flags) setValsartanMiss(!!d.flags.valsartanMiss);
    if ("forxigaMiss"  in d.flags) setForxigaMiss(!!d.flags.forxigaMiss);
    if ("nsar"         in d.flags) setNsar(!!d.flags.nsar);
    if ("saltHigh"     in d.flags) setSaltHigh(!!d.flags.saltHigh);
    if ("sugarHigh"    in d.flags) setSugarHigh(!!d.flags.sugarHigh);
  }
}

// Debounce: Soft Save nach kurzer Tipp-Pause
let __draftTimer = null;
function scheduleDraftSave(){
  if (__draftTimer) clearTimeout(__draftTimer);
  __draftTimer = setTimeout(async ()=>{
    const dateStr = $("#date").value || todayStr();
    await saveDraft(dateStr, readDraftFromUI());
  }, 250);
}

// --- Service-Role-Schutz (NIEMALS im Browser) ---
function isServiceRoleKey(raw){
  const tok = String(raw||"").trim().replace(/^Bearer\s+/i,'');
  try{
    const payload = JSON.parse(atob(tok.split('.')[1].replace(/-/g,'+').replace(/_/g,'/')));
    return payload?.role === 'service_role';
  }catch{
    return false; // Fallback: lieber konservativ sein
  }
}

/* ===== Auth-Guard ===== */
async function isLoggedIn(){
try{
if(!sbClient) return false;
const { data:{ session } } = await sbClient.auth.getSession();
return !!session;
}catch{ return false; }
}

/** Schaltet optisch auf „gesperrt“ – ohne Controls hart zu deaktivieren */
function setAuthGuard(logged){
  // Nur visuelles Dimmen; die Save-Logik prüft isLoggedIn() ohnehin.
  document.body.classList.toggle('auth-locked', !logged);
  // Kein auto-boot mehr hier – Start erfolgt in main()/watchAuthState.
}

const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const fmtNum = (n, d=1) => (n===null||n===undefined||isNaN(n)) ? "" : Number(n).toFixed(d);
const pad2 = n => n.toString().padStart(2,'0');
const todayStr = () => { const d = new Date(); const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; };
const timeStr = () => { const d = new Date(); return pad2(d.getHours())+":"+pad2(d.getMinutes()); };
function esc(s){ return String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function nl2br(s){ return esc(s).replace(/\n/g, "<br>"); }
function calcMAP(sys, dia){ if (sys==null || dia==null) return null; return Number(dia) + (Number(sys)-Number(dia))/3; }
// „Legacy“: Measurement Eintrag, der nur Gewicht enthält
function isWeightOnly(e){
const hasVitals = !!(e?.sys || e?.dia || e?.pulse);
return !hasVitals && (e?.weight != null);
}

function setBusy(on){
document.body.classList.toggle('is-busy', !!on);
const b = document.getElementById('busy');
if (b) b.style.display = on ? 'flex' : 'none';
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function softWarnRange(el, min, max){
const v = Number(el.value);
if (!isNaN(v) && (v < min || v > max)) {
el.style.outline = '2px solid var(--warn)';
} else {
el.style.outline = '';
}
}

/* ===== IndexedDB ===== */
let db;
const DB_NAME = "healthlog_db";
const STORE   = "entries";
const CONF    = "config";

function initDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, 5);

    req.onupgradeneeded = (e)=>{
      db = e.target.result;
      // entries
      if(!db.objectStoreNames.contains(STORE)){
        const s = db.createObjectStore(STORE,{ keyPath:"id", autoIncrement:true });
        s.createIndex("byDateTime","dateTime",{unique:false});
        s.createIndex("byRemote","remote_id",{unique:false});
      } else {
        const s = e.target.transaction.objectStore(STORE);
        try{ s.createIndex("byDateTime","dateTime",{unique:false}); }catch(_){}
        try{ s.createIndex("byRemote","remote_id",{unique:false}); }catch(_){}
      }
      // config
      if(!db.objectStoreNames.contains(CONF)){
        db.createObjectStore(CONF,{ keyPath:"key" });
      }
    };

    req.onsuccess = (e)=>{
      db = e.target.result;
      db.onversionchange = ()=> db?.close?.();
      resolve();
    };
    req.onerror = ()=> reject(req.error || new Error("IndexedDB open failed"));
  });
}

/* --- IDB Helpers (global) --- */
function putConf(key, value){
  return new Promise((res,rej)=>{
    const tx = db.transaction(CONF,"readwrite");
    tx.objectStore(CONF).put({key, value});
    tx.oncomplete = ()=>res();
    tx.onerror = (e)=>rej(e);
  });
}
function getConf(key){
  return new Promise((res,rej)=>{
    const tx = db.transaction(CONF,"readonly");
    const rq = tx.objectStore(CONF).get(key);
    rq.onsuccess = ()=> res(rq.result?.value ?? null);
    rq.onerror   = (e)=> rej(e);
  });
}
function addEntry(obj){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    const rq = tx.objectStore(STORE).add(obj);
    rq.onsuccess = ()=> res(rq.result);
    rq.onerror   = (e)=> rej(e);
  });
}
function updateEntry(id, patch){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    const store = tx.objectStore(STORE);
    const get = store.get(id);
    get.onsuccess = ()=>{
      const cur = get.result; if(!cur){ res(false); return; }
      store.put(Object.assign({}, cur, patch));
    };
    tx.oncomplete = ()=> res(true);
    tx.onerror    = (e)=> rej(e);
  });
}
function getAllEntries(){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readonly");
    const rq = tx.objectStore(STORE).getAll();
    rq.onsuccess = ()=> res(rq.result || []);
    rq.onerror   = (e)=> rej(e);
  });
}
function getEntryByRemoteId(remoteId){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readonly");
    const idx = tx.objectStore(STORE).index("byRemote");
    const rq  = idx.getAll(remoteId);
    rq.onsuccess = ()=> res(rq.result?.[0] ?? null);
    rq.onerror   = (e)=> rej(e);
  });
}
function deleteEntryLocal(id){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    tx.objectStore(STORE).delete(id);
    tx.oncomplete = ()=> res();
    tx.onerror    = (e)=> rej(e);
  });
}

/* ===== Remote (Supabase REST) ===== */
async function getHeaders(){
const key = await getConf("webhookKey");
if (!key || isServiceRoleKey(key)) return null; // NEU: blocken
const anonKey = key.replace(/^Bearer\s+/i, "");

const supa = await ensureSupabaseClient();
if (!supa) return null;

const { data: { session } } = await supa.auth.getSession();
const jwt = session?.access_token;
if (!anonKey || !jwt) return null;

return {
"Content-Type": "application/json",
"apikey": anonKey,
"Authorization": `Bearer ${jwt}`,
"Prefer": "return=representation"
};
}

async function deleteRemote(remote_id){
const url = await getConf("webhookUrl");
const headers = await getHeaders();
if(!url || !headers || !remote_id) return {ok:false};
const q = `${url}?id=eq.${encodeURIComponent(remote_id)}`;
try{
const res = await withRetry(()=> fetch(q, { method:"DELETE", headers }));
return {ok: res.ok, status: res.status};
}catch(e){
return {ok:false, status:0};
}
}
async function pullAllFromRemote(){
const url = await getConf("webhookUrl");
const headers = await getHeaders();
if(!url || !headers) throw new Error("Webhook nicht konfiguriert");
const q = `${url}?select=*&order=ts.asc`;
const res = await fetch(q, { headers });
if(!res.ok) throw new Error(`Fetch fehlgeschlagen (${res.status})`);
return res.json();
}
async function pushPendingToRemote(){
const url = await getConf("webhookUrl");
const headers = await getHeaders();
if(!url || !headers) return { pushed:0, failed:0 };
const all = await getAllEntries();
const pending = all.filter(e=>!e.remote_id);
let pushed=0, failed=0;
for(const e of pending){
try{
const uid = await getUserId();
const { id: _dropLocal, remote_id: _dropRemote, ...safe } = e;
const payload = uid ? { ...safe, user_id: uid } : safe;
const res = await withRetry(()=> fetch(url, { method:"POST", headers, body: JSON.stringify(payload) }));
if(!res.ok){ failed++; continue; }
const json = await res.json();
const rid = json?.[0]?.id;
if(rid){ await updateEntry(e.id, { remote_id: rid }); pushed++; }
else { failed++; }
await sleep(50);
}catch(_){ failed++; }
}
return { pushed, failed };
}

function showLoginBar(show){
const bar = document.getElementById('loginBar');
if (bar) bar.style.display = show ? 'flex' : 'none';
}
function setUserUi(email){
document.getElementById('whoAmI').textContent = email ? `Angemeldet als: ${email}` : '';
document.getElementById('logoutBtn').style.display = email ? '' : 'none';
}

// Buttons binden (einmalig, z. B. in main())
function bindAuthButtons(){
const gbtn = document.getElementById('googleLoginBtn');
const lout = document.getElementById('logoutBtn');

if (gbtn) gbtn.addEventListener('click', async ()=>{
const supa = await ensureSupabaseClient();
if (!supa) { 
alert('Konfiguration fehlt (REST-URL und ANON-Key). Standardwerte sind gesetzt – falls entfernt, bitte App neu laden oder Konfiguration in IndexedDB hinterlegen.');
return;
}
const { error } = await supa.auth.signInWithOAuth({
provider: 'google',
options: { redirectTo: `${window.location.origin}${window.location.pathname}` }
});
if (error) alert('Google-Login fehlgeschlagen: ' + error.message);
});

if (lout) lout.addEventListener('click', async ()=>{
const supa = await ensureSupabaseClient();
if (supa) await supa.auth.signOut();
await teardownRealtime(); // <- Channels sauber schließen
__booted = false; // <- erlaubt späteren Re-Login-Start
setUserUi('');
showLoginBar(true);
setAuthGuard(false);
});
}

// Beim Start Session prüfen
async function requireSession(){
if(!sbClient){
setUserUi('');
showLoginBar(true);
setAuthGuard(false);
return false;
}
const { data: { session } } = await sbClient.auth.getSession();
const email = session?.user?.email || '';
setUserUi(email);
showLoginBar(!session);
setAuthGuard(!!session);
return !!session;
}

// Reagiert auch auf spätere Logins (z. B. nach Redirect)
function watchAuthState(){
sbClient.auth.onAuthStateChange(async (_event, session)=>{
const email = session?.user?.email || '';
setUserUi(email);
showLoginBar(!session);
setAuthGuard(!!session); // <— NEU: UI sperren/freigeben
if (session) {
  await afterLoginBoot(); // Start nach frischem Login
}
});
}

// Alles, was NACH Login laufen soll (deine bestehende Logik)
let __booted = false; // ganz oben im Script oder vor afterLoginBoot definieren

async function afterLoginBoot(){
if (__booted) return; // <- Guard gegen Doppelstart
__booted = true;
await initialAutoSync();
await teardownRealtime();
await setupRealtime();
await renderDoctor();
}

/* ===== CSV/JSON export (Daily) ===== */
function dl(filename, content, mime){
const a = document.createElement("a");
a.href = URL.createObjectURL(new Blob([content], {type:mime}));
a.download = filename;
a.click();
URL.revokeObjectURL(a.href);
}

/* ===== Doctor view ===== */
function setDocBadges({ training, bad, visible } = {}) {
  const t = document.getElementById('docTrainCnt');
  const b = document.getElementById('docBadCnt');
  if (!t || !b) return;

  if (training !== undefined) t.querySelector('.val').textContent = String(training);
  if (bad !== undefined)      b.querySelector('.val').textContent = String(bad);

  if (visible !== undefined) {
    t.classList.toggle('hidden', !visible);
    b.classList.toggle('hidden', !visible);
  }
}

const __t0 = performance.now();
async function renderDoctor(){
const host = $("#doctorView");
if (!host) return;
host.innerHTML = "";

// Helpers (nur Anzeige)
const dash = v => (v === null || v === undefined || v === "" ? "–" : String(v));
const onClass = b => (b ? "on" : "");
const fmtDateDE = (iso) => {
const d = new Date(iso + "T00:00:00");
return d.toLocaleDateString("de-AT", { weekday:"short", day:"2-digit", month:"2-digit", year:"numeric" });
};

// 1) Filter + Sort wie bisher
const from = $("#from").value;
const to = $("#to").value;
const entries = await getAllEntries();
const list = entries
.filter(e => {
if (from && e.date < from) return false;
if (to && e.date > to) return false;
return true;
})
.sort((a,b)=> ((a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime))));

// 2) Tagesobjekte aufbauen (nur Darstellung)
const days = new Map();
for (const e of list){
  // Day-Objekt holen/erzeugen
  let d = days.get(e.date);
  if (!d){
    d = {
      date: e.date,
      morning: { sys:null, dia:null, pulse:null, map:null },
      evening: { sys:null, dia:null, pulse:null, map:null },
      weight: null,
      notes: "",
      flags: { water_lt2:false, salt_gt5:false, sugar_gt10:false, sick:false, meds:false, training:false },
      localIds: [],
      remoteIds: [],
      hasCloud: false
    };
    days.set(e.date, d);
  }

  // IDs & Cloud-Status sammeln
  if (e?.id != null) d.localIds.push(e.id);
  if (e?.remote_id != null) { d.remoteIds.push(e.remote_id); d.hasCloud = true; }

  const legacyWeightOnly = isWeightOnly(e);
  const hasVitals = !!(e.sys || e.dia || e.pulse);
  const isDaySummary = (e.context === "Tag") || legacyWeightOnly;
  const isMeasurement = hasVitals && !isDaySummary;

  // Messblöcke
  if (isMeasurement && e.context === "Morgen"){
    d.morning.sys   = e.sys ?? null;
    d.morning.dia   = e.dia ?? null;
    d.morning.pulse = e.pulse ?? null;
    d.morning.map   = (e.map != null ? e.map : calcMAP(e.sys, e.dia));
  } else if (isMeasurement && e.context === "Abend"){
    d.evening.sys   = e.sys ?? null;
    d.evening.dia   = e.dia ?? null;
    d.evening.pulse = e.pulse ?? null;
    d.evening.map   = (e.map != null ? e.map : calcMAP(e.sys, e.dia));
  }

  // Tageszusammenfassung / Gewicht / Notizen
  if (isDaySummary){
    if (e.weight != null) d.weight = e.weight;
    if (e.notes)          d.notes  = e.notes;
  }

  // Flags
  if (e.training)                         d.flags.training   = true;
  if (e.low_intake)                       d.flags.water_lt2  = true;
  if (e.salt_high)                        d.flags.salt_gt5   = true;
  if (e.sugar_high)                       d.flags.sugar_gt10 = true;
  if (e.sick)                             d.flags.sick       = true;
  if (e.valsartan_missed || e.forxiga_missed || e.nsar_taken) d.flags.meds = true;
}

const daysArr = Array.from(days.values()).sort((a,b)=> a.date.localeCompare(b.date));
 
  // --- KPI: Anzahl Trainingstage und Tage mit mind. einem Bad-Flag
const trainingDays = daysArr.filter(d => !!d.flags.training).length;
const badDays = daysArr.filter(d => {
  const f = d.flags;
  return !!(f.water_lt2 || f.salt_gt5 || f.sugar_gt10 || f.sick || f.meds);
}).length;

// Badges setzen (nur Daily)
setDocBadges({ training: trainingDays, bad: badDays, visible: true });


// 3) Renderer pro Tag (-> 3 Spalten)
const renderDoctorDay = (day) => `
<section class="doctor-day" data-date="${day.date}">
<!-- Spalte A: Datum -->
<!-- Spalte A: Datum (+ Cloud + Löschen) -->
<div class="col-date">
  <div class="date-top">
    <span class="date-label">${fmtDateDE(day.date)}</span>
    <span class="date-cloud" title="In Cloud gespeichert?">${day.hasCloud ? "☁️" : ""}</span>
  </div>
  <div class="date-actions">
    <button class="btn ghost btn-xs" data-del-day="${day.date}">Löschen</button>
  </div>
</div>

<!-- Spalte B: Messungen -->
<div class="col-measure">
<div class="measure-head">
<div></div>
<div>Sys</div><div>Dia</div><div>Puls</div><div>MAP</div>
</div>
<div class="measure-grid">
<div class="measure-row">
<div class="label">morgens</div>
<div class="num ${ (day.morning.sys!=null && day.morning.sys>130) ? 'alert' : '' }">${dash(day.morning.sys)}</div>
<div class="num ${ (day.morning.dia!=null && day.morning.dia>90)  ? 'alert' : '' }">${dash(day.morning.dia)}</div>
<div class="num">${dash(day.morning.pulse)}</div>
<div class="num ${ (day.morning.map!=null && day.morning.map>100) ? 'alert' : '' }">${dash(fmtNum(day.morning.map))}</div>
</div>
<div class="measure-row">
<div class="label">abends</div>
<div class="num ${ (day.evening.sys!=null && day.evening.sys>130) ? 'alert' : '' }">${dash(day.evening.sys)}</div>
<div class="num ${ (day.evening.dia!=null && day.evening.dia>90)  ? 'alert' : '' }">${dash(day.evening.dia)}</div>
<div class="num">${dash(day.evening.pulse)}</div>
<div class="num ${ (day.evening.map!=null && day.evening.map>100) ? 'alert' : '' }">${dash(fmtNum(day.evening.map))}</div>
</div>
</div>
</div>

<!-- Spalte C: Spezial -->
<div class="col-special">
<div class="weight-line">
<div>Gewicht</div>
<div class="num">${dash(fmtNum(day.weight))}</div>
</div>

<div class="flags">
<div class="flag"><span class="flag-box ${onClass(day.flags.water_lt2)}"></span><span>&lt;2L Wasser</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.salt_gt5)}"></span><span>Salz &gt;5g</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.sugar_gt10)}"></span><span>Zucker &gt;10g</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.sick)}"></span><span>Krank</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.meds)}"></span><span>Medikamente</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.training)}"></span><span>Training</span></div>
</div>

<div class="notes">${nl2br((day.notes || "").trim() || "–")}</div>
</div>
</section>
`;

// 4) Rendern oder Leerzustand
if (!daysArr.length){
  host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Keine Einträge im Zeitraum</div>`;
} else {
  host.innerHTML = daysArr.map(renderDoctorDay).join("");

  // 🔹 Tages-Löschbuttons (löscht ALLE Einträge dieses Datums – lokal + remote)
  host.querySelectorAll('[data-del-day]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const date = btn.getAttribute('data-del-day');
      if (!date) return;
      if (!confirm(`Alle Einträge für ${date} löschen? (Cloud-Einträge werden – falls möglich – mitgelöscht)`)) return;

      btn.disabled = true;
      const old = btn.textContent;
      btn.textContent = 'Lösche…';

      try{
        const all = await getAllEntries();
        const ofDay = all.filter(e => e.date === date);
        // 1) Remote löschen (falls remote_id vorhanden)
        for (const e of ofDay){
          if (e.remote_id){
            const r = await deleteRemote(e.remote_id);
            if (!r.ok){
              alert(`Server-Löschung fehlgeschlagen (${r.status||"?"}) für einen Eintrag am ${date}. Vorgang abgebrochen.`);
              btn.disabled = false; btn.textContent = old;
              return;
            }
          }
        }
        // 2) Lokal löschen
        for (const e of ofDay){
          await deleteEntryLocal(e.id);
        }
        // 3) UI aktualisieren
        await renderDoctor();
        if (chartPanel.open) chartPanel.draw();
      } finally {
        btn.disabled = false;
        btn.textContent = old;
      }
    });
  });
}
}

/* ===== Simple SVG Chart (Daily) ===== */
const chartPanel = {
  el:null, svg:null, legend:null, open:false, tip:null, tipSticky:false,
  init(){
    this.el = $("#chart");
    this.svg = $("#chartSvg");
    this.el.style.display = 'none';
    this.legend = $("#chartLegend");
    $("#chartClose").addEventListener("click", ()=>this.hide());
    $("#metricSel").addEventListener("change", ()=> this.draw());

    // Tooltip (hover/click)
    const contentHost = this.el.querySelector(".content") || this.el;
    const tip = document.createElement("div");
    Object.assign(tip.style, {
      position:"absolute", inset:"auto auto auto auto", transform:"translate(8px,8px)",
      display:"none", pointerEvents:"none", zIndex:2,
      background:"#10131a", border:"1px solid #2b2f3a", borderRadius:"8px",
      padding:"8px 10px", fontSize:"12px", lineHeight:"1.35", maxWidth:"280px",
      boxShadow:"0 6px 18px rgba(0,0,0,.35)", color:"var(--fg)"
    });
    tip.id = "chartTip";
    contentHost.style.position = "relative";
    contentHost.appendChild(tip);
    this.tip = tip;

    // Interaktivität auf dem SVG
this.svg.addEventListener("pointermove", (e)=>{
  if (this.tipSticky) return; // bei Sticky nicht folgen
  const tgt = e.target;
  const hasNote = tgt && tgt.classList.contains("pt") && tgt.getAttribute("data-note");
  if (!hasNote) { this.hideTip(); return; }
  this.fillTipFromTarget(tgt);
  this.positionTip(e);
});

    this.svg.addEventListener("pointerleave", ()=>{
      if (this.tipSticky) return;
      this.hideTip();
    });
    // Click/Tap: Tooltip toggeln (mobil-freundlich)
this.svg.addEventListener("click", (e)=>{
  const tgt = e.target;
  const hasNote = tgt && tgt.classList.contains("pt") && tgt.getAttribute("data-note");
  if (!hasNote) {
    // Klick ins Leere oder auf Punkt ohne Notiz -> Sticky aus
    if (this.tipSticky) { this.tipSticky = false; this.hideTip(); }
    return;
  }
  this.fillTipFromTarget(tgt);
  this.tipSticky = !this.tipSticky;
  this.positionTip(e);
});

    // Resize/Orientation -> neu zeichnen, wenn offen
    const ro = new ResizeObserver(() => { if (this.open) this.draw(); });
    ro.observe(this.el);
    this._ro = ro;
    window.addEventListener('orientationchange', () => {
      setTimeout(() => { if (this.open) this.draw(); }, 150);
    });
  },
  toggle(){ this.open = !this.open; this.el.style.display = this.open ? 'block' : 'none'; },
  hide(){ this.open = false; this.el.style.display = 'none'; this.tipSticky = false; this.hideTip(); },

  async getFiltered(){
    const entries = await getAllEntries();
    const from = $("#from").value;
    const to   = $("#to").value;
    return entries
      .filter(e=>{
        if (from && e.date < from) return false;
        if (to   && e.date > to)   return false;
        return true;
      })
      .sort((a,b)=> ((a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime))));
  },

  // Tooltip-Helfer
  hideTip(){ if (this.tip){ this.tip.style.display = "none"; this.tip.textContent = ""; } },
  positionTip(e){
    if (!this.tip) return;
    const hostRect = (this.el.querySelector(".content") || this.el).getBoundingClientRect();
    const x = e.clientX - hostRect.left;
    const y = e.clientY - hostRect.top;
    this.tip.style.left = `${x + 10}px`;
    this.tip.style.top  = `${y + 10}px`;
    if (this.tip.style.display !== "block") this.tip.style.display = "block";
  },
fillTipFromTarget(tgt){
  if (!this.tip) return;
  const note = tgt.getAttribute("data-note") || "";
  if (!note) { this.hideTip(); return; }
  // Nur den Kommentar anzeigen – keine Werte, kein Header
  this.tip.innerHTML = `<div style="white-space:pre-wrap">${esc(note)}</div>`;
},

  async draw(){
    const t0 = performance.now();
    const metric = $("#metricSel").value;
    const data   = await this.getFiltered();

    // Basis-X: alle (fallback)
    const xsAll  = data.map(e => (e.ts ?? Date.parse(e.dateTime)));
    let series = [];
    let X = xsAll;

    // KPI-Box
    const avgBox = $("#chartAverages");

    // Schwellen (nur BP)
    const TH_SYS = 130;
    const TH_DIA = 90;

    // Map der Tages-Kommentare (erste Zeile)
    const notesByDate = new Map();
    for (const e of data){
      const hasDayLike = (e.context === "Tag") || isWeightOnly(e);
      const txt = (e.notes || "").trim();
      if (hasDayLike && txt){
        const firstLine = txt.split(/\r?\n/)[0].trim();
        if (firstLine) notesByDate.set(e.date, firstLine);
      }
    }

    // Für BP brauchen wir die Messungs-Meta je Index
    let meta = null;

    if (metric === "bp") {
      // Nur echte Messungen (kein „Tag“/Gewicht-only)
      const mData = data.filter(e =>
        (e.context === "Morgen" || e.context === "Abend") &&
        (e.sys != null || e.dia != null)
      );

      // Meta-Infos je Punktindex (für Tooltip)
      meta = mData.map(e=>({
        date: e.date,
        ctx:  e.context,                  // "Morgen" | "Abend"
        sys:  (e.sys!=null?Number(e.sys):null),
        dia:  (e.dia!=null?Number(e.dia):null),
        note: (notesByDate.get(e.date) || "")
      }));

      // X auf Tagesebene (00:00) -> alle Punkte je Tag bündig
      const xsBP = mData.map(e => new Date(e.date + "T00:00:00").getTime());

      // Vier Reihen (Werte-Arrays, aber Index passt zu meta)
      const sysM = mData.map(e => (e.context==="Morgen" && e.sys!=null) ? Number(e.sys) : null);
      const sysA = mData.map(e => (e.context==="Abend"  && e.sys!=null) ? Number(e.sys) : null);
      const diaM = mData.map(e => (e.context==="Morgen" && e.dia!=null) ? Number(e.dia) : null);
      const diaA = mData.map(e => (e.context==="Abend"  && e.dia!=null) ? Number(e.dia) : null);

      // KPIs (ø über alle Messungen, unabhängig M/A)
      const mapArr = mData.map(e => (e.sys!=null && e.dia!=null) ? (Number(e.dia)+(Number(e.sys)-Number(e.dia))/3) : null);
      const avg = a => { const v=a.filter(x=>x!=null); return v.length ? v.reduce((p,c)=>p+c,0)/v.length : null; };
      if (avgBox){
        const avgSys = avg(mData.map(e=>e.sys!=null?Number(e.sys):null));
        const avgDia = avg(mData.map(e=>e.dia!=null?Number(e.dia):null));
        const avgMap = avg(mapArr);
        if (avgSys!=null || avgDia!=null || avgMap!=null){
          avgBox.style.display="inline-flex";
          const f0 = v => v==null ? "–" : Math.round(v).toString();
          avgBox.querySelector('[data-k="sys"]').textContent = `Durchschnitt Sys: ${f0(avgSys)}`;
          avgBox.querySelector('[data-k="dia"]').textContent = `Durchschnitt Dia: ${f0(avgDia)}`;
          avgBox.querySelector('[data-k="map"]').textContent = `Durchschnitt MAP: ${f0(avgMap)}`;
        } else { avgBox.style.display="none"; }
      }

      series = [
        { name:"Sys Morgens", values: sysM, color:"#93c5fd", type:"sys" },
        { name:"Sys Abends",  values: sysA, color:"#2563eb", type:"sys" },
        { name:"Dia Morgens", values: diaM, color:"#f9a8d4", type:"dia" },
        { name:"Dia Abends",  values: diaA, color:"#db2777", type:"dia" },
      ];

      X = xsBP; // wichtig: ab hier überall dieses X verwenden
    } else if (metric === "pulse") {
      if (avgBox) avgBox.style.display="none";
      series = [{ name:"Puls", values: data.map(e=>e.pulse!=null?Number(e.pulse):null), color:"#34d399", type:"misc" }];
    } else if (metric === "weight") {
      if (avgBox) avgBox.style.display="none";
      series = [{ name:"Gewicht (kg)", values: data.map(e=>e.weight!=null?Number(e.weight):null), color:"#f59e0b", type:"misc" }];
    }

    // --- Render-Prep ---
    this.svg.innerHTML = ""; this.legend.innerHTML = "";
    if (!this.tipSticky) this.hideTip();
    const hasAny = series.some(s => s.values.some(v=>v!=null));
    if (!hasAny){
      this.svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Keine darstellbaren Werte</text>`;
      return;
    }

    // Dynamische Größe
    const bbox = this.svg.getBoundingClientRect();
    const W = Math.max(300, Math.floor(bbox.width  || 640));
    const H = Math.max(200, Math.floor(bbox.height || 280));
    this.svg.setAttribute("viewBox", `0 0 ${W} ${H}`);

    const PL=48, PR=16, PT=12, PB=28;
    const innerW = W-PL-PR, innerH = H-PT-PB;

    const xVals = X.filter(Boolean);
    const xmin = Math.min(...xVals), xmax = Math.max(...xVals);
    const allY = series.flatMap(s => s.values.filter(v=>v!=null));
    const ymin = Math.min(...allY), ymax = Math.max(...allY);
    const ypad = Math.max((ymax-ymin)*0.08, 1);
    const y0 = ymin-ypad, y1 = ymax+ypad;

    const x = t => PL + ((t - xmin)/Math.max(1,(xmax-xmin))) * innerW;
    const y = v => PT + (1 - ((v - y0)/Math.max(1,(y1 - y0)))) * innerH;

    const line = (x1,y1,x2,y2, stroke, dash="") =>
      `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="1" ${dash?`stroke-dasharray="${dash}"`:""} />`;
    const text = (tx,ty,str,anchor="end") =>
      `<text x="${tx}" y="${ty}" fill="#9aa3af" font-size="11" text-anchor="${anchor}">${esc(str)}</text>`;

    // Grid + Labels
    let grid = "";
    const ticks = 9;
    for(let i=0;i<=ticks;i++){
      const vv = y0 + (i*(y1-y0)/ticks);
      const yy = y(vv);
      grid += line(PL,yy,W-PR,yy,"#2a3140");
      grid += text(PL-6,yy+4, Math.round(vv).toString());
    }
    // vertikale Wochenlinien + Datum unten
    const week = 7*24*3600*1000;
    let start = xmin - (xmin % week) + week;
    for(let t=start; t<xmax; t+=week){
      const xx = x(t);
      grid += line(xx,PT,xx,H-PB,"#1b1f28","3 3");
      const d = new Date(t);
      const lbl = `${pad2(d.getDate())}.${pad2(d.getMonth()+1)}.`;
      grid += text(xx, H-8, lbl, "middle");
    }
    // Achsen
    grid += line(PL,PT,PL,H-PB,"#2b2f3a");
    grid += line(PL,H-PB,W-PR,H-PB,"#2b2f3a");

    // Schwellenlinien (nur bei BP)
    if (metric === "bp") {
      const ySys = y(TH_SYS);
      const yDia = y(TH_DIA);
      grid += line(PL,ySys,W-PR,ySys,"#ef4444","6 4"); // dezent gestrichelt
      grid += line(PL,yDia,W-PR,yDia,"#ef4444","6 4");
      // kleine Labels rechts
      grid += text(W-PR+2, ySys+4, "Sys 130", "start");
      grid += text(W-PR+2, yDia+4, "Dia 90", "start");
    }

    this.svg.insertAdjacentHTML("beforeend", grid);

    // Linien + Punkte
    const mkPath = (values, color)=>{
      let d=""; values.forEach((v,i)=>{ if(v==null || !X[i]) return;
        d += (d===""?"M":"L") + `${x(X[i]).toFixed(1)},${y(v).toFixed(1)} `;
      });
      return `<path d="${d}" fill="none" stroke="${color}" stroke-width="2.2" />`;
    };

    const mkDots = (values, color, kind)=>{
      // kind: "sys" | "dia" | "misc"
      let out="";
      values.forEach((v,i)=>{
        if(v==null || !X[i]) return;
        const cx = x(X[i]).toFixed(1), cy = y(v).toFixed(1);
        let date="", ctx="", note="";
        if (metric==="bp" && meta){
          // meta[i] existiert immer für BP
          const m = meta[i];
          date = m?.date || "";
          ctx  = m?.ctx  || "";
          // An dieser Stelle Note nur setzen, wenn Schwelle gerissen ODER Note existiert
          note = m?.note || "";
        }
        out += `<circle class="pt" cx="${cx}" cy="${cy}" r="2.6" fill="${color}"
                    data-kind="${kind}" data-val="${v}" data-date="${esc(date)}" data-ctx="${esc(ctx)}"
                    data-note="${esc(note)}" />`;
      });
      return out;
    };

    // Hervorhebungs-Punkte (größer + rot) für Grenzüberschreitungen
    const mkAlertDots = (seriesItem)=>{
      if (metric !== "bp") return "";
      const isSys = seriesItem.type === "sys";
      const thr = isSys ? TH_SYS : TH_DIA;
      const kind = isSys ? "sys" : "dia";
      let out="";
      seriesItem.values.forEach((v,i)=>{
        if(v==null || !X[i]) return;
        if (v > thr){
          const cx = x(X[i]).toFixed(1), cy = y(v).toFixed(1);
          // Tooltip-Daten mitgeben (inkl. Notiz)
          const m = meta?.[i] || {};
          out += `<circle class="pt" cx="${cx}" cy="${cy}" r="5.2" fill="#ef4444" stroke="#000" stroke-width="0.8"
                     data-kind="${kind}" data-val="${v}"
                     data-date="${esc(m.date||"")}" data-ctx="${esc(m.ctx||"")}"
                     data-note="${esc(m.note||"")}" />`;
        }
      });
      return out;
    };

    // Zeichnen
    series.forEach(s=>{
      this.svg.insertAdjacentHTML("beforeend", mkPath(s.values, s.color));
      this.svg.insertAdjacentHTML("beforeend", mkDots(s.values, s.color, (s.type==="sys"||s.type==="dia")?s.type:"misc"));
      if (metric === "bp") {
        this.svg.insertAdjacentHTML("beforeend", mkAlertDots(s));
      }
      // Legende
      const wrap = document.createElement("span");
      wrap.style.display="inline-flex"; wrap.style.alignItems="center"; wrap.style.gap="6px";
      const dot = Object.assign(document.createElement("span"), { className:"dot" });
      dot.style.background = s.color;
      const label = document.createElement("span"); label.textContent = s.name;
      wrap.append(dot, label); this.legend.appendChild(wrap);
    });

    // Wenn wir im Sticky-Modus sind und gerade neu gezeichnet haben, Tooltip ausblenden (der Punkt ist evtl. weg)
    if (this.tipSticky) { this.tipSticky = false; this.hideTip(); }

    const sPerf = (perfStats.add('drawChart', performance.now()-t0), perfStats.snap('drawChart'));
    diag.add(`[perf] drawChart p50=${sPerf.p50|0}ms p95=${sPerf.p95|0}ms p99=${sPerf.p99|0}ms (n=${sPerf.count})`);
  }
};
  
/* --- Button-Flash --- */
let saveFlashTimer = null;
function flashSaveOk(){
const btn = document.getElementById('saveAllBtn');
if(!btn) return;
if (saveFlashTimer) { clearTimeout(saveFlashTimer); saveFlashTimer = null; }
btn.disabled = true; btn.classList.add('flash'); btn.innerHTML = '✔️ Gespeichert';
saveFlashTimer = setTimeout(()=>{ btn.classList.remove('flash'); btn.innerHTML = '💾 Speichern'; btn.disabled = false; saveFlashTimer = null; }, 1000);
}

/* ===== Tabs / Segments ===== */
function setTab(name){
  $$(".view").forEach(v => v.classList.remove("active"));
  $("#"+name).classList.add("active");
  $$(".tabs .btn").forEach(b =>
    b.classList.toggle("primary", b.dataset.tab === name)
  );
    // 👇 Zusatz: Panels schließen, wenn ich Tab wechsle
  if (typeof chartPanel?.hide === "function") chartPanel.hide();
  if (helpPanel?.el) { helpPanel.open = false; helpPanel.el.style.display = 'none'; }
  if (diag?.el)     { diag.open = false;     diag.el.style.display = 'none'; }

  if (name === "doctor") { renderDoctor(); }
}
  
function bindTabs(){
  $$(".tabs .btn").forEach(b =>
    b.addEventListener("click", e => setTab(e.currentTarget.dataset.tab))
  );
}
  
/* ===== Save flows ===== */
let trainingActive=false, lowIntakeActive=false, sickActive=false, valsartanMissed=false, forxigaMissed=false, nsarTaken=false,
saltHigh=false, sugarHigh=false;
function setToggle(el, on, activeText, baseText){
el.classList.toggle("active", !!on);
el.setAttribute("aria-pressed", on ? "true" : "false");
el.textContent = on ? activeText : baseText;
}
function setTraining(on){ trainingActive=!!on; setToggle($("#trainingToggle"), trainingActive, "🏋️ Training heute (aktiv)", "🏋️ Training heute"); }
function setLowIntake(on){ lowIntakeActive=!!on; setToggle($("#lowIntakeToggle"), lowIntakeActive, "🚰 < 2 L – aktiv", "🚰 < 2 L getrunken"); }
function setSaltHigh(on){ saltHigh = !!on; setToggle($("#saltHighToggle"), saltHigh, "🧂 > 5 g Salz – aktiv", "🧂 > 5 g Salz"); }
function setSugarHigh(on){ sugarHigh = !!on; setToggle($("#sugarHighToggle"), sugarHigh, "🍬 > 10 g Zucker – aktiv", "🍬 > 10 g Zucker"); }

function setSick(on){
sickActive=!!on; setToggle($("#sickToggle"), sickActive, "🤒 Krank (Forxiga pausiert) – aktiv", "🤒 Krank (Forxiga pausiert)");
if(sickActive){ setForxigaMiss(true); $("#forxigaMissToggle").disabled=true; $("#forxigaMissToggle").style.opacity=0.6; }
else { $("#forxigaMissToggle").disabled=false; $("#forxigaMissToggle").style.opacity=1; }
}
function setValsartanMiss(on){ valsartanMissed=!!on; setToggle($("#valsartanMissToggle"), valsartanMissed, "💊 Valsartan vergessen – aktiv", "💊 Valsartan vergessen"); }
function setForxigaMiss(on){ forxigaMissed=!!on; setToggle($("#forxigaMissToggle"), forxigaMissed, "💊 Forxiga vergessen – aktiv", "💊 Forxiga vergessen"); }
function setNsar(on){ nsarTaken=!!on; setToggle($("#nsarToggle"), nsarTaken, "⚠️ NSAR genommen – aktiv", "⚠️ NSAR genommen"); }
function blockHasData(which){
return !!(
$(`#time${which}`).value ||
$(`#sys${which}`).value ||
$(`#dia${which}`).value ||
$(`#pulse${which}`).value
);
}
async function saveAll(){
const __t0 = performance.now();
if(!(await isLoggedIn())){ alert("Bitte zuerst mit Google anmelden."); return; }

// ⤵️ Vor dem Speichern: Draft laden und auf die UI anwenden,
// damit die bestehende Logik (needsComment, hasM/hasA ...) sauber greift.
const todayDate = $("#date").value || todayStr();
const draft = await loadDraft(todayDate);
if (draft) applyDraftToUI(draft);

// 1) Erkennen, was heute eingegeben wurde
const hasM = blockHasData("M"); 
const hasA = blockHasData("A"); 
const weightVal = $("#weightDay")?.value?.trim();
const notes = ($("#notesDay").value || "").trim();
const hasAnyFlag = !!(trainingActive || lowIntakeActive || sickActive ||
valsartanMissed || forxigaMissed || nsarTaken ||
saltHigh || sugarHigh);
const hasDaySummary = !!(weightVal || hasAnyFlag || notes);

// 🔴 NEU: Kommentarpflicht bei Grenzwertüberschreitung
const sysM = Number($("#sysM").value);
const diaM = Number($("#diaM").value);
const sysA = Number($("#sysA").value);
const diaA = Number($("#diaA").value);

const needsComment = 
  (sysM > 130) || (diaM > 90) ||
  (sysA > 130) || (diaA > 90);

const notesEl = $("#notesDay");
notesEl.style.outline = ""; // Reset

if (needsComment && !notes) {
  alert("Bitte Kommentar eingeben bei Grenzwertüberschreitung (Sys>130 oder Dia>90).");
  notesEl.focus();
  notesEl.style.outline = "2px solid var(--danger)";
  return;
}

// 2) Speichern in drei klaren Pfaden
let saved = false;
if (hasM) saved = (await saveBlock("Morgen","M", /*includeWeight=*/false, /*force=*/false)) || saved;
if (hasA) saved = (await saveBlock("Abend","A", /*includeWeight=*/false, /*force=*/false)) || saved;
if (hasDaySummary) saved = (await saveDaySummary()) || saved;

if (!saved) { alert("Keine Daten eingegeben – nichts zu speichern."); return; }

// 3) UI aktualisieren
await renderDoctor();
if(chartPanel.open) await chartPanel.draw();

{ const s = (perfStats.add('saveEntry', performance.now()-__t0), perfStats.snap('saveEntry'));
diag.add(`[perf] saveEntry p50=${s.p50|0}ms p95=${s.p95|0}ms p99=${s.p99|0}ms (n=${s.count})`); }

// ⤵️ Nach erfolgreichem Finalisieren: Tages-Draft löschen
try { await clearDraft(todayDate); } catch(_){}

flashSaveOk();
}

async function saveBlock(contextLabel, which, includeWeight=false, force=false){
const date = $("#date").value || todayStr();
const time = $(`#time${which}`).value || timeStr();

const sys = $(`#sys${which}`).value ? Number($(`#sys${which}`).value) : null;
const dia = $(`#dia${which}`).value ? Number($(`#dia${which}`).value) : null;
const pulse = $(`#pulse${which}`).value ? Number($(`#pulse${which}`).value) : null;

// Nur vitale Werte; Gewicht NICHT mehr in M/A
const weight = null;

const nothingToSave = !sys && !dia && !pulse;
if (!force && nothingToSave) return false;

const currentISO = new Date(date + "T" + time).toISOString();
const ts = new Date(date + "T" + time).getTime();

const entry = {
date, time, dateTime: currentISO, ts,
context: contextLabel, arm: "links", position: "sitzend",
sys, dia, pulse, weight,
map: (sys!=null && dia!=null) ? calcMAP(sys, dia) : null,
notes: "",
training: false,
low_intake: false,
sick: false,
valsartan_missed: false,
forxiga_missed: false,
nsar_taken: false,
salt_high: false,
sugar_high: false
};

const localId = await addEntry(entry);
await syncWebhook(entry, localId);
return true;
}

function baseEntry(date, time, contextLabel){
const iso = new Date(date + "T" + time).toISOString();
const ts = new Date(date + "T" + time).getTime();
return {
date, time, dateTime: iso, ts,
context: contextLabel, arm: "links", position: "sitzend",
sys: null, dia: null, pulse: null, weight: null, map: null,
notes: ($("#notesDay").value || "").trim(),
training: trainingActive,
low_intake: lowIntakeActive,
sick: sickActive,
valsartan_missed: valsartanMissed,
forxiga_missed: forxigaMissed,
nsar_taken: nsarTaken,
salt_high: saltHigh,
sugar_high: sugarHigh
};
}

async function saveDaySummary(){
const date = $("#date").value || todayStr();
const time = $("#timeA").value || "19:00";

const entry = baseEntry(date, time, "Tag");
const w = $("#weightDay")?.value?.trim();
entry.weight = w ? Number(w) : null;

const hasContent =
(entry.weight != null) ||
!!entry.notes ||
entry.training || entry.low_intake || entry.sick ||
entry.valsartan_missed || entry.forxiga_missed ||
entry.nsar_taken || entry.salt_high || entry.sugar_high;

if (!hasContent) return false;

const localId = await addEntry(entry);
await syncWebhook(entry, localId);
return true;
}

async function withRetry(fn, {tries=3, base=300}={}) {
let lastErr;
for (let i=0;i<tries;i++){
try { return await fn(); }
catch (e) {
const code = e?.status ?? e?.response?.status ?? 0;
if (!(code >= 500 && code < 600)) throw e;
await new Promise(r => setTimeout(r, base * Math.pow(2,i)));
lastErr = e;
}
}
throw lastErr;
}
async function syncWebhook(entry, localId){
const url = await getConf("webhookUrl");
const headers = await getHeaders();
if(!url || !headers) return;
try{
const uid = await getUserId();
const { id: _d1, remote_id: _d2, ...safe } = entry;
const payload = uid ? { ...safe, user_id: uid } : safe;
const res = await withRetry(()=> fetch(url, { method:"POST", headers, body: JSON.stringify(payload) }));
if(!res.ok){
const txt = await res.text().catch(()=>'?');
diag.add(`Webhook-Fehler ${res.status}: ${txt}`);
return;
}
const json = await res.json();
const remoteId = json?.[0]?.id;
if(remoteId!=null){
await updateEntry(localId, { remote_id: remoteId });
diag.add("Webhook: OK");
}
}catch(e){
diag.add("Webhook: Netzwerkfehler");
}
}

/* ===== Realtime / Auto-Sync ===== */
  async function reconcileFromRemote(){
  const remoteRows = await pullAllFromRemote();
  const seen = new Set(remoteRows.map(r => r.id));

  for(const r of remoteRows){
    const mapped = {
      date: r.date, time: r.time, dateTime: r.dateTime, ts: r.ts, context: r.context,
      arm: r.arm, position: r.position, sys: r.sys, dia: r.dia, pulse: r.pulse,
      weight: r.weight, map: r.map, notes: r.notes,
      training: r.training, low_intake: r.low_intake, sick: r.sick,
      valsartan_missed: r.valsartan_missed, forxiga_missed: r.forxiga_missed, nsar_taken: r.nsar_taken,
      salt_high: r.salt_high, sugar_high: r.sugar_high,
      remote_id: r.id
    };
    const existing = await getEntryByRemoteId(r.id);
    if (existing) await updateEntry(existing.id, mapped);
    else          await addEntry(mapped);
  }

  // lokale Leichen entfernen
  const allLocal = await getAllEntries();
  for (const e of allLocal){
    if (e.remote_id && !seen.has(e.remote_id)) await deleteEntryLocal(e.id);
  }

  await renderDoctor();
  if (chartPanel.open) await chartPanel.draw();
}

let sbClient = null;

let __channels = [];
function trackChannel(ch){ __channels.push(ch); return ch; }
function teardownRealtime(){
try{
__channels.forEach(ch => ch.unsubscribe?.());
diag.add(`Realtime: ${__channels.length} Channel(s) unsubscribed`);
}catch(e){ diag.add("Realtime: unsubscribe error"); }
__channels = [];
}

window.addEventListener('beforeunload', teardownRealtime);


function baseUrlFromRest(restUrl){
if(!restUrl) return null;
const i = restUrl.indexOf("/rest/");
return i>0 ? restUrl.slice(0, i) : null;
}

async function getUserId(){
try{
const supa = await ensureSupabaseClient();
if(!supa) return null;
const { data: { user } } = await supa.auth.getUser();
return user?.id ?? null;
}catch{ return null; }
}

async function ensureSupabaseClient(){
if (sbClient) return sbClient;

const rest = await getConf("webhookUrl");
const keyConf = await getConf("webhookKey"); // ANON key (nicht service_role)
if (!rest || !keyConf) { diag.add("Supabase Auth: fehlende Konfiguration"); return null; }

// NEU: niemals mit service_role starten
if (isServiceRoleKey(keyConf)) {
diag.add("Sicherheitsblock: service_role Key erkannt – Abbruch");
return null;
}

const supabaseUrl = baseUrlFromRest(rest);
const anonKey = keyConf.replace(/^Bearer\s+/i,"");
if (!supabaseUrl || !anonKey) { diag.add("Supabase Auth: ungültige URL/Key"); return null; }

sbClient = window.supabase.createClient(supabaseUrl, anonKey, {
auth: { persistSession:true, autoRefreshToken:true, detectSessionInUrl:true }
});
diag.add("Supabase: Client (Auth) initialisiert");
return sbClient;
}

async function setupRealtime(){
const supa = await ensureSupabaseClient();
const uid = await getUserId();
if(!supa) return;
if(!uid) return;

// health_entries
trackChannel(
supa.channel('ch_health_entries')
.on('postgres_changes', {
  event: '*', schema: 'public', table: 'health_entries',
  filter: `user_id=eq.${uid}`
}, async (payload)=>{
const et = payload.eventType; const n = payload.new; const o = payload.old;
if(et === 'INSERT' || et === 'UPDATE'){
const row = n;
const mapped = {
date: row.date, time: row.time, dateTime: row.dateTime, ts: row.ts, context: row.context,
arm: row.arm, position: row.position, sys: row.sys, dia: row.dia, pulse: row.pulse,
weight: row.weight, map: row.map, notes: row.notes,
training: row.training, low_intake: row.low_intake, sick: row.sick,
valsartan_missed: row.valsartan_missed, forxiga_missed: row.forxiga_missed, nsar_taken: row.nsar_taken,
salt_high: row.salt_high, sugar_high: row.sugar_high, // <<< hinzufügen
remote_id: row.id
};
const existing = await getEntryByRemoteId(row.id);
if(existing){ await updateEntry(existing.id, mapped); }
else{ await addEntry(mapped); }
await renderDoctor();
if(chartPanel.open) chartPanel.draw();
diag.add(`Realtime health_entries: ${et}`);
}
if(et === 'DELETE'){
const rid = o?.id;
if(rid!=null){
const existing = await getEntryByRemoteId(rid);
if(existing){ await deleteEntryLocal(existing.id); }
await renderDoctor();
if(chartPanel.open) chartPanel.draw();
diag.add("Realtime health_entries: DELETE");
}
}
})
.subscribe((status)=>{ if(status==='SUBSCRIBED') diag.add("Realtime health_entries: subscribed"); })
);

// Daily
const remoteRows = await pullAllFromRemote();
const seen = new Set(remoteRows.map(r=>r.id));
for(const r of remoteRows){
const mapped = {
date: r.date, time: r.time, dateTime: r.dateTime, ts: r.ts, context: r.context,
arm: r.arm, position: r.position, sys: r.sys, dia: r.dia, pulse: r.pulse,
weight: r.weight, map: r.map, notes: r.notes,
training: r.training, low_intake: r.low_intake, sick: r.sick,
valsartan_missed: r.valsartan_missed, forxiga_missed: r.forxiga_missed, nsar_taken: r.nsar_taken,
salt_high: r.salt_high, sugar_high: r.sugar_high, // <<< hinzufügen
remote_id: r.id
};

const existing = await getEntryByRemoteId(r.id);
if(existing){ await updateEntry(existing.id, mapped); }
else { await addEntry(mapped); }
}
// Entferne lokale Einträge, die serverseitig gelöscht wurden
const allLocal = await getAllEntries();
for(const e of allLocal){
if(e.remote_id && !seen.has(e.remote_id)){ await deleteEntryLocal(e.id); }
}
await renderDoctor();
if(chartPanel.open) chartPanel.draw();
}
async function initialAutoSync(){
const headers = await getHeaders();
const url = await getConf("webhookUrl");
if(!headers || !url){ diag.add("Auto-Sync: keine Konfiguration – übersprungen"); return; }
setBusy(true);
try{
const push = await pushPendingToRemote();
if(push.pushed || push.failed) diag.add(`Auto-Push: OK=${push.pushed}, FAIL=${push.failed}`);
await reconcileFromRemote();
diag.add("Auto-Sync: Abgleich fertig (ohne Wipe)");
}catch(e){
diag.add("Auto-Sync: Fehler – " + (e.message||e));
}finally{
setBusy(false);
}
}

/* ===== Main ===== */
async function main(){
diag.init(); helpPanel.init(); await initDB();
try {
const haveUrl = await getConf("webhookUrl");
const haveKey = await getConf("webhookKey");
if (!haveUrl && SUPABASE_URL_DEFAULT) await putConf("webhookUrl", DEFAULT_WEBHOOK_ENTRIES);
if (!haveKey && SUPABASE_ANON_DEFAULT) await putConf("webhookKey", `Bearer ${SUPABASE_ANON_DEFAULT}`);
} catch (_) {}
chartPanel.init(); bindTabs();
$("#date").value = todayStr();
$("#timeM").value = "07:00"; $("#timeA").value = "19:00";

// ⤵️ Soft-Save: Draft für HEUTE laden und anwenden
try{
  const d = await loadDraft($("#date").value);
  applyDraftToUI(d);
} catch(_){}

$("#from").value = new Date(Date.now()-90*24*3600*1000).toISOString().slice(0,10);
$("#to").value = todayStr();
setTab("capture");
await ensureSupabaseClient();
bindAuthButtons();
if (sbClient) watchAuthState()

// Wenn schon eingeloggt ? App starten, sonst Login-Leiste zeigen
const hasSession = await requireSession();
if (hasSession) {
  await afterLoginBoot(); // wichtig für Reload mit persistierter Session
}

// Konfiguration laden
const savedUrl = await getConf("webhookUrl");
const savedKey = await getConf("webhookKey");
if (!savedUrl || !savedKey) {
  setTab("capture"); // In Erfassung bleiben
}

// Sanfte Warnung
// === Live-Kommentar-Pflicht: sofort roter Rand bei Grenzwertüberschreitung ===
function needsCommentNow(){
  const sysM = Number($("#sysM").value);
  const diaM = Number($("#diaM").value);
  const sysA = Number($("#sysA").value);
  const diaA = Number($("#diaA").value);
  return (sysM > 130) || (diaM > 90) || (sysA > 130) || (diaA > 90);
}
function updateNotesRequirementUI(){
  const notesEl = $("#notesDay");
  if (!notesEl) return;
  const notes = (notesEl.value || "").trim();
  const need = needsCommentNow();
  const invalid = need && !notes;
  notesEl.style.outline = invalid ? "2px solid var(--danger)" : "";
  if (invalid) notesEl.setAttribute("aria-invalid","true"); else notesEl.removeAttribute("aria-invalid");
}
  
// bei jeder Eingabe der vier BP-Felder + Kommentar selbst neu bewerten
["#sysM","#diaM","#sysA","#diaA","#notesDay","#pulseM","#pulseA","#weightDay","#timeM","#timeA"].forEach(sel=>{
  const el = $(sel); if(!el) return;
  el.addEventListener("input", ()=>{
    updateNotesRequirementUI();
    scheduleDraftSave();   // ⤵️ jede Eingabe → Soft-Save
  });
});

// einmal initial prüfen (falls Werte schon stehen)
updateNotesRequirementUI();

// Toggle-Handler
const bindToggle = (id, setter, getVal)=>{
  const el = $(id);
  el.addEventListener("click", ()=>{
    setter(!getVal());
    scheduleDraftSave(); // ⤵️ Flags ändern → Soft-Save
  });
};

bindToggle("#trainingToggle", setTraining, ()=>trainingActive);
bindToggle("#lowIntakeToggle", setLowIntake, ()=>lowIntakeActive);
bindToggle("#sickToggle", setSick, ()=>sickActive);
bindToggle("#valsartanMissToggle", setValsartanMiss, ()=>valsartanMissed);
bindToggle("#forxigaMissToggle", setForxigaMiss, ()=>forxigaMissed);
bindToggle("#nsarToggle", setNsar, ()=>nsarTaken);
bindToggle("#saltHighToggle", setSaltHigh, ()=>saltHigh);
bindToggle("#sugarHighToggle", setSugarHigh, ()=>sugarHigh);

$("#saveAllBtn").addEventListener("click", saveAll);
$("#applyRange").addEventListener("click", async ()=>{
  await renderDoctor();
setDocBadges({ visible: true });
  if(chartPanel.open) chartPanel.draw();
});

$("#doctorChartBtn").addEventListener("click", async ()=>{
setDocBadges({ visible: true });
chartPanel.open = true;
chartPanel.el.style.display = 'block';
await chartPanel.draw();
});
  
  // Diagramm aus der Erfassungs-Ansicht öffnen
const capChartBtn = $("#captureChartBtn");
if (capChartBtn) {
  capChartBtn.addEventListener("click", async ()=>{
    setDocBadges({ visible: true });     // Badges zeigen (optional)
    chartPanel.open = true;
    chartPanel.el.style.display = 'block';
    await chartPanel.draw();
  });
}

document.addEventListener('keydown', (e)=>{
const isSave = (e.key.toLowerCase()==='s') && (e.ctrlKey || e.metaKey);
if(isSave){ e.preventDefault(); saveAll(); }
});

  $("#doctorExportJson").addEventListener("click", async ()=>{
  const all = await getAllEntries();
  dl("gesundheitslog.json", JSON.stringify(all,null,2), "application/json");
});
  
// Initial Render
await renderDoctor();
setDocBadges({ visible: true });

// --- Failsafe: nach Reload alles sicher freigeben (falls etwas "disabled" hängen blieb)
$$('main input, main select, main textarea, main button, nav.tabs button').forEach(el=>{
  if (el.id !== 'logoutBtn') el.disabled = false;
});
document.body.classList.remove('auth-locked');

function daySummaryActive(){
const w = ($("#weightDay")?.value || "").trim();
const n = ($("#notesDay")?.value || "").trim();
return !!(w || n || trainingActive || lowIntakeActive || sickActive ||
valsartanMissed || forxigaMissed || nsarTaken || saltHigh || sugarHigh);
}

const disableVitals = daySummaryActive();
["#sysM","#diaM","#pulseM","#sysA","#diaA","#pulseA"].forEach(sel=>{
const el = $(sel);
if (!el) return;
el.disabled = disableVitals;
el.style.opacity = disableVitals ? 0.6 : 1;
});

// Auto-Push Pending sobald online
window.addEventListener('online', async ()=>{
const resPush = await pushPendingToRemote();
if(resPush.pushed || resPush.failed){
diag.add(`Online-Push: OK=${resPush.pushed}, FAIL=${resPush.failed}`);
await reconcileFromRemote();
}
});
}

/* boot */
if (document.readyState === "loading") {
window.addEventListener("DOMContentLoaded", main);
} else {
main();
}

/* === Debug-Notizen
- V1.5: Realtime über supabase-js; Projekt-URL aus REST-URL abgeleitet.
- Auto-Sync: push pending ? reconcile (Entries) ohne Wipe.
- Realtime-Events: INSERT/UPDATE ? upsert, DELETE ? lokal entfernen.
- UI-Refresh: Arzt-Ansicht sofort; Charts nur, wenn Panel offen.
=== */
</script>
<!-- Google-Login (einfach) -->
<div id="loginBar" style="position:fixed;left:8px;bottom:8px;z-index:10000;display:none;gap:8px">
<button class="btn primary" id="googleLoginBtn" type="button">Mit Google anmelden</button>
<span id="whoAmI" class="small" style="margin-left:8px"></span>
<button class="btn ghost" id="logoutBtn" type="button" style="display:none">Abmelden</button>
</div>
</body>
</html>


