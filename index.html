<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Gesundheits-Logger (V1.0.0)</title>
<style>

/* ANKER: chart-controls styles (move to assets/app.css bei n√§chster Release) */
  /* Dropdown optisch kompakter */
  #chart .controls .compact { max-width: 240px; }

  /* KPI-Zeile: √ò-Werte neben dem Dropdown */
  #chart .controls .kpis {
    display: inline-flex;
    gap: 16px;
    align-items: center;
    margin-left: 16px;
    color: var(--text, #e5e7eb);
    font-size: 0.95rem;
    white-space: nowrap;
  }
  #chart .controls .kpis .sep { opacity: .6; }
  
body.auth-locked main{ opacity:.6; }
:root { --bg:#0b0c10; --card:#15171c; --fg:#e8e8e8; --muted:#9aa3af; --accent:#4f46e5; --warn:#f59e0b; --ok:#10b981; --danger:#ef4444; }
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial;background:var(--bg);color:var(--fg);-webkit-tap-highlight-color:transparent;touch-action:manipulation;overscroll-behavior-y:none}
header{position:sticky;top:0;background:linear-gradient(180deg,rgba(11,12,16,.95),rgba(11,12,16,.7));backdrop-filter:blur(6px);z-index:10;padding:10px 12px;border-bottom:1px solid #1f232b}
h1{margin:0;font-size:20px}
nav.tabs{display:flex;gap:8px;padding:8px 12px;position:sticky;top:54px;background:rgba(11,12,16,.9);backdrop-filter:blur(6px);z-index:11}
nav.tabs button{flex:1;min-width:100px;touch-action:manipulation}
main{padding:12px;position:relative;z-index:1}
.card{background:var(--card);border:1px solid #242833;border-radius:16px;padding:14px;margin-bottom:12px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
.row{display:flex;gap:8px;flex-wrap:wrap}
.grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
@media (max-width:640px){ .grid{grid-template-columns:1fr} }
label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
input, select, textarea {width:100%;padding:12px;border-radius:12px;border:1px solid #2b2f3a;background:#0f1116;color:var(--fg);font-size:16px}
textarea{min-height:64px;resize:vertical}

.small{font-size:12px;color:var(--muted)}
.btn{appearance:none;border:none;border-radius:12px;padding:12px 14px;font-weight:600;color:white;background:#2b2f3a;cursor:pointer;touch-action:manipulation;transition: background .25s ease, color .25s ease, transform .06s ease, box-shadow .25s ease}
.btn:disabled{opacity:.6;cursor:not-allowed}
.btn:active{ transform: scale(0.98) }
.btn.primary{background:var(--accent)}
.btn.ghost{background:#0f1116;border:1px solid #2b2f3a;color:var(--fg)}
.btn.warn{background:var(--warn);color:#1a1200}
.btn.toggle.active{ background: var(--ok); color:#06110b; border-color: transparent; }
/* Tabs: aktiver Zustand = wie Primary */
nav.tabs .btn.primary {
  background: var(--accent);
  color: #fff;
  border-color: transparent;
}

.btn.flash{background:linear-gradient(90deg,var(--accent) 0%,#7c3aed 50%,var(--accent) 100%)!important;background-size:200% 100%;color:#fff!important;animation:flashGradient 1s ease forwards,flashPop .2s ease;box-shadow:0 6px 24px rgba(79,70,229,.35)}
@keyframes flashGradient{0%{background-position:0% 50%}100%{background-position:100% 50%}}
@keyframes flashPop {
0% { transform: scale(1) }
50% { transform: scale(1.03) }
100% { transform: scale(1) }
}

/* Toolbar mit zentrierter Mitte + Badges rechts */
#doctorCard .toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: space-between; /* Titel links + Mitte + Badges rechts */
}

#doctorCard .toolbar .center-group {
  flex: 1;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center; /* Buttons + Datum + Anwenden mittig */
}

#doctorCard .toolbar .badge {
  margin-left: 8px;
}

.spacer{flex:1}
section.view{display:none}
section.view.active{display:block}

#doctorCard .toolbar{border-bottom:1px solid #242833;padding-bottom:8px;margin-bottom:8px}

#err{position:fixed;left:8px;right:8px;bottom:8px;background:#3d0d0d;color:#fecaca;padding:8px 10px;border-radius:10px;display:none;z-index:9999}

/* === Arzt-Ansicht (Daily): 3-Spalten-Layout je Tag === */
.doctor-view .doctor-day{
display:grid;
grid-template-columns: 1fr; /* Standard = gestapelt */
gap:12px;
align-items:start;
padding:12px 14px;
margin:8px 0;
border-radius:12px;
background:var(--card);
border:1px solid #242833;
box-shadow:0 6px 18px rgba(0,0,0,.25);
page-break-inside:avoid;
break-inside:avoid;
}

  /* --- Arzt-Toolbar Badges (Daily KPIs) --- */
.badge {
  display: inline-block;
  padding: 6px 12px;         /* etwas mehr Platz */
  border: 1.5px solid #2b2f3a;
  border-radius: 12px;       /* runder = moderner */
  font-size: 13px;           /* +1pt gr√∂√üer */
  font-weight: 600;          /* kr√§ftiger */
  margin-left: 10px;
}
.badge.good{border-color:var(--ok); color:var(--ok)}
.badge.bad{ border-color:var(--danger); color:var(--danger)}
.badge.hidden{ display:none !important; }

/* Tablet/Desktop: nebeneinander */
@media (min-width: 900px){
.doctor-view .doctor-day{
grid-template-columns: 18% 46% 36%;
}
}

/* Zwischenbereich: 2 Spalten */
@media (min-width: 600px) and (max-width: 899px){
.doctor-view .doctor-day{
grid-template-columns: 40% 60%;
grid-template-areas:
"date measure"
"date special";
}
.doctor-view .col-date{ grid-area: date; }
.doctor-view .col-measure{ grid-area: measure; }
.doctor-view .col-special{ grid-area: special; }
}

/* Spalte A ‚Äì Datum */
.doctor-view .col-date{
display:flex; align-items:center;
font-weight:800;
font-size:clamp(16px,1.6vw,20px);
letter-spacing:.2px;
}
  /* Datumsspalte mit Cloud + Delete untereinander */
.doctor-view .col-date{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.doctor-view .col-date .date-top{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}
.doctor-view .col-date .date-label{
  font-weight:800;
  font-size:clamp(16px,1.6vw,20px);
  letter-spacing:.2px;
}
.doctor-view .col-date .date-cloud{ font-size:16px; line-height:1; }
.doctor-view .col-date .date-actions{
  display:flex;
  justify-content:flex-start; /* oder center, wenn du‚Äôs mittig magst */
}
.btn-xs{ padding:6px 10px; font-size:12px; border-radius:8px; }

/* Spalte B ‚Äì Messungen */
.doctor-view .col-measure{ display:grid; grid-template-rows:auto 1fr; gap:6px; }
/* Kopf und Werte-Spalten: gleiche Breiten wie Zahlen, Label links fix */
.doctor-view .measure-head,
.doctor-view .measure-grid{
display:grid;
grid-template-columns: minmax(70px, auto) repeat(4, 1fr);
gap:4px;
}
.doctor-view .measure-head{ font-size:12px; opacity:.8; }


/* Head-Zellen als Flex: rechtsb√ºndig wie die Zahlen */
.doctor-view .measure-head > div{ display:flex; align-items:center; }
.doctor-view .measure-head > div:first-child{ justify-content:flex-start; }
.doctor-view .measure-head > div:not(:first-child){ justify-content:flex-end; }
.doctor-view .measure-row{ display:contents; }
.doctor-view .label{ display:flex; align-items:center; font-size:13px; opacity:.9; }

/* Zahlenbild */
.doctor-view .num{
font-variant-numeric: tabular-nums lining-nums;
-moz-font-feature-settings:"tnum","lnum";
-webkit-font-feature-settings:"tnum","lnum";
font-feature-settings:"tnum","lnum";
text-align:right;
display:flex; align-items:center; justify-content:flex-end;

min-width: 4ch; /* Basisschutz gegen Abschneiden */
white-space: nowrap;
}
  
  /* Grenzwert-Highlight f√ºr Arzt-Ansicht */
.doctor-view .num.alert{ color: var(--danger); }

.doctor-view .measure-grid .num,
.doctor-view .col-special .num{
text-align:right; justify-content:flex-end;
}

/* Spalte C ‚Äì Spezialinfos */
/* Gewicht: √úberschrift + Zahl darunter */
.doctor-view .weight-line,
.doctor-view .waist-line{
  display:flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  background: transparent;
  border: none;
  padding: 0;
  font-weight: 600;
}

.doctor-view .weight-line > :first-child,
.doctor-view .waist-line > :first-child{
  font-size: 12px;
  opacity:.8;
  font-weight:600;
  letter-spacing:.2px;
}

.doctor-view .weight-line .num,
.doctor-view .waist-line .num{
  font-size:clamp(16px,1.6vw,20px);
  font-weight:700;
  line-height:1.1;
  text-align:center;
}

/* Spalten C/D/E: Gewicht | Flags | Kommentar */
.doctor-view .col-special{
  display: grid;
  grid-template-columns: minmax(120px, max-content) 220px 1fr; /* C | D | E */
  column-gap: 16px;
  row-gap: 6px;
  align-items: start; /* <-- alles oben ausrichten */
}

/* Elemente gezielt in Spalten setzen */
.doctor-view .col-special > .weight-line,
.doctor-view .col-special > .waist-line { grid-column: 1; }
.doctor-view .col-special > .flags       { grid-column: 2; }
.doctor-view .col-special > .notes       { grid-column: 3; }

/* D: Flags ‚Äì Desktop: eine Spalte untereinander */
.doctor-view .flags{
  display:grid;
  grid-template-columns: repeat(2, max-content); /* 2 Spalten */
  justify-content:start;
  align-items:start;
  gap: 6px 16px; /* vertikal 6px, horizontal 16px */
}

.doctor-view .weight-line .num,
.doctor-view .waist-line .num{ font-variant-numeric: tabular-nums; } /* Spalten wirken ruhiger */
.doctor-view .flag span:last-child{ white-space:nowrap; }
.doctor-view .flag{ display:grid; grid-template-columns:18px 1fr; align-items:center; gap:6px; font-size:12px; opacity:.95; }
.doctor-view .flag-box{
width:16px; height:16px; border:1.5px solid #2b2f3a; border-radius:3px; display:inline-block; position:relative;
}
.doctor-view .flag-box.on::after{
content:""; position:absolute; inset:2px; background:var(--accent); border-radius:2px;
}

/* Notizen: im Screen 3 Zeilen, im Druck voll */
/* Kommentar: Titel + Box */
/* Kommentar: Kopf + Wert, ohne Kasten */
.doctor-view .notes{
  font-size: 13px;
  line-height: 1.35;
  display: -webkit-box;
  -webkit-line-clamp: 3;      /* 3 Zeilen, bei Bedarf 2 setzen */
  -webkit-box-orient: vertical;
  overflow: hidden;
  word-break: break-word;
  padding: 0;                 /* kein Box-Feeling */
  background: transparent;
  border: none;
}
.doctor-view .notes::before{
  content: "Kommentar";
  display: block;
  font-size: 12px;
  opacity: .8;
  font-weight: 600;
  letter-spacing: .2px;
  margin-bottom: 4px;
}
/* NICHT ausblenden, auch wenn leer ‚Äì der Renderer liefert "‚Äì" */

/* Mobile-Optimierung */
@media (max-width: 599px){

  /* Kopf & Werte: schm√§lere Label-Spalte + garantierte Zahlbreite */
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(72px, 1fr) repeat(4, minmax(56px, 1fr));
  }
  .doctor-view .measure-head{ font-size: 11px; }

  /* Zahlen d√ºrfen nicht schrumpfen ‚Üí keine abgeschnittenen Dezimalstellen */
  .doctor-view .num{
    min-width: 4.5ch; /* ~ ‚Äû96.7‚Äú passt sicher */
    white-space: nowrap;
    flex: 0 0 auto;
  }
.doctor-view .col-special .weight-line .num,
.doctor-view .col-special .waist-line .num{
  min-width: 5ch;
}

  /* Spalten: Gewicht | Flags nebeneinander, Kommentar darunter √ºber volle Breite */
  .doctor-view .col-special{
    grid-template-columns: minmax(110px, max-content) 1fr; /* Flags bekommen flex Breite */
    column-gap: 12px;
  }
  .doctor-view .col-special > .notes{
    grid-column: 1 / -1; /* Kommentar √ºber beide Spalten */
  }

  /* Kommentar: mobil 4 Zeilen anzeigen */
  .doctor-view .notes{
    -webkit-line-clamp: 4; /* bei Bedarf auf 5 erh√∂hen */
  }

  /* Flags: kompakt in 2 Spalten, keine abgeschnittenen Labels */
  .doctor-view .flags{
    display: grid;
    grid-template-columns: repeat(2, max-content);
    justify-content: start;
    align-items: center;
    column-gap: 14px;
    row-gap: 6px;
    margin-top: 6px;
  }
  .doctor-view .flag span:last-child{ white-space: nowrap; }
}

/* Extra-eng (‚â§ 390px Breite) */
@media (max-width: 390px){
  .doctor-view .measure-head,
  .doctor-view .measure-grid{
    grid-template-columns: minmax(66px, 1fr) repeat(4, minmax(50px, 1fr));
  }
  .doctor-view .flags{
    grid-template-columns: repeat(3, max-content);
  }
}

/* Panels */
.panel{position:fixed;right:8px;bottom:8px;max-height:80vh;overflow:auto;background:#0f1116;border:1px solid #2b2f3a;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.35);display:none;z-index:9998}
/* Panel (Charts) ‚Äî Fullscreen */
.panel.chart{
  inset: 0;                 /* volle Fl√§che (top/right/bottom/left = 0) */
  width: 100vw;
  height: 100dvh;           /* korrekt auf Mobile (sichtbare H√∂he) */
  max-width: 100vw;
  max-height: 100dvh;
  border-radius: 0;         /* keine abgerundeten Ecken im Vollbild */
}

/* Flex-Layout: Header fix oben, Inhalt f√ºllt Rest */
.panel.chart{
  /* Sichtbarkeit steuert JS; NICHT auf block setzen */
}
.panel.chart header{ 
  /* bleibt oben, keine √Ñnderung n√∂tig ‚Äì aber fixere H√∂he ist hilfreich */
  min-height: 44px;
}
.panel.chart .content{
  /* Inhalt f√ºllt den verf√ºgbaren Raum */
  height: calc(100dvh - 44px - 2px); /* 44px Header + 1px border oben/unten */
  display: flex;
  flex-direction: column;
  overflow: auto;
}
.panel header{display:flex;gap:6px;align-items:center;justify-content:space-between;padding:8px;border-bottom:1px solid #2b2f3a}
.panel h4{margin:0;font-size:14px}
.panel .content{
  padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) 
           max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
  font-size: 13px;
  line-height: 1.45;
}
#diag pre{margin:0;padding:8px;font-size:12px;white-space:pre-wrap}

/* FABs */
.fab-wrap{position:fixed;right:8px;bottom:8px;display:flex;flex-direction:column;gap:8px;z-index:9999}
.fab{width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;border:1px solid #2b2f3a;background:#0f1116;cursor:pointer}
.fab:hover{box-shadow:0 8px 24px rgba(0,0,0,.35)}

/* Chart panel */
#chart .controls{
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  margin-bottom:6px;
}
/* ANKER: flags-overlay CSS */
#chartSvg .flags { pointer-events: none; }
#chart .controls > * {flex:1}
#chart .controls .half{flex:0 0 calc(50% - 4px)}
  
  /* SVG f√ºllt verbleibende H√∂he vollst√§ndig */
#chart svg{
  flex: 1 1 auto;
  width: 100%;
  height: 100%;     /* statt auto */
  min-height: 160px;
  display: block;
  background: #0f1116;
  border: 1px solid #2b2f3a;
  border-radius: 10px;
}

#chart .legend{display:flex;gap:10px;font-size:12px;color:var(--muted);margin-top:6px;flex-wrap:wrap}

.dot{width:8px;height:8px;border-radius:50%;display:inline-block;margin-right:6px;border:1px solid #000}

/* Busy overlay */
#busy{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);z-index:99998}
#busy .box{background:#10131a;border:1px solid #2b2f3a;border-radius:12px;padding:12px 16px;font-weight:600}

.seg{display:flex;gap:8px;margin:8px 0 12px}
.seg .seg-btn.active{background:var(--accent);color:#fff}
.hidden{display:none!important}
:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

/* App-Lock Overlay */
#appLock{
  position: fixed; inset: 0; z-index: 10001;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.45); backdrop-filter: blur(2px);
}
#appLock .lock-card{
  width: min(420px, 92vw);
  background: #fff; color: #111;
  border-radius: 16px; padding: 18px;
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
  border: 1px solid #e5e7eb;
}
#appLock .lock-card h3{ margin: 0 0 6px; }
#appLock .btn.primary{ background: var(--accent); color: #fff; }
#appLock .pin-wrap{ display:flex; gap:8px; margin-top:8px; }
#appLock .pin-wrap input{
  flex:1; background:#f8fafc; color:#111; border:1px solid #e5e7eb;
}

/* Body-State: solange gelockt ist, Interaktion sperren (Overlay deckt ohnehin ab) */
body.app-locked main, body.app-locked nav, body.app-locked header{
  filter: blur(0); /* bewusst ohne Blur, nur visuelles Dimmen optional */
}
body.app-locked { pointer-events: auto; } /* Overlay nimmt Events ab */

/* Login-Overlay */
#loginOverlay{

  position: fixed; inset: 0; z-index: 10000;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.35); backdrop-filter: blur(2px);
}
#loginOverlay .login-card{
  width: min(420px, 92vw);
  background: #fff; color: #111;
  border-radius: 16px; padding: 18px;
  box-shadow: 0 18px 48px rgba(0,0,0,.35);
  border: 1px solid #e5e7eb;
}
#loginOverlay .login-card h3{ margin: 0 0 6px; }
#loginOverlay .btn.primary{ background: var(--accent); color: #fff; }
  
</style>
</head>
<body>
<header>
<div style="display:flex;align-items:center;gap:10px">
<h1>Gesundheits-Logger</h1><span class="small">V1.0.0</span>
<div class="spacer"></div>
<button class="btn ghost" id="helpToggle" type="button">Hilfe</button>
<button class="btn ghost" id="diagToggle" type="button">Log</button>
</div>
</header>

<nav class="tabs">
<button class="btn ghost" data-tab="capture" id="tab-capture" type="button">Erfassen</button>
<button class="btn ghost" data-tab="doctor" id="tab-doctor" type="button">Arzt-Ansicht</button>
</nav>

<!-- Hilfe-Panel -->
<div id="help" class="panel" role="dialog" aria-modal="false" aria-labelledby="helpTitle">
<header>
<h4 id="helpTitle">Hilfe ‚Ä¢ Was soll ich ankreuzen?</h4>
<button class="btn ghost" id="helpClose" type="button">√ó</button>
</header>
<div class="content">
<strong>NSAR genommen</strong> ankreuzen, wenn du ein Schmerz-/Entz√ºndungsmedikament der Klasse NSAR genommen hast.
<ul>
<li><em>Beispiele (AT, frei):</em> Ibuprofen, Diclofenac, Naproxen.</li>
<li><em>Kombo-Achtung:</em> Viele ‚ÄûErk√§ltungs-/Kopfweh‚Äú-Mittel enthalten NSAR.</li>
<li><em>Bei Nierenkrankheit:</em> NSAR m√∂glichst vermeiden, Alternativen mit Arzt besprechen.</li>
</ul>
</div>
</div>

<!-- Diagnose-Panel -->
<div id="diag" class="panel" role="dialog" aria-modal="false" aria-labelledby="diagTitle">
<header>
<h4 id="diagTitle">Touch-Log</h4>
<button class="btn ghost" id="diagClose" type="button">√ó</button>
</header>
<pre id="diagLog" class="content" style="margin:0"></pre>
</div>

<!-- Diagramm-Panel (Daily) -->
<div id="chart" class="panel chart" role="dialog" aria-modal="false" aria-labelledby="chartTitle">
<header>
<h4 id="chartTitle">Diagramm (Daily)</h4>
<button class="btn ghost" id="chartClose" type="button">√ó</button>
</header>
<div class="content">
<div class="controls">
<select id="metricSel" class="half compact" aria-label="Messgr√∂√üe ausw√§hlen">
    <option value="bp">Blutdruck (Sys/Dia)</option>
    <option value="weight">K√∂rper</option>
</select>

  <!-- ANKER: chart-averages (Daily) -->
  <div id="chartAverages" class="kpis" aria-live="polite">
    <span data-k="sys">Durchschnitt Sys: ‚Äì</span>
    <span class="sep" aria-hidden="true">‚Ä¢</span>
    <span data-k="dia">Durchschnitt Dia: ‚Äì</span>
    <span class="sep" aria-hidden="true">‚Ä¢</span>
    <span data-k="map">Durchschnitt MAP: ‚Äì</span>
  </div>
</div>

<svg id="chartSvg" viewBox="0 0 640 280" preserveAspectRatio="none" role="img" aria-label="Werteverlauf"></svg>
<div class="legend" id="chartLegend"></div>
<div class="small" style="opacity:.7;margin-top:6px">Zeitraum: nutzt die <em>Arzt-Ansicht</em> (von/bis).</div>
</div>
</div>

<div id="err" role="status" aria-live="polite"></div>
<div id="busy"><div class="box">‚è≥ Bitte warten‚Ä¶</div></div>

<main>
<!-- Capture -->
<section class="view active" id="capture">
 
  <!-- Daily-Capture -->
  <section class="card" id="entry">
    <div class="row">
      <div style="flex:1">
        <label>Datum</label>
        <input type="date" id="date">
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Morgens</h3>
      <div class="row">
        <div style="width:130px">
          <label>Uhrzeit</label>
          <input type="time" id="timeM" step="60">
        </div>
      </div>
      <div class="grid">
        <div><label>Systolisch (mmHg)</label><input type="number" id="sysM" inputmode="numeric" placeholder="z. B. 128"></div>
        <div><label>Diastolisch (mmHg)</label><input type="number" id="diaM" inputmode="numeric" placeholder="z. B. 82"></div>
        <div><label>Puls (bpm)</label><input type="number" id="pulseM" inputmode="numeric" placeholder="z. B. 66"></div>
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Abends</h3>
      <div class="row">
        <div style="width:130px">
          <label>Uhrzeit</label>
          <input type="time" id="timeA" step="60">
        </div>
      </div>
      <div class="grid">
        <div><label>Systolisch (mmHg)</label><input type="number" id="sysA" inputmode="numeric" placeholder="z. B. 128"></div>
        <div><label>Diastolisch (mmHg)</label><input type="number" id="diaA" inputmode="numeric" placeholder="z. B. 82"></div>
        <div><label>Puls (bpm)</label><input type="number" id="pulseA" inputmode="numeric" placeholder="z. B. 66"></div>
      </div>
    </div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      
<h3 class="blockTitle">K√∂rper</h3>
<div class="grid" style="grid-template-columns:1fr 1fr">
  <div>
    <label>Gewicht (kg)</label>
    <input type="number" step="0.1" id="weightDay" inputmode="decimal" placeholder="z. B. 84.2">
  </div>
  <div>
    <label>Bauchumfang (cm)</label>
    <input id="input-waist-cm" type="text" inputmode="decimal" autocomplete="off" placeholder="z. B. 104,5" />
  </div>
</div>
</div>

    <div class="card" style="margin:8px 0;background:#11131a;border-color:#232735">
      <h3 class="blockTitle">Kommentar</h3>
      <div class="row">
        <div style="flex:1">
          <textarea id="notesDay" placeholder="Allgemeiner Kommentar zum Tag (optional)"></textarea>
        </div>
      </div>
    </div>

    <div class="row" style="align-items:center; gap:8px; margin-top:4px">
      <button class="btn toggle" id="trainingToggle" type="button" aria-pressed="false">üèãÔ∏è Training heute</button>
      <button class="btn toggle" id="sickToggle" type="button" aria-pressed="false">ü§í Krank (Forxiga pausiert)</button>
      <button class="btn toggle" id="valsartanMissToggle" type="button" aria-pressed="false">üíä Valsartan vergessen</button>
      <button class="btn toggle" id="forxigaMissToggle" type="button" aria-pressed="false">üíä Forxiga vergessen</button>
      <button class="btn toggle" id="lowIntakeToggle" type="button" aria-pressed="false">üö∞ &lt; 2 L getrunken</button>
      <button class="btn toggle" id="saltHighToggle" type="button" aria-pressed="false" title="> 5 g Salz">üßÇ &gt; 5 g Salz</button>
      <button class="btn toggle" id="sugarHighToggle" type="button" aria-pressed="false" title="> 10 g Zucker">üç¨ &gt; 10 g Zucker</button>
      <button class="btn toggle" id="nsarToggle" type="button" aria-pressed="false" title="Nicht-steroidale Antirheumatika">‚ö†Ô∏è NSAR genommen</button>
      <div class="spacer"></div>
    </div>

    <div class="row" style="align-items:center; gap:8px; margin-top:12px">
      <button class="btn primary" id="saveAllBtn" type="button">üíæ Speichern</button>
      <div class="spacer"></div>
    </div>
  </section>
</section>

<!-- Doctor -->
<section class="view" id="doctor">
  <section class="card" id="doctorCard">
    <div class="toolbar">
      <strong id="doctorTitle">Arzt-Ansicht</strong>

      <div class="center-group">
        <label class="small">Von <input type="date" id="from" style="width:auto"></label>
        <label class="small">Bis <input type="date" id="to" style="width:auto"></label>
        <button class="btn ghost" id="applyRange" type="button">Anwenden</button>
        <button class="btn ghost" id="doctorChartBtn" type="button" title="Werte als Grafik">Werte anzeigen</button>
        <button class="btn ghost" id="doctorExportJson" type="button">Export JSON</button>
      </div>

      <span id="docTrainCnt" class="badge good" title="Anzahl Tage mit Training im Zeitraum">üèãÔ∏è Trainingstage: <span class="val">0</span></span>
      <span id="docBadCnt" class="badge bad" title="Anzahl Tage mit mind. einem Bad-Flag">‚ö†Ô∏è Tage mit Bad-Flag: <span class="val">0</span></span>
    </div> <!-- üëà Toolbar sauber schlie√üen -->

    <div style="overflow:auto" id="doctorDailyWrap">
      <div class="doctor-view" id="doctorView"></div>
    </div>

        <div class="small" style="margin-top:6px">
      Tipp: ‚ÄûWerte anzeigen‚Äú √∂ffnet die passende Grafik zum aktuellen Tab (Daily).
    </div>
  </section>
</section>

<!-- Supabase (UMD, v2) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

<script>
/* ===== Supabase Defaults (ANON only ‚Äì niemals service_role!) ===== */
const SUPABASE_URL_DEFAULT = "https://jlylmservssinsavlkdi.supabase.co";
const SUPABASE_ANON_DEFAULT = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpseWxtc2VydnNzaW5zYXZsa2RpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNTQ2NjAsImV4cCI6MjA3MDgzMDY2MH0.4BpnwDJAlPohSYLfNcaEJfxQNvlHBbMvxVcCOAWpkFA";
const DEFAULT_WEBHOOK_ENTRIES = `${SUPABASE_URL_DEFAULT}/rest/v1/health_events`;

/* ===== Fehlerbox ===== */
window.addEventListener('unhandledrejection', (e)=>{
const box = document.getElementById('err');
box.style.display='block';
box.textContent = 'Fehler: ' + (e.reason?.message || e.reason || 'Unbekannter Fehler');
});

/* ===== Diagnostics ===== */
const perfStats = (() => {
const buckets = Object.create(null);
const add = (k, ms) => (buckets[k] ??= []).push(ms);
const pct = (arr, p) => {
if (!arr.length) return 0;
const a = [...arr].sort((x,y)=>x-y);
const i = Math.ceil((p/100)*a.length)-1;
return a[Math.max(0, Math.min(i, a.length-1))];
};
const snap = (k) => {
const arr = buckets[k] || [];
return { count: arr.length, p50: pct(arr,50), p95: pct(arr,95), p99: pct(arr,99) };
};
return { add, snap };
})();

const diag = { el:null, logEl:null, open:false, lines:[],
add(msg){ const t=new Date().toLocaleTimeString(); this.lines.unshift(`[${t}] ${msg}`); this.lines=this.lines.slice(0,80); if(this.logEl) this.logEl.textContent = this.lines.join('\n'); },
init(){ this.el=document.getElementById('diag'); this.logEl=document.getElementById('diagLog');
const t1=document.getElementById('diagToggle'); const t2=document.getElementById('diagToggleFab');
const close=document.getElementById('diagClose');
const toggle=()=>{ this.open=!this.open; this.el.style.display=this.open?'block':'none'; };
t1.addEventListener('click', toggle);
if (t2) t2.addEventListener('click', toggle);
close.addEventListener('click', ()=>{ this.open=false; this.el.style.display='none'; });
}
};

/* ===== Help panel ===== */
const helpPanel={ el:null, open:false,
init(){ this.el=document.getElementById('help');
const t1=document.getElementById('helpToggle'); const t2=document.getElementById('helpToggleFab'); const close=document.getElementById('helpClose');
const toggle=()=>{ this.open=!this.open; this.el.style.display=this.open?'block':'none'; };
t1.addEventListener('click', toggle);
if (t2) t2.addEventListener('click', toggle);
close.addEventListener('click', ()=>{ this.open=false; this.el.style.display='none'; });
}
};

/* ===== Helpers ===== */
// --- Service-Role-Schutz (NIEMALS im Browser) ---
function isServiceRoleKey(raw){
  const tok = String(raw||"").trim().replace(/^Bearer\s+/i,'');
  try{
    const payload = JSON.parse(atob(tok.split('.')[1].replace(/-/g,'+').replace(/_/g,'/')));
    return payload?.role === 'service_role';
  }catch{
    return false; // Fallback: lieber konservativ sein
  }
}

// ANCHOR: num-helper-de
function toNumDE(s) {
  if (s == null) return null;
  const v = String(s).trim();
  if (!v) return null;
  const n = parseFloat(v.replace(',', '.'));
  return Number.isFinite(n) ? n : null;
}
  
/* ===== Auth-Guard ===== */
async function isLoggedIn(){
try{
if(!sbClient) return false;
const { data:{ session } } = await sbClient.auth.getSession();
return !!session;
}catch{ return false; }
}

/** Schaltet optisch auf ‚Äûgesperrt‚Äú ‚Äì ohne Controls hart zu deaktivieren */
function setAuthGuard(logged){
  // Nur visuelles Dimmen; die Save-Logik pr√ºft isLoggedIn() ohnehin.
  document.body.classList.toggle('auth-locked', !logged);
  // Kein auto-boot mehr hier ‚Äì Start erfolgt in main()/watchAuthState.
}

function setDoctorAccess(enabled){
  // Tab-Button
  const tabBtn = document.getElementById('tab-doctor');
  if (tabBtn){
    tabBtn.disabled = !enabled;
    tabBtn.classList.toggle('ghost', !enabled);
    tabBtn.title = enabled ? '' : 'Bitte zuerst anmelden';
  }
  // ‚ÄûWerte anzeigen‚Äú-Button
  const chartBtn = document.getElementById('doctorChartBtn');
  if (chartBtn){
    chartBtn.disabled = !enabled;
    chartBtn.title = enabled ? 'Werte als Grafik' : 'Bitte zuerst anmelden';
  }
}
  
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const fmtNum = (n, d=1) => (n===null||n===undefined||isNaN(n)) ? "" : Number(n).toFixed(d);
const pad2 = n => n.toString().padStart(2,'0');
const todayStr = () => { const d = new Date(); const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; };
const timeStr = () => { const d = new Date(); return pad2(d.getHours())+":"+pad2(d.getMinutes()); };
function esc(s){ return String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function nl2br(s){ return esc(s).replace(/\n/g, "<br>"); }
function calcMAP(sys, dia){ if (sys==null || dia==null) return null; return Number(dia) + (Number(sys)-Number(dia))/3; }
  // === Mapping: lokaler Erfassungseintrag -> 0..N health_events ===
// Erzeugt pro Eingabe die n√∂tigen Events (bp/body/day_flags/note)
function toHealthEvents(entry){
  const tsIso = entry.dateTime; // ISO Timestamp des Eintrags
  const out = [];

  // 1) Blutdruck-Messungen (Morgen/Abend)
  if (entry.context === "Morgen" || entry.context === "Abend"){
    const hasVitals = (entry.sys != null) || (entry.dia != null) || (entry.pulse != null);
    if (hasVitals){
      const payload = {};
      if (entry.sys   != null) payload.sys   = Number(entry.sys);
      if (entry.dia   != null) payload.dia   = Number(entry.dia);
      if (entry.pulse != null) payload.pulse = Number(entry.pulse);
      payload.ctx = entry.context; // "Morgen" | "Abend"
      out.push({ ts: tsIso, type: "bp", payload });
    }
  }

  // 2) Tageszusammenfassung (Gewicht, Bauchumfang, Flags, Kommentar)
  if (entry.context === "Tag"){
    // body (Gewicht + Bauchumfang)
    const hasBody = (entry.weight != null) || (entry.waist_cm != null);
    if (hasBody){
      const payload = {};
      if (entry.weight   != null) payload.kg = Number(entry.weight);
      if (entry.waist_cm != null) payload.cm = Number(entry.waist_cm);
      out.push({ ts: tsIso, type: "body", payload });
    }

    // day_flags (alle Booleans)
    const flags = {
      training:         !!entry.training,
      sick:             !!entry.sick,
      low_intake:       !!entry.low_intake,
      salt_high:        !!entry.salt_high,
      sugar_high:       !!entry.sugar_high,
      valsartan_missed: !!entry.valsartan_missed,
      forxiga_missed:   !!entry.forxiga_missed,
      nsar_taken:       !!entry.nsar_taken,
    };
    const anyFlag = Object.values(flags).some(Boolean);
    if (anyFlag){
      out.push({ ts: tsIso, type: "day_flags", payload: flags });
    }

    // note (optional, 1 Zeile Text)
    const note = (entry.notes || "").trim();
    if (note){
      out.push({ ts: tsIso, type: "note", payload: { text: note } });
    }
  }

  return out;
}

// ‚ÄûLegacy‚Äú: Measurement Eintrag, der nur Gewicht enth√§lt
function isWeightOnly(e){
const hasVitals = !!(e?.sys || e?.dia || e?.pulse);
return !hasVitals && (e?.weight != null);
}

function setBusy(on){
document.body.classList.toggle('is-busy', !!on);
const b = document.getElementById('busy');
if (b) b.style.display = on ? 'flex' : 'none';
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function softWarnRange(el, min, max){
const v = Number(el.value);
if (!isNaN(v) && (v < min || v > max)) {
el.style.outline = '2px solid var(--warn)';
} else {
el.style.outline = '';
}
}

/* ===== IndexedDB ===== */
let db;
const DB_NAME = "healthlog_db";
const STORE   = "entries";
const CONF    = "config";

function initDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, 5);

    req.onupgradeneeded = (e)=>{
      db = e.target.result;
      // entries
      if(!db.objectStoreNames.contains(STORE)){
        const s = db.createObjectStore(STORE,{ keyPath:"id", autoIncrement:true });
        s.createIndex("byDateTime","dateTime",{unique:false});
        s.createIndex("byRemote","remote_id",{unique:false});
      } else {
        const s = e.target.transaction.objectStore(STORE);
        try{ s.createIndex("byDateTime","dateTime",{unique:false}); }catch(_){}
        try{ s.createIndex("byRemote","remote_id",{unique:false}); }catch(_){}
      }
      // config
      if(!db.objectStoreNames.contains(CONF)){
        db.createObjectStore(CONF,{ keyPath:"key" });
      }
    };

    req.onsuccess = (e)=>{
      db = e.target.result;
      db.onversionchange = ()=> db?.close?.();
      resolve();
    };
    req.onerror = ()=> reject(req.error || new Error("IndexedDB open failed"));
  });
}

/* --- IDB Helpers (global) --- */
function putConf(key, value){
  return new Promise((res,rej)=>{
    const tx = db.transaction(CONF,"readwrite");
    tx.objectStore(CONF).put({key, value});
    tx.oncomplete = ()=>res();
    tx.onerror = (e)=>rej(e);
  });
}
function getConf(key){
  return new Promise((res,rej)=>{
    const tx = db.transaction(CONF,"readonly");
    const rq = tx.objectStore(CONF).get(key);
    rq.onsuccess = ()=> res(rq.result?.value ?? null);
    rq.onerror   = (e)=> rej(e);
  });
}
function addEntry(obj){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    const rq = tx.objectStore(STORE).add(obj);
    rq.onsuccess = ()=> res(rq.result);
    rq.onerror   = (e)=> rej(e);
  });
}
function updateEntry(id, patch){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    const store = tx.objectStore(STORE);
    const get = store.get(id);
    get.onsuccess = ()=>{
      const cur = get.result; if(!cur){ res(false); return; }
      store.put(Object.assign({}, cur, patch));
    };
    tx.oncomplete = ()=> res(true);
    tx.onerror    = (e)=> rej(e);
  });
}
function getAllEntries(){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readonly");
    const rq = tx.objectStore(STORE).getAll();
    rq.onsuccess = ()=> res(rq.result || []);
    rq.onerror   = (e)=> rej(e);
  });
}
function getEntryByRemoteId(remoteId){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readonly");
    const idx = tx.objectStore(STORE).index("byRemote");
    const rq  = idx.getAll(remoteId);
    rq.onsuccess = ()=> res(rq.result?.[0] ?? null);
    rq.onerror   = (e)=> rej(e);
  });
}
function deleteEntryLocal(id){
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,"readwrite");
    tx.objectStore(STORE).delete(id);
    tx.oncomplete = ()=> res();
    tx.onerror    = (e)=> rej(e);
  });
}

/* ===== Remote (Supabase REST) ===== */
async function getHeaders(){
const key = await getConf("webhookKey");
if (!key || isServiceRoleKey(key)) return null; // NEU: blocken
const anonKey = key.replace(/^Bearer\s+/i, "");

const supa = await ensureSupabaseClient();
if (!supa) return null;

const { data: { session } } = await supa.auth.getSession();
const jwt = session?.access_token;
if (!anonKey || !jwt) return null;

return {
"Content-Type": "application/json",
"apikey": anonKey,
"Authorization": `Bearer ${jwt}`,
"Prefer": "return=representation"
};
}

async function deleteRemote(remote_id){
const url = await getConf("webhookUrl");
const headers = await getHeaders();
if(!url || !headers || !remote_id) return {ok:false};
const q = `${url}?id=eq.${encodeURIComponent(remote_id)}`;
try{
const res = await withRetry(()=> fetch(q, { method:"DELETE", headers }));
return {ok: res.ok, status: res.status};
}catch(e){
return {ok:false, status:0};
}
}
// VORERST deaktiviert ‚Äì Arzt-Ansicht folgt in Schritt 2
async function pullAllFromRemote(){
  return []; // No-Op bis zur Anzeige-Umstellung
}

async function pushPendingToRemote(){
  const url = await getConf("webhookUrl");
  const headers = await getHeaders();
  if(!url || !headers) return { pushed:0, failed:0 };

  const all = await getAllEntries();
  const pending = all.filter(e => !e.remote_id);

  let pushed = 0, failed = 0;

  for (const e of pending){
    try{
      const uid = await getUserId();

      // 1) Legacy-Entry ‚Üí 0..N Events
      const events = toHealthEvents(e);
      if (!events.length) { 
        // nichts sendbar: als "abgearbeitet" markieren, damit wir nicht h√§ngen bleiben
        await updateEntry(e.id, { remote_id: -1 });
        continue;
      }

      // 2) user_id anh√§ngen (RLS)
      const payload = uid ? events.map(ev => ({...ev, user_id: uid})) : events;

      // 3) Batch-POST (Array)
      const res = await withRetry(() => fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(payload)
      }));
      if (!res.ok) { failed++; continue; }

      const json = await res.json();
      const firstId = json?.[0]?.id ?? null;

      // 4) Lokal markieren: irgendein Remote-Event existiert ‚Üí Cloud-Icon ok
      if (firstId != null) {
        await updateEntry(e.id, { remote_id: firstId });
        pushed++;
      } else {
        failed++;
      }

      await sleep(50);
    } catch(_){
      failed++;
    }
  }

  return { pushed, failed };
}

function showLoginOverlay(show){
  const ov = document.getElementById('loginOverlay');
  if (ov) ov.style.display = show ? 'flex' : 'none';
}
function setUserUi(email){
  const who = document.getElementById('whoAmI');
  const lout = document.getElementById('logoutBtn');
  if (who) who.textContent = email ? `Angemeldet als: ${email}` : '';
  if (lout) lout.style.display = email ? '' : 'none';
}

// Buttons binden (einmalig, z. B. in main())
function bindAuthButtons(){
const gbtn = document.getElementById('googleLoginBtn');
const lout = document.getElementById('logoutBtn');

if (gbtn) gbtn.addEventListener('click', async ()=>{
const supa = await ensureSupabaseClient();
if (!supa) { 
alert('Konfiguration fehlt (REST-URL und ANON-Key). Standardwerte sind gesetzt ‚Äì falls entfernt, bitte App neu laden oder Konfiguration in IndexedDB hinterlegen.');
return;
}
const { error } = await supa.auth.signInWithOAuth({
provider: 'google',
options: { redirectTo: `${window.location.origin}${window.location.pathname}` }
});
if (error) alert('Google-Login fehlgeschlagen: ' + error.message);
});

if (lout) lout.addEventListener('click', async ()=>{
const supa = await ensureSupabaseClient();
if (supa) await supa.auth.signOut();
await teardownRealtime(); // <- Channels sauber schlie√üen
__booted = false; // <- erlaubt sp√§teren Re-Login-Start
setUserUi('');
showLoginOverlay(true);
setAuthGuard(false);
});
}

// Beim Start Session pr√ºfen
async function requireSession(){
if(!sbClient){
setUserUi('');
showLoginOverlay(true);
setAuthGuard(false);
return false;
}
const { data: { session } } = await sbClient.auth.getSession();
const email = session?.user?.email || '';
setUserUi(email);
showLoginOverlay(!session);
setAuthGuard(!!session);
setDoctorAccess(!!session);
return !!session;
}

// Reagiert auch auf sp√§tere Logins (z. B. nach Redirect)
function watchAuthState(){
sbClient.auth.onAuthStateChange(async (_event, session)=>{
const email = session?.user?.email || '';
setUserUi(email);
showLoginOverlay(!session);
setAuthGuard(!!session);
setDoctorAccess(!!session);
if (session) {
  await afterLoginBoot();
  await ensureAppLock(); // üëà App-Lock nach erfolgreichem Login
}
});
}

// Alles, was NACH Login laufen soll (deine bestehende Logik)
let __booted = false; // ganz oben im Script oder vor afterLoginBoot definieren

async function afterLoginBoot(){
  if (__booted) return;
  __booted = true;
  // Keine Auto-Sync/Realtime bis Arzt-Ansicht umgestellt ist
  await renderDoctor(); // l√§sst "Bitte anmelden" o. "Keine Eintr√§ge" stehen
}

/* ===== CSV/JSON export (Daily) ===== */
function dl(filename, content, mime){
const a = document.createElement("a");
a.href = URL.createObjectURL(new Blob([content], {type:mime}));
a.download = filename;
a.click();
URL.revokeObjectURL(a.href);
}

/* ===== Doctor view ===== */
function setDocBadges({ training, bad, visible } = {}) {
  const t = document.getElementById('docTrainCnt');
  const b = document.getElementById('docBadCnt');
  if (!t || !b) return;

  if (training !== undefined) t.querySelector('.val').textContent = String(training);
  if (bad !== undefined)      b.querySelector('.val').textContent = String(bad);

  if (visible !== undefined) {
    t.classList.toggle('hidden', !visible);
    b.classList.toggle('hidden', !visible);
  }
}

const __t0 = performance.now();
async function renderDoctor(){
const host = $("#doctorView");
if (!host) return;
if (!(await isLoggedIn())){
  host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Bitte anmelden, um die Arzt-Ansicht zu sehen.</div>`;
  setDocBadges({ visible: false });
  return;
}
host.innerHTML = "";

// Helpers (nur Anzeige)
const dash = v => (v === null || v === undefined || v === "" ? "‚Äì" : String(v));
const onClass = b => (b ? "on" : "");
const fmtDateDE = (iso) => {
const d = new Date(iso + "T00:00:00");
return d.toLocaleDateString("de-AT", { weekday:"short", day:"2-digit", month:"2-digit", year:"numeric" });
};

// 1) Filter + Sort wie bisher
const from = $("#from").value;
const to = $("#to").value;
const entries = await getAllEntries();
const list = entries
.filter(e => {
if (from && e.date < from) return false;
if (to && e.date > to) return false;
return true;
})
.sort((a,b)=> ((a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime))));

// 2) Tagesobjekte aufbauen (nur Darstellung)
const days = new Map();
for (const e of list){
  // Day-Objekt holen/erzeugen
  let d = days.get(e.date);
  if (!d){
  d = {
  date: e.date,
  morning: { sys:null, dia:null, pulse:null, map:null },
  evening: { sys:null, dia:null, pulse:null, map:null },
  weight: null,
  waist_cm: null,
  notes: "",
  flags: { water_lt2:false, salt_gt5:false, sugar_gt10:false, sick:false, meds:false, training:false },
  localIds: [],
  remoteIds: [],
  hasCloud: false
};

    days.set(e.date, d);
  }

  // IDs & Cloud-Status sammeln
  if (e?.id != null) d.localIds.push(e.id);
  if (e?.remote_id != null) { d.remoteIds.push(e.remote_id); d.hasCloud = true; }

  const legacyWeightOnly = isWeightOnly(e);
  const hasVitals = !!(e.sys || e.dia || e.pulse);
  const isDaySummary = (e.context === "Tag") || legacyWeightOnly;
  const isMeasurement = hasVitals && !isDaySummary;

  // Messbl√∂cke
  if (isMeasurement && e.context === "Morgen"){
    d.morning.sys   = e.sys ?? null;
    d.morning.dia   = e.dia ?? null;
    d.morning.pulse = e.pulse ?? null;
    d.morning.map   = (e.map != null ? e.map : calcMAP(e.sys, e.dia));
  } else if (isMeasurement && e.context === "Abend"){
    d.evening.sys   = e.sys ?? null;
    d.evening.dia   = e.dia ?? null;
    d.evening.pulse = e.pulse ?? null;
    d.evening.map   = (e.map != null ? e.map : calcMAP(e.sys, e.dia));
  }

  // Tageszusammenfassung / Gewicht / Notizen
if (isDaySummary){
  if (e.weight != null) d.weight = e.weight;
  if (e.waist_cm != null) d.waist_cm = e.waist_cm;
  if (e.notes)          d.notes  = e.notes;
}

  // Flags
  if (e.training)                         d.flags.training   = true;
  if (e.low_intake)                       d.flags.water_lt2  = true;
  if (e.salt_high)                        d.flags.salt_gt5   = true;
  if (e.sugar_high)                       d.flags.sugar_gt10 = true;
  if (e.sick)                             d.flags.sick       = true;
  if (e.valsartan_missed || e.forxiga_missed || e.nsar_taken) d.flags.meds = true;
}

const daysArr = Array.from(days.values()).sort((a,b)=> a.date.localeCompare(b.date));
 
  // --- KPI: Anzahl Trainingstage und Tage mit mind. einem Bad-Flag
const trainingDays = daysArr.filter(d => !!d.flags.training).length;
const badDays = daysArr.filter(d => {
  const f = d.flags;
  return !!(f.water_lt2 || f.salt_gt5 || f.sugar_gt10 || f.sick || f.meds);
}).length;

// Badges setzen (nur Daily)
setDocBadges({ training: trainingDays, bad: badDays, visible: true });


// 3) Renderer pro Tag (-> 3 Spalten)
const renderDoctorDay = (day) => `
<section class="doctor-day" data-date="${day.date}">
<!-- Spalte A: Datum -->
<!-- Spalte A: Datum (+ Cloud + L√∂schen) -->
<div class="col-date">
  <div class="date-top">
    <span class="date-label">${fmtDateDE(day.date)}</span>
    <span class="date-cloud" title="In Cloud gespeichert?">${day.hasCloud ? "‚òÅÔ∏è" : ""}</span>
  </div>
  <div class="date-actions">
    <button class="btn ghost btn-xs" data-del-day="${day.date}">L√∂schen</button>
  </div>
</div>

<!-- Spalte B: Messungen -->
<div class="col-measure">
<div class="measure-head">
<div></div>
<div>Sys</div><div>Dia</div><div>Puls</div><div>MAP</div>
</div>
<div class="measure-grid">
<div class="measure-row">
<div class="label">morgens</div>
<div class="num ${ (day.morning.sys!=null && day.morning.sys>130) ? 'alert' : '' }">${dash(day.morning.sys)}</div>
<div class="num ${ (day.morning.dia!=null && day.morning.dia>90)  ? 'alert' : '' }">${dash(day.morning.dia)}</div>
<div class="num">${dash(day.morning.pulse)}</div>
<div class="num ${ (day.morning.map!=null && day.morning.map>100) ? 'alert' : '' }">${dash(fmtNum(day.morning.map))}</div>
</div>
<div class="measure-row">
<div class="label">abends</div>
<div class="num ${ (day.evening.sys!=null && day.evening.sys>130) ? 'alert' : '' }">${dash(day.evening.sys)}</div>
<div class="num ${ (day.evening.dia!=null && day.evening.dia>90)  ? 'alert' : '' }">${dash(day.evening.dia)}</div>
<div class="num">${dash(day.evening.pulse)}</div>
<div class="num ${ (day.evening.map!=null && day.evening.map>100) ? 'alert' : '' }">${dash(fmtNum(day.evening.map))}</div>
</div>
</div>
</div>

<!-- Spalte C: Spezial -->
<div class="col-special">
  <div class="weight-line">
    <div>Gewicht</div>
    <div class="num">${dash(fmtNum(day.weight))}</div>
  </div>

  <div class="waist-line">
    <div>Bauchumfang (cm)</div>
    <div class="num">${dash(fmtNum(day.waist_cm))}</div>
  </div>

<div class="flags">
<div class="flag"><span class="flag-box ${onClass(day.flags.water_lt2)}"></span><span>&lt;2L Wasser</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.salt_gt5)}"></span><span>Salz &gt;5g</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.sugar_gt10)}"></span><span>Zucker &gt;10g</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.sick)}"></span><span>Krank</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.meds)}"></span><span>Medikamente</span></div>
<div class="flag"><span class="flag-box ${onClass(day.flags.training)}"></span><span>Training</span></div>
</div>

<div class="notes">${nl2br((day.notes || "").trim() || "‚Äì")}</div>
</div>
</section>
`;

// 4) Rendern oder Leerzustand
if (!daysArr.length){
  host.innerHTML = `<div class="small" style="text-align:center;opacity:.7;padding:12px">Keine Eintr√§ge im Zeitraum</div>`;
} else {
  host.innerHTML = daysArr.map(renderDoctorDay).join("");

  // üîπ Tages-L√∂schbuttons (l√∂scht ALLE Eintr√§ge dieses Datums ‚Äì lokal + remote)
  host.querySelectorAll('[data-del-day]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const date = btn.getAttribute('data-del-day');
      if (!date) return;
      if (!confirm(`Alle Eintr√§ge f√ºr ${date} l√∂schen? (Cloud-Eintr√§ge werden ‚Äì falls m√∂glich ‚Äì mitgel√∂scht)`)) return;

      btn.disabled = true;
      const old = btn.textContent;
      btn.textContent = 'L√∂sche‚Ä¶';

      try{
        const all = await getAllEntries();
        const ofDay = all.filter(e => e.date === date);
        // 1) Remote l√∂schen (falls remote_id vorhanden)
        for (const e of ofDay){
          if (e.remote_id){
            const r = await deleteRemote(e.remote_id);
            if (!r.ok){
              alert(`Server-L√∂schung fehlgeschlagen (${r.status||"?"}) f√ºr einen Eintrag am ${date}. Vorgang abgebrochen.`);
              btn.disabled = false; btn.textContent = old;
              return;
            }
          }
        }
        // 2) Lokal l√∂schen
        for (const e of ofDay){
          await deleteEntryLocal(e.id);
        }
        // 3) UI aktualisieren
        await renderDoctor();
        if (chartPanel.open) chartPanel.draw();
      } finally {
        btn.disabled = false;
        btn.textContent = old;
      }
    });
  });
}
}
  
/* ===== Simple SVG Chart (Daily) ‚Äì final, ohne Doppel-Helper & mit WHO-Ampel ===== */

/* Fallbacks nur, wenn extern nicht verf√ºgbar */
const safeEnsureSupabaseClient = async () => {
  try { if (typeof ensureSupabaseClient === "function") return await ensureSupabaseClient(); } catch(_) {}
  return null;
};
const safeGetConf = async (k) => {
  try { if (typeof getConf === "function") return await getConf(k); } catch(_) {}
  return null;
};

const chartPanel = {
  el: null,
  svg: null,
  legend: null,
  open: false,
  tip: null,
  tipSticky: false,

  init() {
    this.el = $("#chart");
    this.svg = $("#chartSvg");
    this.legend = $("#chartLegend");

    // Panel initial nicht anzeigen
    if (this.el) this.el.style.display = "none";

    // Close + Metric-Select
    const closeBtn = $("#chartClose");
    if (closeBtn) closeBtn.addEventListener("click", () => this.hide());
    const metricSel = $("#metricSel");
    if (metricSel) metricSel.addEventListener("change", () => this.draw());

    // Tooltip (hover/click)
    const contentHost = this.el?.querySelector(".content") || this.el || document.body;
    const tip = document.createElement("div");
    Object.assign(tip.style, {
      position: "absolute",
      inset: "auto auto auto auto",
      transform: "translate(8px,8px)",
      display: "none",
      pointerEvents: "none",
      zIndex: 2,
      background: "#10131a",
      border: "1px solid #2b2f3a",
      borderRadius: "8px",
      padding: "8px 10px",
      fontSize: "12px",
      lineHeight: "1.35",
      maxWidth: "280px",
      boxShadow: "0 6px 18px rgba(0,0,0,.35)",
      color: "var(--fg)",
    });
    tip.id = "chartTip";
    contentHost.style.position = "relative";
    contentHost.appendChild(tip);
    this.tip = tip;

    // Interaktivit√§t
    if (this.svg) {
      this.svg.addEventListener("pointermove", (e) => {
        if (this.tipSticky) return;
        const tgt = e.target;
        const hasNote = tgt && tgt.classList.contains("pt") && tgt.getAttribute("data-note");
        if (!hasNote) { this.hideTip(); return; }
        this.fillTipFromTarget(tgt);
        this.positionTip(e);
      });

      this.svg.addEventListener("pointerleave", () => {
        if (this.tipSticky) return;
        this.hideTip();
      });

      // Click/Tap: Tooltip toggeln (mobil-freundlich)
      this.svg.addEventListener("click", (e) => {
        const tgt = e.target;
        const hasNote = tgt && tgt.classList.contains("pt") && tgt.getAttribute("data-note");
        if (!hasNote) {
          if (this.tipSticky) { this.tipSticky = false; this.hideTip(); }
          return;
        }
        this.fillTipFromTarget(tgt);
        this.tipSticky = !this.tipSticky;
        this.positionTip(e);
      });
    }

    // Redraw bei Resize/Orientation
    if (this.el) {
      const ro = new ResizeObserver(() => { if (this.open) this.draw(); });
      ro.observe(this.el);
      this._ro = ro;
    }
    window.addEventListener("orientationchange", () => {
      setTimeout(() => { if (this.open) this.draw(); }, 150);
    });

    // KPI-Box: Felder sicherstellen
    this.ensureKpiFields();
  },

  toggle() {
    this.open = !this.open;
    if (this.el) this.el.style.display = this.open ? "block" : "none";
  },

  hide() {
    this.open = false;
    if (this.el) this.el.style.display = "none";
    this.tipSticky = false;
    this.hideTip();
  },

  // ----- Helpers -----
  async getFiltered() {
    const entries = typeof getAllEntries === "function" ? await getAllEntries() : [];
    const from = $("#from")?.value;
    const to   = $("#to")?.value;
    return entries
      .filter(e => {
        if (from && e.date < from) return false;
        if (to   && e.date > to)   return false;
        return true;
      })
      .sort((a,b) => (a.ts ?? Date.parse(a.dateTime)) - (b.ts ?? Date.parse(b.dateTime)));
  },

  // H√∂he laden (Konfig oder Fallback 183 cm)
  async getHeightCm() {
    // 1) Supabase-Profil
    const supa = await safeEnsureSupabaseClient();
    if (supa) {
      try {
        const { data, error } = await supa.from("user_profile").select("height_cm").single();
        if (!error && data?.height_cm) return Number(data.height_cm);
      } catch(_) {}
    }
    // 2) lokale Konfig
    const v = await safeGetConf("height_cm");
    const n = Number(v);
    if (Number.isFinite(n) && n > 0) return n;
    return 183;
  },

  // Tooltip
  hideTip() {
    if (this.tip) {
      this.tip.style.display = "none";
      this.tip.textContent = "";
    }
  },
  positionTip(e) {
    if (!this.tip || !this.el) return;
    const hostRect = (this.el.querySelector(".content") || this.el).getBoundingClientRect();
    const x = e.clientX - hostRect.left;
    const y = e.clientY - hostRect.top;
    this.tip.style.left = `${x + 10}px`;
    this.tip.style.top  = `${y + 10}px`;
    if (this.tip.style.display !== "block") this.tip.style.display = "block";
  },
  fillTipFromTarget(tgt) {
    if (!this.tip) return;
    const note = tgt.getAttribute("data-note") || "";
    if (!note) { this.hideTip(); return; }
    this.tip.innerHTML = `<div style="white-space:pre-wrap">${esc(note)}</div>`;
  },

  /* ---------- KPI-Felder + WHO-Ampellogik ---------- */
  ensureKpiFields() {
    const box = $("#chartAverages");
    if (!box) return;
    const need = [
      { k: "sys",  label: "Durchschnitt Sys: ‚Äì" },
      { k: "dia",  label: "Durchschnitt Dia: ‚Äì" },
      { k: "map",  label: "Durchschnitt MAP: ‚Äì" },
      { k: "bmi",  label: "BMI (letzter): ‚Äì" },
      { k: "whtr", label: "WHtR (letzter): ‚Äì" },
    ];
    need.forEach((n) => {
      if (!box.querySelector(`[data-k="${n.k}"]`)) {
        const span = document.createElement("span");
        span.setAttribute("data-k", n.k);
        span.textContent = n.label;
        box.appendChild(span);
      }
    });
  },

  // WHO-Farben
  kpiColorBMI(v) {
    if (v == null) return "#9aa3af";        // unknown
    if (v < 18.5) return "#60a5fa";         // untergew.
    if (v < 25)   return "#10b981";         // normal
    if (v < 30)   return "#f59e0b";         // √ºbergew.
    return "#ef4444";                        // adip√∂s
  },
  kpiColorWHtR(v) {
    if (v == null) return "#9aa3af";
    if (v < 0.5)   return "#10b981";        // ok
    if (v <= 0.6)  return "#f59e0b";        // erh√∂ht
    return "#ef4444";                        // hoch
  },

  // Ein Punkt pro KPI, korrekt eingef√§rbt; saubere Separatoren
  layoutKpis() {
    const box = $("#chartAverages");
    if (!box) return;

    // 1) Alle alten Deko-Elemente entfernen (auch statische .sep aus dem HTML!)
    [...box.querySelectorAll(".kpi-dot, .kpi-sep, .sep")].forEach(n => n.remove());

    // 2) Sichtbare KPI-Spans ermitteln (display != "none")
    const items = [...box.querySelectorAll('[data-k]')].filter(el => el.style.display !== "none");

    // 3) Pro Item farbigen Punkt einsetzen + exakt einen Separator zwischen Items
    const makeDot = (color) => {
      const d = document.createElement("span");
      d.className = "kpi-dot";
      Object.assign(d.style, {
        display: "inline-block",
        width: "8px", height: "8px",
        borderRadius: "50%",
        margin: "0 8px 0 12px",
        background: color,
        verticalAlign: "middle"
      });
      return d;
    };
    const makeSep = () => {
      const s = document.createElement("span");
      s.className = "kpi-sep";
      s.textContent = "‚Ä¢";
      Object.assign(s.style, {
        color: "#6b7280",
        margin: "0 10px",
        userSelect: "none"
      });
      return s;
    };

    items.forEach((el, idx) => {
      let color = "#9aa3af";
      const k = el.getAttribute("data-k");

      // Wert aus Text extrahieren (erste Zahl im Text)
      const m = el.textContent.match(/([\d.]+)/);
      const v = m ? parseFloat(m[1]) : null;

      if (k === "bmi") {
        color = this.kpiColorBMI(Number.isFinite(v) ? v : null);
      } else if (k === "whtr") {
        color = this.kpiColorWHtR(Number.isFinite(v) ? v : null);
      } else {
        // BP-KPIs neutral blau
        color = "#60a5fa";
      }

      el.before(makeDot(color));
      if (idx < items.length - 1) el.after(makeSep());
    });

    box.style.display = items.length ? "inline-flex" : "none";
    box.style.alignItems = "center";
  },

  // ----- Zeichnen -----
  async draw() {
    const t0 = performance.now?.() ?? Date.now();
if (!(await isLoggedIn())) {
  if (this.svg) this.svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Bitte anmelden</text>';
  if (this.legend) this.legend.innerHTML = "";
  return;
}
const metric = $("#metricSel")?.value || "bp";

    const data   = await this.getFiltered();

    // X-Basis
    const xsAll = data.map(e => e.ts ?? Date.parse(e.dateTime));
    let series = [];
    let X = xsAll;

    // KPI-Box
    const avgBox = $("#chartAverages");

    // Schwellen (nur BP)
    const TH_SYS = 130;
    const TH_DIA = 90;

    // Tagesstempel (UTC, 00:00)
    const toDayTs = (isoDate /* "YYYY-MM-DD" */) => {
      if (!isoDate) return NaN;
      const [y, m, d] = isoDate.split("-").map(Number);
      return Date.UTC(y, (m || 1) - 1, d || 1);
    };

    // Tageskommentare (erste Zeile)
    const notesByDate = new Map();
    for (const e of data) {
      const hasDayLike = e?.context === "Tag" || isWeightOnly(e);
      const txt = (e?.notes || "").trim();
      if (hasDayLike && txt) {
        const firstLine = txt.split(/\r?\n/)[0].trim();
        if (firstLine) notesByDate.set(e.date, firstLine);
      }
    }

    // F√ºr BP ben√∂tigen wir Meta je Punkt
    let meta = null;

    if (metric === "bp") {
      // Nur echte Messungen
      const mData = data.filter(
        e => (e.context === "Morgen" || e.context === "Abend") && (e.sys != null || e.dia != null)
      );

      // Meta
      meta = mData.map(e => ({
        date: e.date,
        ctx:  e.context,
        sys:  e.sys != null ? Number(e.sys) : null,
        dia:  e.dia != null ? Number(e.dia) : null,
        note: notesByDate.get(e.date) || "",
      }));

      // X auf Tage normalisieren
      const xsBP = mData.map(e => toDayTs(e.date));

      // Werte-Reihen (Index passend zu meta)
      const sysM = mData.map(e => (e.context === "Morgen" && e.sys != null) ? Number(e.sys) : null);
      const sysA = mData.map(e => (e.context === "Abend"  && e.sys != null) ? Number(e.sys) : null);
      const diaM = mData.map(e => (e.context === "Morgen" && e.dia != null) ? Number(e.dia) : null);
      const diaA = mData.map(e => (e.context === "Abend"  && e.dia != null) ? Number(e.dia) : null);

      // KPIs (√∏ √ºber alle Messungen)
      const avg = (arr) => {
        const v = arr.filter(x => x != null);
        return v.length ? v.reduce((p,c) => p + c, 0) / v.length : null;
      };
      const mapArr = mData.map(e =>
        e.sys != null && e.dia != null
          ? Number(e.dia) + (Number(e.sys) - Number(e.dia)) / 3
          : null
      );

      if (avgBox) {
        const avgSys = avg(mData.map(e => (e.sys != null ? Number(e.sys) : null)));
        const avgDia = avg(mData.map(e => (e.dia != null ? Number(e.dia) : null)));
        const avgMap = avg(mapArr);

        const f0 = (v) => (v == null ? "‚Äì" : Math.round(v).toString());

        // Zeige BP-KPIs, blende BMI/WHtR aus
        const sEl  = avgBox.querySelector('[data-k="sys"]');
        const dEl  = avgBox.querySelector('[data-k="dia"]');
        const mEl  = avgBox.querySelector('[data-k="map"]');
        const bmiEl  = avgBox.querySelector('[data-k="bmi"]');
        const whtrEl = avgBox.querySelector('[data-k="whtr"]');
        if (sEl)  { sEl.style.display  = ""; sEl.textContent  = "Durchschnitt Sys: " + f0(avgSys); }
        if (dEl)  { dEl.style.display  = ""; dEl.textContent  = "Durchschnitt Dia: " + f0(avgDia); }
        if (mEl)  { mEl.style.display  = ""; mEl.textContent  = "Durchschnitt MAP: " + f0(avgMap); }
        if (bmiEl)  bmiEl.style.display  = "none";
        if (whtrEl) whtrEl.style.display = "none";

        avgBox.style.display = (avgSys != null || avgDia != null || avgMap != null) ? "inline-flex" : "none";
        this.layoutKpis();
      }

      // Serien definieren
      series = [
        { name: "Sys Morgens", values: sysM, color: "#93c5fd", type: "sys" },
        { name: "Sys Abends",  values: sysA, color: "#2563eb", type: "sys" },
        { name: "Dia Morgens", values: diaM, color: "#f9a8d4", type: "dia" },
        { name: "Dia Abends",  values: diaA, color: "#db2777", type: "dia" },
      ];

      X = xsBP; // wichtig
} else if (metric === "weight") {
  // Serien: Gewicht + Bauchumfang
  series = [
    {
      name: "Gewicht (kg)",
      values: data.map(e => e.weight != null ? Number(e.weight) : null),
      color: "#f59e0b", // Amber
      type: "misc",
    },
    {
      name: "Bauchumfang (cm)",
      values: data.map(e => e.waist_cm != null ? Number(e.waist_cm) : null),
      color: "#10b981", // Gr√ºn
      type: "misc",
    }
  ];

  // KPI-Leiste: BMI & WHtR aus dem LETZTEN verf√ºgbaren Wert
  if (avgBox) {
    // BP-KPIs ausblenden
    ["sys","dia","map"].forEach(k => {
      const el = avgBox.querySelector(`[data-k="${k}"]`);
      if (el) el.style.display = "none";
    });

    // letzten Weight/Bauchumfang finden (data ist aufsteigend sortiert)
    let lastWeight = null, lastWaist = null;
    for (let i = data.length - 1; i >= 0; i--) {
      if (lastWeight == null && data[i].weight   != null) lastWeight = Number(data[i].weight);
      if (lastWaist  == null && data[i].waist_cm != null) lastWaist  = Number(data[i].waist_cm);
      if (lastWeight != null && lastWaist != null) break;
    }

    const heightCm = await this.getHeightCm();
    const hM = heightCm > 0 ? heightCm / 100 : null;

    const bmi  = (lastWeight != null && hM)         ? lastWeight / (hM * hM) : null;
    const whtr = (lastWaist  != null && heightCm>0) ? lastWaist  / heightCm  : null;

    const bmiEl  = avgBox.querySelector('[data-k="bmi"]');
    const whtrEl = avgBox.querySelector('[data-k="whtr"]');

    if (bmiEl)  { bmiEl.textContent  = `BMI (letzter): ${bmi  == null ? "‚Äì" : bmi.toFixed(1)}`;  bmiEl.style.display  = ""; }
    if (whtrEl) { whtrEl.textContent = `WHtR (letzter): ${whtr == null ? "‚Äì" : whtr.toFixed(2)}`; whtrEl.style.display = ""; }

    avgBox.style.display = "inline-flex";
    this.layoutKpis();
  }
}

    // --- Render-Prep ---
    if (this.svg) this.svg.innerHTML = "";
    if (this.legend) this.legend.innerHTML = "";
    if (!this.tipSticky) this.hideTip();

    const hasAny = series.some(s => s.values.some(v => v != null));
    if (!hasAny) {
      if (this.svg) this.svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#9aa3af" font-size="14">Keine darstellbaren Werte</text>';
      return;
    }

    // Dynamische Gr√∂√üe
    const bbox = this.svg?.getBoundingClientRect?.() || { width: 640, height: 280 };
    const W = Math.max(300, Math.floor(bbox.width  || 640));
    const H = Math.max(200, Math.floor(bbox.height || 280));
    if (this.svg) this.svg.setAttribute("viewBox", `0 0 ${W} ${H}`);

    const PL = 48, PR = 16, PT = 12, PB = 28;
    const innerW = W - PL - PR, innerH = H - PT - PB;

    // === Flags -> X-Bereich erweitern ===
    let flagTs = [];
    if (metric === "bp") {
      const dayFlagsTmp = new Map(); // date -> { training:bool, bad:int, seen:{} }
      for (const e of data) {
        if (!e?.date) continue;
        let rec = dayFlagsTmp.get(e.date);
        if (!rec) {
          rec = {
            training: false,
            bad: 0,
            seen: { water: false, salt: false, sugar: false, sick: false, meds: false },
          };
          dayFlagsTmp.set(e.date, rec);
        }
        if (e.training) rec.training = true;
        const meds = !!(e.valsartan_missed || e.forxiga_missed || e.nsar_taken);
        const flags = {
          water: !!e.low_intake,
          salt:  !!e.salt_high,
          sugar: !!e.sugar_high,
          sick:  !!e.sick,
          meds,
        };
        for (const k of Object.keys(flags)) {
          if (flags[k] && !rec.seen[k]) { rec.seen[k] = true; rec.bad++; }
        }
      }
      flagTs = [...dayFlagsTmp.keys()].map(d => Date.parse(d + "T00:00:00Z"));
    }

    // Skalen
    const xVals = X.filter(t => Number.isFinite(t));
    let xmin = Math.min(...xVals);
    let xmax = Math.max(...xVals);

    if (!Number.isFinite(xmin) || !Number.isFinite(xmax)) {
      // Fallback
      xmin = Date.now() - 7 * 864e5;
      xmax = Date.now();
    }

    // Union mit Flag-Tagen
    if (metric === "bp" && flagTs.length) {
      xmin = Math.min(xmin, Math.min(...flagTs));
      xmax = Math.max(xmax, Math.max(...flagTs));
    }

    // Padding (2%)
    const pad = xmax > xmin ? (xmax - xmin) * 0.02 : 0;
    xmin -= pad; xmax += pad;

    const allY   = series.flatMap(s => s.values.filter(v => v != null));
    const yminRaw = Math.min(...allY);
    const ymaxRaw = Math.max(...allY);
    const range   = Math.max(1, ymaxRaw - yminRaw);
    const ypad    = Math.max(range * 0.08, 1);
    const y0 = yminRaw - ypad;
    const y1 = ymaxRaw + ypad;

    const x = (t) => PL + ((t - xmin) / Math.max(1, xmax - xmin)) * innerW;
    const y = (v) => PT + (1 - (v - y0) / Math.max(1, y1 - y0)) * innerH;

    const line = (x1,y1_,x2,y2,stroke,dash="") =>
      `<line x1="${x1}" y1="${y1_}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="1" ${dash ? `stroke-dasharray="${dash}"` : ""} />`;
    const text = (tx,ty,str,anchor="end") =>
      `<text x="${tx}" y="${ty}" fill="#9aa3af" font-size="11" text-anchor="${anchor}">${esc(str)}</text>`;

    // Grid + Labels
    let grid = "";
    const ticks = 9;
    for (let i=0; i<=ticks; i++) {
      const vv = y0 + (i * (y1 - y0)) / ticks;
      const yy = y(vv);
      grid += line(PL, yy, W-PR, yy, "#2a3140");
      grid += text(PL - 6, yy + 4, Math.round(vv).toString());
    }
    // vertikale Wochenlinien + Datum
    const week = 7 * 24 * 3600 * 1000;
    let start = xmin - (xmin % week) + week;
    for (let t = start; t < xmax; t += week) {
      const xx = x(t);
      grid += line(xx, PT, xx, H - PB, "#1b1f28", "3 3");
      const d = new Date(t);
      const lbl = `${String(d.getDate()).padStart(2,"0")}.${String(d.getMonth()+1).padStart(2,"0")}.`;
      grid += text(xx, H - 8, lbl, "middle");
    }
    // Achsen
    grid += line(PL, PT, PL, H - PB, "#2b2f3a");
    grid += line(PL, H - PB, W - PR, H - PB, "#2b2f3a");

    // Schwellenlinien (BP)
    if (metric === "bp") {
      const ySys = y(TH_SYS);
      const yDia = y(TH_DIA);
      grid += line(PL, ySys, W - PR, ySys, "#ef4444", "6 4");
      grid += line(PL, yDia, W - PR, yDia, "#ef4444", "6 4");
grid += text(W - PR - 2, ySys + 4, "Sys 130", "end");
grid += text(W - PR - 2, yDia  + 4, "Dia 90",  "end");
    }

    if (this.svg) this.svg.insertAdjacentHTML("beforeend", grid);

    // === Flags Overlay (nur BP) ===
    if (metric === "bp" && this.svg) {
      const dayFlags = new Map(); // date -> { training:bool, badCount:int, seen:{} }
      for (const e of data) {
        if (!e?.date) continue;
        let rec = dayFlags.get(e.date);
        if (!rec) {
          rec = { training:false, badCount:0, seen:{ water:false, salt:false, sugar:false, sick:false, meds:false } };
          dayFlags.set(e.date, rec);
        }
        if (e.training) rec.training = true;
        const meds = !!(e.valsartan_missed || e.forxiga_missed || e.nsar_taken);
        const flags = {
          water: !!e.low_intake, salt: !!e.salt_high, sugar: !!e.sugar_high, sick: !!e.sick, meds
        };
        for (const k of Object.keys(flags)) {
          if (flags[k] && !rec.seen[k]) { rec.seen[k] = true; rec.badCount++; }
        }
      }

      const toDayTsLocal = (iso) => Date.parse(iso + "T00:00:00Z");
      const flaggedDays = [...dayFlags.keys()]
        .filter(d => {
          const r = dayFlags.get(d);
          return r && (r.training || r.badCount > 0);
        })
        .sort();

      if (flaggedDays.length) {
        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.setAttribute("class","flags");
        g.setAttribute("pointer-events","none");
        g.setAttribute("aria-hidden","true");

        const uniqDays = [...new Set([...flaggedDays.map(d => toDayTsLocal(d)), ...X.filter(Boolean)])].sort((a,b)=>a-b);
        const dayXs = uniqDays.map(t => x(t));
        const minStep = dayXs.length > 1 ? Math.min(...dayXs.slice(1).map((v,i)=>v - dayXs[i])) : innerW;
        const bandW   = Math.max(10, Math.floor(minStep * 0.45));
        const yBottom = PT + innerH;
        const slotH   = innerH / 6; // 1 Training + bis zu 5 Bad

        for (const d of flaggedDays) {
          const t = toDayTsLocal(d);
          const cx = x(t), xLeft = Math.round(cx - bandW/2);
          const rec = dayFlags.get(d);
          let used = 0;

          // Training (gr√ºn)
          if (rec.training) {
            const yTop = Math.round(yBottom - (used + 1) * slotH);
            const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
            r.setAttribute("x", xLeft); r.setAttribute("y", yTop);
            r.setAttribute("width", bandW); r.setAttribute("height", Math.ceil(slotH));
            r.setAttribute("fill", "#10b981"); r.setAttribute("fill-opacity","0.22");
            r.setAttribute("stroke", "#fff");  r.setAttribute("stroke-opacity","0.06");
            r.setAttribute("shape-rendering","crispEdges");
            g.appendChild(r);
            used++;
          }
          // Bad-Flags (rot gestapelt)
          for (let i=0; i<rec.badCount; i++) {
            const yTop = Math.round(yBottom - (used + 1) * slotH);
            const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
            r.setAttribute("x", xLeft); r.setAttribute("y", yTop);
            r.setAttribute("width", bandW); r.setAttribute("height", Math.ceil(slotH));
            r.setAttribute("fill", "#ef4444"); r.setAttribute("fill-opacity","0.18");
            r.setAttribute("stroke", "#fff");  r.setAttribute("stroke-opacity","0.06");
            r.setAttribute("shape-rendering","crispEdges");
            g.appendChild(r);
            used++;
          }
        }
        this.svg.appendChild(g); // hinter den Linien/Punkten
      }
    }

    // Linien + Punkte
const isFiniteTs = (t) => Number.isFinite(t);

const mkPath = (values, color) => {
  let d = "";
  values.forEach((v,i) => {
    if (v == null || !isFiniteTs(X[i])) return; // statt !X[i]
    d += (d === "" ? "M" : "L") + `${x(X[i]).toFixed(1)},${y(v).toFixed(1)} `;
  });
  return `<path d="${d}" fill="none" stroke="${color}" stroke-width="2.2" />`;
};

const mkDots = (values, color, kind) => {
  let out = "";
  values.forEach((v, i) => {
    if (v == null || !Number.isFinite(X[i])) return;
    const cx = x(X[i]).toFixed(1);
    const cy = y(v).toFixed(1);

    // Tooltip-Infos (nur bei BP vorhanden)
    const m = (kind === "sys" || kind === "dia") ? (meta?.[i] || {}) : {};
    const date = m.date || "";
    const ctx  = m.ctx  || "";
    const note = m.note || "";

    out += `<circle class="pt" cx="${cx}" cy="${cy}" r="2.6" fill="${color}"
               data-kind="${esc(kind)}" data-val="${v}"
               data-date="${esc(date)}" data-ctx="${esc(ctx)}"
               data-note="${esc(note)}" />`;
  });
  return out;
};

const mkAlertDots = (seriesItem) => {
  if (metric !== "bp") return "";
  const isSys = seriesItem.type === "sys";
  const thr   = isSys ? TH_SYS : TH_DIA;
  const kind  = isSys ? "sys" : "dia";
  let out = "";
  seriesItem.values.forEach((v, i) => {
    if (v == null || !isFiniteTs(X[i])) return;
    if (v > thr) {
      const cx = x(X[i]).toFixed(1), cy = y(v).toFixed(1);
      const m = meta?.[i] || {};
      out += `<circle class="pt" cx="${cx}" cy="${cy}" r="5.2" fill="#ef4444" stroke="#000" stroke-width="0.8"
               data-kind="${kind}" data-val="${v}"
               data-date="${esc(m.date || "")}" data-ctx="${esc(m.ctx || "")}"
               data-note="${esc(m.note || "")}" />`;
    }
  });
  return out;
};

    // Zeichnen
    series.forEach((s) => {
      if (!this.svg) return;
      this.svg.insertAdjacentHTML("beforeend", mkPath(s.values, s.color));
      this.svg.insertAdjacentHTML(
        "beforeend",
        mkDots(s.values, s.color, (s.type === "sys" || s.type === "dia") ? s.type : "misc")
      );
      if (metric === "bp") {
        this.svg.insertAdjacentHTML("beforeend", mkAlertDots(s));
      }
      // Legende
      if (this.legend) {
        const wrap = document.createElement("span");
        wrap.style.display = "inline-flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        const dot = Object.assign(document.createElement("span"), { className: "dot" });
        dot.style.background = s.color;
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        const label = document.createElement("span");
        label.textContent = s.name;
        wrap.append(dot, label);
        this.legend.appendChild(wrap);
      }
    });

    if (this.tipSticky) { this.tipSticky = false; this.hideTip(); }

    const sPerf = (perfStats.add?.("drawChart", (performance.now?.() ?? Date.now()) - t0), perfStats.snap?.("drawChart")) || {p50:0,p95:0,p99:0,count:0};
    diag.add?.(`[perf] drawChart p50=${sPerf.p50|0}ms p95=${sPerf.p95|0}ms p99=${sPerf.p99|0}ms (n=${sPerf.count})`);
  },
};

/* --- Button-Flash (nur Platzhalter, wie gehabt) --- */
let saveFlashTimer = null;
function flashSaveOk(){
  const btn = document.getElementById('saveAllBtn');
  if(!btn) return;
  if (saveFlashTimer) { clearTimeout(saveFlashTimer); saveFlashTimer = null; }
  btn.disabled = true; btn.classList.add('flash'); btn.innerHTML = '‚úîÔ∏è Events gespeichert';
  saveFlashTimer = setTimeout(()=>{ btn.classList.remove('flash'); btn.innerHTML = 'üíæ Speichern'; btn.disabled = false; saveFlashTimer = null; }, 1000);
}

/* ===== Tabs / Segments ===== */
async function setTab(name){
  if (name === "doctor"){
    if (!(await isLoggedIn())){
      showLoginOverlay(true);
      name = "capture";
    }
  }
  $$(".view").forEach(v => v.classList.remove("active"));
  $("#"+name).classList.add("active");
  $$(".tabs .btn").forEach(b =>
    b.classList.toggle("primary", b.dataset.tab === name)
  );
  if (name === "doctor") { renderDoctor(); }
}

function bindTabs(){
  $$(".tabs .btn").forEach(b =>
    b.addEventListener("click", async (e) => {
      const tab = e.currentTarget.dataset.tab;
      if (tab === "doctor" && !(await isLoggedIn())){
        showLoginOverlay(true);
        return;
      }
      setTab(tab);
    })
  );
}

/* ===== Save flows ===== */
let trainingActive=false, lowIntakeActive=false, sickActive=false, valsartanMissed=false, forxigaMissed=false, nsarTaken=false,
saltHigh=false, sugarHigh=false;
function setToggle(el, on, activeText, baseText){
el.classList.toggle("active", !!on);
el.setAttribute("aria-pressed", on ? "true" : "false");
el.textContent = on ? activeText : baseText;
}
function setTraining(on){ trainingActive=!!on; setToggle($("#trainingToggle"), trainingActive, "üèãÔ∏è Training heute (aktiv)", "üèãÔ∏è Training heute"); }
function setLowIntake(on){ lowIntakeActive=!!on; setToggle($("#lowIntakeToggle"), lowIntakeActive, "üö∞ < 2 L ‚Äì aktiv", "üö∞ < 2 L getrunken"); }
function setSaltHigh(on){ saltHigh = !!on; setToggle($("#saltHighToggle"), saltHigh, "üßÇ > 5 g Salz ‚Äì aktiv", "üßÇ > 5 g Salz"); }
function setSugarHigh(on){ sugarHigh = !!on; setToggle($("#sugarHighToggle"), sugarHigh, "üç¨ > 10 g Zucker ‚Äì aktiv", "üç¨ > 10 g Zucker"); }

function setSick(on){
sickActive=!!on; setToggle($("#sickToggle"), sickActive, "ü§í Krank (Forxiga pausiert) ‚Äì aktiv", "ü§í Krank (Forxiga pausiert)");
if(sickActive){ setForxigaMiss(true); $("#forxigaMissToggle").disabled=true; $("#forxigaMissToggle").style.opacity=0.6; }
else { $("#forxigaMissToggle").disabled=false; $("#forxigaMissToggle").style.opacity=1; }
}
function setValsartanMiss(on){ valsartanMissed=!!on; setToggle($("#valsartanMissToggle"), valsartanMissed, "üíä Valsartan vergessen ‚Äì aktiv", "üíä Valsartan vergessen"); }
function setForxigaMiss(on){ forxigaMissed=!!on; setToggle($("#forxigaMissToggle"), forxigaMissed, "üíä Forxiga vergessen ‚Äì aktiv", "üíä Forxiga vergessen"); }
function setNsar(on){ nsarTaken=!!on; setToggle($("#nsarToggle"), nsarTaken, "‚ö†Ô∏è NSAR genommen ‚Äì aktiv", "‚ö†Ô∏è NSAR genommen"); }
function blockHasData(which){
return !!(
$(`#time${which}`).value ||
$(`#sys${which}`).value ||
$(`#dia${which}`).value ||
$(`#pulse${which}`).value
);
}
async function saveAll(){
const __t0 = performance.now();
if(!(await isLoggedIn())){ alert("Bitte zuerst mit Google anmelden."); return; }

// 1) Erkennen, was heute eingegeben wurde
const hasM = blockHasData("M"); 
const hasA = blockHasData("A"); 
const weightVal = $("#weightDay")?.value?.trim();
const waistValRaw = $("#input-waist-cm")?.value?.trim();
const notes = ($("#notesDay").value || "").trim();
const hasAnyFlag = !!(trainingActive || lowIntakeActive || sickActive ||
  valsartanMissed || forxigaMissed || nsarTaken ||
  saltHigh || sugarHigh);
const hasDaySummary = !!(weightVal || waistValRaw || hasAnyFlag || notes);

// üî¥ NEU: Kommentarpflicht bei Grenzwert√ºberschreitung
const sysM = Number($("#sysM").value);
const diaM = Number($("#diaM").value);
const sysA = Number($("#sysA").value);
const diaA = Number($("#diaA").value);

const needsComment = 
  (sysM > 130) || (diaM > 90) ||
  (sysA > 130) || (diaA > 90);

const notesEl = $("#notesDay");
notesEl.style.outline = ""; // Reset

if (needsComment && !notes) {
  alert("Bitte Kommentar eingeben bei Grenzwert√ºberschreitung (Sys>130 oder Dia>90).");
  notesEl.focus();
  notesEl.style.outline = "2px solid var(--danger)";
  return;
}

// 2) Speichern in drei klaren Pfaden
let saved = false;
if (hasM) saved = (await saveBlock("Morgen","M", /*includeWeight=*/false, /*force=*/false)) || saved;
if (hasA) saved = (await saveBlock("Abend","A", /*includeWeight=*/false, /*force=*/false)) || saved;
if (hasDaySummary) saved = (await saveDaySummary()) || saved;

if (!saved) { alert("Keine Daten eingegeben ‚Äì nichts zu speichern."); return; }

// 3) UI aktualisieren
await renderDoctor();
if(chartPanel.open) await chartPanel.draw();

{ const s = (perfStats.add('saveEntry', performance.now()-__t0), perfStats.snap('saveEntry'));
diag.add(`[perf] saveEntry p50=${s.p50|0}ms p95=${s.p95|0}ms p99=${s.p99|0}ms (n=${s.count})`); }
flashSaveOk();
}

async function saveBlock(contextLabel, which, includeWeight=false, force=false){
const date = $("#date").value || todayStr();
const time = $(`#time${which}`).value || timeStr();

const sys = $(`#sys${which}`).value ? Number($(`#sys${which}`).value) : null;
const dia = $(`#dia${which}`).value ? Number($(`#dia${which}`).value) : null;
const pulse = $(`#pulse${which}`).value ? Number($(`#pulse${which}`).value) : null;

// Nur vitale Werte; Gewicht NICHT mehr in M/A
const weight = null;

const nothingToSave = !sys && !dia && !pulse;
if (!force && nothingToSave) return false;

const currentISO = new Date(date + "T" + time).toISOString();
const ts = new Date(date + "T" + time).getTime();

const entry = {
date, time, dateTime: currentISO, ts,
context: contextLabel, 
sys, dia, pulse, weight,
map: (sys!=null && dia!=null) ? calcMAP(sys, dia) : null,
notes: "",
training: false,
low_intake: false,
sick: false,
valsartan_missed: false,
forxiga_missed: false,
nsar_taken: false,
salt_high: false,
sugar_high: false
};

const localId = await addEntry(entry);
await syncWebhook(entry, localId);
return true;
}

function baseEntry(date, time, contextLabel){
const iso = new Date(date + "T" + time).toISOString();
const ts = new Date(date + "T" + time).getTime();
return {
date, time, dateTime: iso, ts,
context: contextLabel, 
sys: null, dia: null, pulse: null, weight: null, map: null,
notes: ($("#notesDay").value || "").trim(),
training: trainingActive,
low_intake: lowIntakeActive,
sick: sickActive,
valsartan_missed: valsartanMissed,
forxiga_missed: forxigaMissed,
nsar_taken: nsarTaken,
salt_high: saltHigh,
sugar_high: sugarHigh
};
}

async function saveDaySummary(){
const date = $("#date").value || todayStr();
const time = $("#timeA").value || "19:00";

const entry = baseEntry(date, time, "Tag");

// Gewicht (kg)
const w = $("#weightDay")?.value?.trim();
entry.weight = w ? Number((w||"").replace(',', '.')) : null;

// Bauchumfang (cm)
const waistRaw = $("#input-waist-cm")?.value?.trim();
entry.waist_cm = waistRaw ? toNumDE(waistRaw) : null;

const hasContent =
(entry.weight != null) ||
(entry.waist_cm != null) ||
!!entry.notes ||
entry.training || entry.low_intake || entry.sick ||
entry.valsartan_missed || entry.forxiga_missed ||
entry.nsar_taken || entry.salt_high || entry.sugar_high;

if (!hasContent) return false;

const localId = await addEntry(entry);
await syncWebhook(entry, localId);
return true;
}

async function withRetry(fn, {tries=3, base=300}={}) {
let lastErr;
for (let i=0;i<tries;i++){
try { return await fn(); }
catch (e) {
const code = e?.status ?? e?.response?.status ?? 0;
if (!(code >= 500 && code < 600)) throw e;
await new Promise(r => setTimeout(r, base * Math.pow(2,i)));
lastErr = e;
}
}
throw lastErr;
}
  
async function syncWebhook(entry, localId){
  const url = await getConf("webhookUrl");
  const headers = await getHeaders();
  if(!url || !headers){
    diag.add("Webhook: keine Header/URL ‚Äì vermutlich nicht eingeloggt. Bitte Login ausf√ºhren.");
    showLoginOverlay(true);
    return;
  }

  try{
    const uid = await getUserId();
    const events = toHealthEvents(entry);
    if (!events.length){
      diag.add("Webhook: keine Events zu senden");
      return;
    }

    // POST der Events in einer Batch-Anfrage (array)
    // Supabase akzeptiert JSON-Array f√ºr bulk insert.
    const payload = events.map(ev => (uid ? { ...ev, user_id: uid } : ev));
    const res = await withRetry(()=> fetch(url, { method:"POST", headers, body: JSON.stringify(payload) }));

    if(!res.ok){
      const txt = await res.text().catch(()=>'?');
      diag.add(`Webhook-Fehler ${res.status}: ${txt}`);
      return;
    }

    // Antwort: Liste der eingef√ºgten Events (je ein id)
    const json = await res.json();
    const firstId = json?.[0]?.id ?? null;
    if(firstId != null){
      // Wir mappen EINEN local entry auf mehrere server events.
      // F√ºrs Erfassen brauchen wir nur wissen: "ist was in der Cloud?" -> remote_id setzen.
      await updateEntry(localId, { remote_id: firstId });
      diag.add(`Webhook: OK (${events.length} Event(s))`);
    }
  }catch(e){
    diag.add("Webhook: Netzwerkfehler");
  }
}

/* ===== Realtime / Auto-Sync ===== */
// VORERST deaktiviert ‚Äì Arzt-Ansicht folgt in Schritt 2
async function reconcileFromRemote(){
  // No-Op
}

let sbClient = null;

let __channels = [];
function trackChannel(ch){ __channels.push(ch); return ch; }
function teardownRealtime(){
try{
__channels.forEach(ch => ch.unsubscribe?.());
diag.add(`Realtime: ${__channels.length} Channel(s) unsubscribed`);
}catch(e){ diag.add("Realtime: unsubscribe error"); }
__channels = [];
}

window.addEventListener('beforeunload', teardownRealtime);


function baseUrlFromRest(restUrl){
if(!restUrl) return null;
const i = restUrl.indexOf("/rest/");
return i>0 ? restUrl.slice(0, i) : null;
}

async function getUserId(){
try{
const supa = await ensureSupabaseClient();
if(!supa) return null;
const { data: { user } } = await supa.auth.getUser();
return user?.id ?? null;
}catch{ return null; }
}

async function ensureSupabaseClient(){
if (sbClient) return sbClient;

const rest = await getConf("webhookUrl");
const keyConf = await getConf("webhookKey"); // ANON key (nicht service_role)
if (!rest || !keyConf) { diag.add("Supabase Auth: fehlende Konfiguration"); return null; }

// NEU: niemals mit service_role starten
if (isServiceRoleKey(keyConf)) {
diag.add("Sicherheitsblock: service_role Key erkannt ‚Äì Abbruch");
return null;
}

const supabaseUrl = baseUrlFromRest(rest);
const anonKey = keyConf.replace(/^Bearer\s+/i,"");
if (!supabaseUrl || !anonKey) { diag.add("Supabase Auth: ung√ºltige URL/Key"); return null; }

sbClient = window.supabase.createClient(supabaseUrl, anonKey, {
auth: { persistSession:false, autoRefreshToken:true, detectSessionInUrl:true } // Session nur im RAM
});
diag.add("Supabase: Client (Auth) initialisiert");
return sbClient;
}

// VORERST deaktiviert ‚Äì Arzt-Ansicht + Realtime folgen in Schritt 2
async function setupRealtime(){
  // No-Op
}

// Nur noch "Pending" pushen; kein Pull solange Anzeige noch nicht migriert
async function initialAutoSync(){
  // Vorerst deaktiviert, bis Anzeige komplett auf Events migriert ist.
  diag.add("Auto-Sync: deaktiviert (Event-Migration Phase)");
  return;
}

/* ===== App-Lock (Passkey + PIN) ===== */

/* Kleine Utils */
const u8 = (len)=>{ const a=new Uint8Array(len); crypto.getRandomValues(a); return a; };
const b64u = {
  enc: (buf)=> btoa(String.fromCharCode(...new Uint8Array(buf)))
                .replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''),
  dec: (str)=> Uint8Array.from(atob(str.replace(/-/g,'+').replace(/_/g,'/')), c=>c.charCodeAt(0))
};
async function sha256(text){
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return b64u.enc(buf);
}

/* Config-Keys in IndexedDB.CONF */
const LOCK_ENABLED_KEY   = "app_lock_enabled";     // bool
const LOCK_CRED_ID_KEY   = "lock_cred_id";         // base64url
const LOCK_PIN_HASH_KEY  = "lock_pin_hash";        // SHA-256 b64url
const LOCK_LAST_OK_KEY   = "lock_last_ok";         // timestamp

/* UI Helpers */
function lockUi(on){
  document.body.classList.toggle('app-locked', !!on);
  const ov = document.getElementById('appLock');
  if (ov) ov.style.display = on ? 'flex' : 'none';
}
function setLockMsg(msg){
  const el = document.getElementById('lockMsg');
  if (el) el.textContent = msg || '';
}

/* Setup: Passkey registrieren (platform) */
async function registerPasskey(){
  try{
    const rpId = location.hostname;
    const userId = u8(16);
    const challenge = u8(32);
    const pubKeyOpts = {
      publicKey: {
        challenge,
        rp: { name: "Gesundheits-Logger", id: rpId },
        user: { id: userId, name: "local-user", displayName: "Local User" },
        pubKeyCredParams: [{ type:'public-key', alg:-7 }, { type:'public-key', alg:-257 }],
        timeout: 60000,
        authenticatorSelection: { authenticatorAttachment: 'platform', userVerification: 'preferred', residentKey: 'preferred' },
        attestation: 'none'
      }
    };
    const cred = await navigator.credentials.create(pubKeyOpts);
    if (!cred) throw new Error("Keine Antwort vom Authenticator.");
    const idB64 = b64u.enc(cred.rawId);
    await putConf(LOCK_CRED_ID_KEY, idB64);
    await putConf(LOCK_ENABLED_KEY, true);
    setLockMsg("Passkey eingerichtet ‚úîÔ∏é");
    return true;
  }catch(e){
    setLockMsg("Passkey-Setup fehlgeschlagen: " + (e.message||e));
    return false;
  }
}

/* Entsperren per Passkey (nur Besitz+UV Check ‚Äì lokal ausreichend f√ºr App-Lock) */
async function unlockWithPasskey(){
  try{
    const credId = await getConf(LOCK_CRED_ID_KEY);
    if (!credId){
      setLockMsg("Noch kein Passkey eingerichtet.");
      return false;
    }
    const allow = [{ type:'public-key', id: b64u.dec(credId) }];
    const challenge = u8(32);
    const opts = { publicKey: { challenge, rpId: location.hostname, timeout: 60000, allowCredentials: allow, userVerification:'preferred' } };
    const assertion = await navigator.credentials.get(opts);
    if (!assertion) throw new Error("Abgebrochen.");
    // Lokaler Gate: Erfolg der Challenge => entsperrt
    await putConf(LOCK_LAST_OK_KEY, Date.now());
    lockUi(false);
    return true;
  }catch(e){
    setLockMsg("Passkey fehlgeschlagen: " + (e.message||e));
    return false;
  }
}

/* PIN setzen/pr√ºfen */
async function setPinInteractive(){
  const pin = prompt("Neue PIN (4‚Äì10 Ziffern):") || "";
  if (!/^\d{4,10}$/.test(pin)){ alert("Ung√ºltige PIN."); return false; }
  const hash = await sha256("pin:"+pin);
  await putConf(LOCK_PIN_HASH_KEY, hash);
  await putConf(LOCK_ENABLED_KEY, true);
  setLockMsg("PIN gesetzt ‚úîÔ∏é");
  return true;
}
async function unlockWithPin(){
  const input = document.getElementById('pinInput');
  const pin = (input?.value||"").trim();
  if (!pin){ setLockMsg("PIN eingeben."); return false; }
  const saved = await getConf(LOCK_PIN_HASH_KEY);
  if (!saved){ setLockMsg("Keine PIN hinterlegt."); return false; }
  const hash = await sha256("pin:"+pin);
  if (hash !== saved){ setLockMsg("PIN falsch."); return false; }
  await putConf(LOCK_LAST_OK_KEY, Date.now());
  input.value = "";
  lockUi(false);
  return true;
}

/* Ensure: Lock aktiv? Wann anzeigen? */
async function ensureAppLock(){
  // Nur wenn eingeloggt (sonst regelt loginOverlay)
  if (!(await isLoggedIn())) { lockUi(false); return; }

  // Ist App-Lock konfiguriert/aktiv?
  let enabled = await getConf(LOCK_ENABLED_KEY);
  const hasCred = !!(await getConf(LOCK_CRED_ID_KEY));
  const hasPin  = !!(await getConf(LOCK_PIN_HASH_KEY));
  if (!enabled && (hasCred || hasPin)) enabled = true;

  // Erster Start ohne Setup: Lock optional deaktiviert bis Setup?
  // Wir zeigen den Lock und bieten Setup im Overlay an.
  if (!enabled) {
    // Noch kein Setup? Dann Lock trotzdem anzeigen, aber mit Setup-Buttons.
    lockUi(true);
    setLockMsg(hasCred||hasPin ? "" : "Tipp: Richte Passkey oder PIN ein.");
    return;
  }

  // Aktiv ‚Üí sperren bis entsperrt
  lockUi(true);
  setLockMsg("");
}

/* Events binden (einmal in main()) */
function bindAppLockButtons(){
  const btnPass = document.getElementById('unlockPasskeyBtn');
  const btnPin  = document.getElementById('unlockPinBtn');
  const btnSetPass = document.getElementById('setupPasskeyBtn');
  const btnSetPin  = document.getElementById('setPinBtn');

  if (btnPass) btnPass.addEventListener('click', unlockWithPasskey);
  if (btnPin)  btnPin.addEventListener('click', unlockWithPin);
  if (btnSetPass) btnSetPass.addEventListener('click', registerPasskey);
  if (btnSetPin)  btnSetPin.addEventListener('click', setPinInteractive);
}

/* ===== Main ===== */
async function main(){
diag.init(); helpPanel.init(); await initDB();
try {
const haveUrl = await getConf("webhookUrl");
const haveKey = await getConf("webhookKey");
if (!haveUrl && SUPABASE_URL_DEFAULT) await putConf("webhookUrl", DEFAULT_WEBHOOK_ENTRIES);
if (!haveKey && SUPABASE_ANON_DEFAULT) await putConf("webhookKey", `Bearer ${SUPABASE_ANON_DEFAULT}`);
} catch (_) {}
chartPanel.init(); bindTabs();
$("#date").value = todayStr();
$("#timeM").value = "07:00"; $("#timeA").value = "19:00";
$("#from").value = new Date(Date.now()-90*24*3600*1000).toISOString().slice(0,10);
$("#to").value = todayStr();
setTab("capture");
await ensureSupabaseClient();
bindAuthButtons();
if (sbClient) watchAuthState()

// Wenn schon eingeloggt ? App starten, sonst Login-Leiste zeigen
const hasSession = await requireSession();
if (hasSession) {
  await afterLoginBoot(); // wichtig f√ºr Reload mit persistierter Session
  await ensureAppLock();  // üëà App-Lock direkt nach Boot pr√ºfen/anzeigen
}
bindAppLockButtons();     // üëà Buttons der Lock-Card binden

// Konfiguration laden
const savedUrl = await getConf("webhookUrl");
const savedKey = await getConf("webhookKey");
if (!savedUrl || !savedKey) {
  setTab("capture"); // In Erfassung bleiben
}

// Sanfte Warnung
// === Live-Kommentar-Pflicht: sofort roter Rand bei Grenzwert√ºberschreitung ===
function needsCommentNow(){
  const sysM = Number($("#sysM").value);
  const diaM = Number($("#diaM").value);
  const sysA = Number($("#sysA").value);
  const diaA = Number($("#diaA").value);
  return (sysM > 130) || (diaM > 90) || (sysA > 130) || (diaA > 90);
}
function updateNotesRequirementUI(){
  const notesEl = $("#notesDay");
  if (!notesEl) return;
  const notes = (notesEl.value || "").trim();
  const need = needsCommentNow();
  const invalid = need && !notes;
  notesEl.style.outline = invalid ? "2px solid var(--danger)" : "";
  if (invalid) notesEl.setAttribute("aria-invalid","true"); else notesEl.removeAttribute("aria-invalid");
}
// bei jeder Eingabe der vier BP-Felder + Kommentar selbst neu bewerten
["#sysM","#diaM","#sysA","#diaA","#notesDay"].forEach(sel=>{
  const el = $(sel); if(!el) return;
  el.addEventListener("input", updateNotesRequirementUI);
});
// einmal initial pr√ºfen (falls Werte schon stehen)
updateNotesRequirementUI();

// Toggle-Handler
const bindToggle = (id, setter, getVal)=>{
  const el = $(id);
  el.addEventListener("click", ()=>{
    setter(!getVal());
  });
};
bindToggle("#trainingToggle", setTraining, ()=>trainingActive);
bindToggle("#lowIntakeToggle", setLowIntake, ()=>lowIntakeActive);
bindToggle("#sickToggle", setSick, ()=>sickActive);
bindToggle("#valsartanMissToggle", setValsartanMiss, ()=>valsartanMissed);
bindToggle("#forxigaMissToggle", setForxigaMiss, ()=>forxigaMissed);
bindToggle("#nsarToggle", setNsar, ()=>nsarTaken);
bindToggle("#saltHighToggle", setSaltHigh, ()=>saltHigh);
bindToggle("#sugarHighToggle", setSugarHigh, ()=>sugarHigh);

$("#saveAllBtn").addEventListener("click", saveAll);
$("#applyRange").addEventListener("click", async ()=>{
  await renderDoctor();
setDocBadges({ visible: true });
  if(chartPanel.open) chartPanel.draw();
});

$("#doctorChartBtn").addEventListener("click", async ()=>{
  if (!(await isLoggedIn())){ showLoginOverlay(true); return; }
  setDocBadges({ visible: true });
  chartPanel.open = true;
  chartPanel.el.style.display = 'block';
  await chartPanel.draw();
});

document.addEventListener('keydown', (e)=>{
const isSave = (e.key.toLowerCase()==='s') && (e.ctrlKey || e.metaKey);
if(isSave){ e.preventDefault(); saveAll(); }
});

  $("#doctorExportJson").addEventListener("click", async ()=>{
  const all = await getAllEntries();
  dl("gesundheitslog.json", JSON.stringify(all,null,2), "application/json");
});
  
// Initial Render
await renderDoctor();
setDocBadges({ visible: true });

// --- Failsafe: nach Reload alles sicher freigeben (falls etwas "disabled" h√§ngen blieb)
$$('main input, main select, main textarea, main button, nav.tabs button').forEach(el=>{
  if (el.id !== 'logoutBtn') el.disabled = false;
});
document.body.classList.remove('auth-locked');

function daySummaryActive(){
  const w   = ($("#weightDay")?.value || "").trim();
  const waist = ($("#input-waist-cm")?.value || "").trim();
  const n   = ($("#notesDay")?.value || "").trim();
  return !!(w || waist || n || trainingActive || lowIntakeActive || sickActive ||
    valsartanMissed || forxigaMissed || nsarTaken || saltHigh || sugarHigh);
}

const disableVitals = daySummaryActive();
["#sysM","#diaM","#pulseM","#sysA","#diaA","#pulseA"].forEach(sel=>{
const el = $(sel);
if (!el) return;
el.disabled = disableVitals;
el.style.opacity = disableVitals ? 0.6 : 1;
});

// Auto-Push Pending sobald online
window.addEventListener('online', async ()=>{
const resPush = await pushPendingToRemote();
if(resPush.pushed || resPush.failed){
diag.add(`Online-Push: OK=${resPush.pushed}, FAIL=${resPush.failed}`);
await reconcileFromRemote();
}
});
}

/* boot */
if (document.readyState === "loading") {
window.addEventListener("DOMContentLoaded", main);
} else {
main();
}

/* === Debug-Notizen
- V1.5: Realtime √ºber supabase-js; Projekt-URL aus REST-URL abgeleitet.
- Auto-Sync: push pending ? reconcile (Entries) ohne Wipe.
- Realtime-Events: INSERT/UPDATE ? upsert, DELETE ? lokal entfernen.
- UI-Refresh: Arzt-Ansicht sofort; Charts nur, wenn Panel offen.
=== */
</script>
<!-- Login-Overlay (zentriert) -->
<div id="loginOverlay" style="display:none">
  <div class="login-card" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
    <h3 id="loginTitle">Willkommen</h3>
    <p class="small" style="margin:0 0 8px">Melde dich an, um Arzt-Ansicht & Diagramme zu nutzen.</p>
    <button class="btn primary" id="googleLoginBtn" type="button" style="width:100%;height:48px">Mit Google anmelden</button>
    <button class="btn ghost" id="logoutBtn" type="button" style="display:none;width:100%;height:40px;margin-top:8px">Abmelden</button>
    <div id="whoAmI" class="small" style="text-align:center;margin-top:6px"></div>
  </div>
</div>

<!-- App-Lock Overlay (zentriert) -->
<div id="appLock" style="display:none">
  <div class="lock-card" role="dialog" aria-modal="true" aria-labelledby="lockTitle">
    <h3 id="lockTitle">App gesperrt</h3>
    <p class="small" style="margin:0 0 8px">
      Bitte entsperren: bevorzugt per Passkey (Finger/Face). Alternativ PIN.
    </p>

    <div class="row" style="gap:8px">
      <button class="btn primary" id="unlockPasskeyBtn" type="button" style="width:100%;height:48px">
        Per Passkey entsperren
      </button>
    </div>

    <div class="pin-wrap">
      <input id="pinInput" type="password" inputmode="numeric" autocomplete="off" placeholder="PIN (optional)" />
      <button class="btn ghost" id="unlockPinBtn" type="button">PIN</button>
    </div>

    <div class="small" style="margin-top:8px; opacity:.8">
      <button class="btn ghost" id="setupPasskeyBtn" type="button" style="width:100%;margin-top:6px">
        Passkey einrichten
      </button>
      <button class="btn ghost" id="setPinBtn" type="button" style="width:100%;margin-top:6px">
        PIN setzen/√§ndern
      </button>
    </div>

    <div id="lockMsg" class="small" style="margin-top:6px;color:#6b7280"></div>
  </div>
</div>

</body>
</html>










